<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>librdkafka: RdKafka::KafkaConsumer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structure&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>RdKafka</b>::<a class="el" href="classRdKafka_1_1KafkaConsumer.html">KafkaConsumer</a>
  </div>
</div>
<div class="contents">
<h1>RdKafka::KafkaConsumer Class Reference</h1><!-- doxytag: class="RdKafka::KafkaConsumer" --><!-- doxytag: inherits="RdKafka::Handle" -->
<p>High-level <a class="el" href="classRdKafka_1_1KafkaConsumer.html" title="High-level KafkaConsumer (for brokers 0.9 and later).">KafkaConsumer</a> (for brokers 0.9 and later).  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="rdkafkacpp_8h_source.html">rdkafkacpp.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for RdKafka::KafkaConsumer:</div>
<div class="dynsection">
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for RdKafka::KafkaConsumer:</div>
<div class="dynsection">
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd22626a2b370f378272e30411df6f78"></a><!-- doxytag: member="RdKafka::KafkaConsumer::assignment" ref="afd22626a2b370f378272e30411df6f78" args="(std::vector&lt; RdKafka::TopicPartition * &gt; &amp;partitions)=0" -->
virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#afd22626a2b370f378272e30411df6f78">assignment</a> (std::vector&lt; <a class="el" href="classRdKafka_1_1TopicPartition.html">RdKafka::TopicPartition</a> * &gt; &amp;partitions)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current partition assignment as set by <a class="el" href="classRdKafka_1_1KafkaConsumer.html#af3f872bcb7d46febbaea63518f854b46" title="Update the assignment set to partitions.">RdKafka::KafkaConsumer::assign()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a470f95d195c1c0dc9466040cdf1ec12d"></a><!-- doxytag: member="RdKafka::KafkaConsumer::subscription" ref="a470f95d195c1c0dc9466040cdf1ec12d" args="(std::vector&lt; std::string &gt; &amp;topics)=0" -->
virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#a470f95d195c1c0dc9466040cdf1ec12d">subscription</a> (std::vector&lt; std::string &gt; &amp;topics)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current subscription as set by <a class="el" href="classRdKafka_1_1KafkaConsumer.html#a7404297cecc9be656026c6c6154ce2bd" title="Update the subscription set to topics.">RdKafka::KafkaConsumer::subscribe()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#a7404297cecc9be656026c6c6154ce2bd">subscribe</a> (const std::vector&lt; std::string &gt; &amp;topics)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update the subscription set to <code>topics</code>.  <a href="#a7404297cecc9be656026c6c6154ce2bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a933d7e1d8bceab2422463ee8b335f15b"></a><!-- doxytag: member="RdKafka::KafkaConsumer::unsubscribe" ref="a933d7e1d8bceab2422463ee8b335f15b" args="()=0" -->
virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#a933d7e1d8bceab2422463ee8b335f15b">unsubscribe</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unsubscribe from the current subscription set. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#af3f872bcb7d46febbaea63518f854b46">assign</a> (const std::vector&lt; <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> * &gt; &amp;partitions)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update the assignment set to <code>partitions</code>.  <a href="#af3f872bcb7d46febbaea63518f854b46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21dc83bc3eb00e2b4e0f6373244976b6"></a><!-- doxytag: member="RdKafka::KafkaConsumer::unassign" ref="a21dc83bc3eb00e2b4e0f6373244976b6" args="()=0" -->
virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#a21dc83bc3eb00e2b4e0f6373244976b6">unassign</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stop consumption and remove the current assignment. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRdKafka_1_1Message.html">Message</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#a7dc106f1c3b99767a0930a9cf8cabf84">consume</a> (int timeout_ms)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Consume message or get error event, triggers callbacks.  <a href="#a7dc106f1c3b99767a0930a9cf8cabf84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#a1c421bf2b44509704ad3d9e785c5b15c">commitSync</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Commit offsets for the current assignment.  <a href="#a1c421bf2b44509704ad3d9e785c5b15c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#a6d68b1b8d21dc26499938cb6e529f928">commitAsync</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Asynchronous version of RdKafka::KafkaConsumer::CommitSync().  <a href="#a6d68b1b8d21dc26499938cb6e529f928"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#ac5d1b4fcadea749b774ab1cdd62de2d1">commitSync</a> (<a class="el" href="classRdKafka_1_1Message.html">Message</a> *message)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Commit offset for a single topic+partition based on <code>message</code>.  <a href="#ac5d1b4fcadea749b774ab1cdd62de2d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#a278db6d20ebcaf501af9487c0957d57f">commitAsync</a> (<a class="el" href="classRdKafka_1_1Message.html">Message</a> *message)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Commit offset for a single topic+partition based on <code>message</code>.  <a href="#a278db6d20ebcaf501af9487c0957d57f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#a892f5ec51f898b67a19d892b9ab08177">commitSync</a> (std::vector&lt; <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> * &gt; &amp;offsets)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Commit offsets for the provided list of partitions.  <a href="#a892f5ec51f898b67a19d892b9ab08177"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#a66a2c7639521e0c9eb25c3417921e318">commitAsync</a> (const std::vector&lt; <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> * &gt; &amp;offsets)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Commit offset for the provided list of partitions.  <a href="#a66a2c7639521e0c9eb25c3417921e318"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#a6791befdd7d705be26e5ed69cf219376">commitSync</a> (<a class="el" href="classRdKafka_1_1OffsetCommitCb.html">OffsetCommitCb</a> *offset_commit_cb)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Commit offsets for the current assignment.  <a href="#a6791befdd7d705be26e5ed69cf219376"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#aaa28c44fe9505f48644f06f49403fcc3">commitSync</a> (std::vector&lt; <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> * &gt; &amp;offsets, <a class="el" href="classRdKafka_1_1OffsetCommitCb.html">OffsetCommitCb</a> *offset_commit_cb)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Commit offsets for the provided list of partitions.  <a href="#aaa28c44fe9505f48644f06f49403fcc3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#aad4b300803fd1c9403c165b9a6431612">committed</a> (std::vector&lt; <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> * &gt; &amp;partitions, int timeout_ms)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve committed offsets for topics+partitions.  <a href="#aad4b300803fd1c9403c165b9a6431612"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#a49705c19baac7e00f6558fb7b4410a57">position</a> (std::vector&lt; <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> * &gt; &amp;partitions)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve current positions (offsets) for topics+partitions.  <a href="#a49705c19baac7e00f6558fb7b4410a57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#a5c78a721aa91f3be9903f09ddf084644">close</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close and shut down the proper.  <a href="#a5c78a721aa91f3be9903f09ddf084644"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#ab08a9a8175edd12ae4e1d5bb0eb50479">seek</a> (const <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> &amp;partition, int timeout_ms)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Seek consumer for topic+partition to offset which is either an absolute or logical offset.  <a href="#ab08a9a8175edd12ae4e1d5bb0eb50479"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#ab693da27c7664692d2247398d483e931">offsets_store</a> (std::vector&lt; <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> * &gt; &amp;offsets)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store offset <code>offset</code> for topic partition <code>partition</code>. The offset will be committed (written) to the offset store according to <code>auto.commit.interval.ms</code> or the next manual offset-less commit*().  <a href="#ab693da27c7664692d2247398d483e931"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRdKafka_1_1KafkaConsumer.html">KafkaConsumer</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1KafkaConsumer.html#ac32a5eb3474b3315635cb1d39794d068">create</a> (<a class="el" href="classRdKafka_1_1Conf.html">Conf</a> *conf, std::string &amp;errstr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a <a class="el" href="classRdKafka_1_1KafkaConsumer.html" title="High-level KafkaConsumer (for brokers 0.9 and later).">KafkaConsumer</a>.  <a href="#ac32a5eb3474b3315635cb1d39794d068"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>High-level <a class="el" href="classRdKafka_1_1KafkaConsumer.html" title="High-level KafkaConsumer (for brokers 0.9 and later).">KafkaConsumer</a> (for brokers 0.9 and later). </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Requires Apache Kafka &gt;= 0.9.0 brokers</dd></dl>
<p>Currently supports the <code>range</code> and <code>roundrobin</code> partition assignment strategies (see <code>partition.assignment.strategy</code>) </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ac32a5eb3474b3315635cb1d39794d068"></a><!-- doxytag: member="RdKafka::KafkaConsumer::create" ref="ac32a5eb3474b3315635cb1d39794d068" args="(Conf *conf, std::string &amp;errstr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classRdKafka_1_1KafkaConsumer.html">KafkaConsumer</a>* RdKafka::KafkaConsumer::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRdKafka_1_1Conf.html">Conf</a> *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>errstr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a <a class="el" href="classRdKafka_1_1KafkaConsumer.html" title="High-level KafkaConsumer (for brokers 0.9 and later).">KafkaConsumer</a>. </p>
<p>The <code>conf</code> object must have <code>group.id</code> set to the consumer group to join.</p>
<p>Use <a class="el" href="classRdKafka_1_1KafkaConsumer.html#a5c78a721aa91f3be9903f09ddf084644" title="Close and shut down the proper.">RdKafka::KafkaConsumer::close()</a> to shut down the consumer.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classRdKafka_1_1RebalanceCb.html" title="KafkaConsunmer: Rebalance callback class">RdKafka::RebalanceCb</a> </dd>
<dd>
CONFIGURATION.md for <code>group.id</code>, <code>session.timeout.ms</code>, <code>partition.assignment.strategy</code>, etc. </dd></dl>

</div>
</div>
<a class="anchor" id="a7404297cecc9be656026c6c6154ce2bd"></a><!-- doxytag: member="RdKafka::KafkaConsumer::subscribe" ref="a7404297cecc9be656026c6c6154ce2bd" args="(const std::vector&lt; std::string &gt; &amp;topics)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ErrorCode RdKafka::KafkaConsumer::subscribe </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>topics</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update the subscription set to <code>topics</code>. </p>
<p>Any previous subscription will be unassigned and unsubscribed first.</p>
<p>The subscription set denotes the desired topics to consume and this set is provided to the partition assignor (one of the elected group members) for all clients which then uses the configured <code>partition.assignment.strategy</code> to assign the subscription sets's topics's partitions to the consumers, depending on their subscription.</p>
<p>The result of such an assignment is a rebalancing which is either handled automatically in librdkafka or can be overriden by the application by providing a <a class="el" href="classRdKafka_1_1RebalanceCb.html" title="KafkaConsunmer: Rebalance callback class">RdKafka::RebalanceCb</a>.</p>
<p>The rebalancing passes the assigned partition set to <a class="el" href="classRdKafka_1_1KafkaConsumer.html#af3f872bcb7d46febbaea63518f854b46" title="Update the assignment set to partitions.">RdKafka::KafkaConsumer::assign()</a> to update what partitions are actually being fetched by the <a class="el" href="classRdKafka_1_1KafkaConsumer.html" title="High-level KafkaConsumer (for brokers 0.9 and later).">KafkaConsumer</a>.</p>
<p>Regex pattern matching automatically performed for topics prefixed with <code>\"^\"</code> (e.g. <code>\"^myPfx[0-9]_.*\"</code> </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an error if the provided list of topics is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="af3f872bcb7d46febbaea63518f854b46"></a><!-- doxytag: member="RdKafka::KafkaConsumer::assign" ref="af3f872bcb7d46febbaea63518f854b46" args="(const std::vector&lt; TopicPartition * &gt; &amp;partitions)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ErrorCode RdKafka::KafkaConsumer::assign </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>partitions</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update the assignment set to <code>partitions</code>. </p>
<p>The assignment set is the set of partitions actually being consumed by the <a class="el" href="classRdKafka_1_1KafkaConsumer.html" title="High-level KafkaConsumer (for brokers 0.9 and later).">KafkaConsumer</a>. </p>

</div>
</div>
<a class="anchor" id="a7dc106f1c3b99767a0930a9cf8cabf84"></a><!-- doxytag: member="RdKafka::KafkaConsumer::consume" ref="a7dc106f1c3b99767a0930a9cf8cabf84" args="(int timeout_ms)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classRdKafka_1_1Message.html">Message</a>* RdKafka::KafkaConsumer::consume </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout_ms</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Consume message or get error event, triggers callbacks. </p>
<p>Will automatically call registered callbacks for any such queued events, including <a class="el" href="classRdKafka_1_1RebalanceCb.html" title="KafkaConsunmer: Rebalance callback class">RdKafka::RebalanceCb</a>, <a class="el" href="classRdKafka_1_1EventCb.html" title="Event callback class.">RdKafka::EventCb</a>, <a class="el" href="classRdKafka_1_1OffsetCommitCb.html" title="Offset Commit callback class.">RdKafka::OffsetCommitCb</a>, etc.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Use <code>delete</code> to free the message.</dd>
<dd>
An application should make sure to call <a class="el" href="classRdKafka_1_1KafkaConsumer.html#a7dc106f1c3b99767a0930a9cf8cabf84" title="Consume message or get error event, triggers callbacks.">consume()</a> at regular intervals, even if no messages are expected, to serve any queued callbacks waiting to be called. This is especially important when a <a class="el" href="classRdKafka_1_1RebalanceCb.html" title="KafkaConsunmer: Rebalance callback class">RebalanceCb</a> has been registered as it needs to be called and handled properly to synchronize internal consumer state.</dd>
<dd>
Application MUST NOT call <code><a class="el" href="classRdKafka_1_1Handle.html#a98d3b4ee48457ff13e4d5155e3fc5ea4" title="Polls the provided kafka handle for events.">poll()</a></code> on <a class="el" href="classRdKafka_1_1KafkaConsumer.html" title="High-level KafkaConsumer (for brokers 0.9 and later).">KafkaConsumer</a> objects.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>One of:<ul>
<li>proper message (<a class="el" href="classRdKafka_1_1Message.html#a90df1fd2a73a74220c9581e6bedb42f2">RdKafka::Message::err()</a> is ERR_NO_ERROR)</li>
<li>error event (<a class="el" href="classRdKafka_1_1Message.html#a90df1fd2a73a74220c9581e6bedb42f2">RdKafka::Message::err()</a> is != ERR_NO_ERROR)</li>
<li>timeout due to no message or event in <code>timeout_ms</code> (<a class="el" href="classRdKafka_1_1Message.html#a90df1fd2a73a74220c9581e6bedb42f2">RdKafka::Message::err()</a> is ERR__TIMED_OUT) </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1c421bf2b44509704ad3d9e785c5b15c"></a><!-- doxytag: member="RdKafka::KafkaConsumer::commitSync" ref="a1c421bf2b44509704ad3d9e785c5b15c" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ErrorCode RdKafka::KafkaConsumer::commitSync </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Commit offsets for the current assignment. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is the synchronous variant that blocks until offsets are committed or the commit fails (see return value).</dd>
<dd>
If a <a class="el" href="classRdKafka_1_1OffsetCommitCb.html" title="Offset Commit callback class.">RdKafka::OffsetCommitCb</a> callback is registered it will be called with commit details on a future call to <a class="el" href="classRdKafka_1_1KafkaConsumer.html#a7dc106f1c3b99767a0930a9cf8cabf84" title="Consume message or get error event, triggers callbacks.">RdKafka::KafkaConsumer::consume()</a></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ERR_NO_ERROR or error code. </dd></dl>

</div>
</div>
<a class="anchor" id="a6d68b1b8d21dc26499938cb6e529f928"></a><!-- doxytag: member="RdKafka::KafkaConsumer::commitAsync" ref="a6d68b1b8d21dc26499938cb6e529f928" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ErrorCode RdKafka::KafkaConsumer::commitAsync </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asynchronous version of RdKafka::KafkaConsumer::CommitSync(). </p>
<dl class="see"><dt><b>See also:</b></dt><dd>RdKafka::KafkaConsummer::commitSync() </dd></dl>

</div>
</div>
<a class="anchor" id="ac5d1b4fcadea749b774ab1cdd62de2d1"></a><!-- doxytag: member="RdKafka::KafkaConsumer::commitSync" ref="ac5d1b4fcadea749b774ab1cdd62de2d1" args="(Message *message)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ErrorCode RdKafka::KafkaConsumer::commitSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRdKafka_1_1Message.html">Message</a> *&nbsp;</td>
          <td class="paramname"> <em>message</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Commit offset for a single topic+partition based on <code>message</code>. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is the synchronous variant.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>RdKafka::KafkaConsummer::commitSync() </dd></dl>

</div>
</div>
<a class="anchor" id="a278db6d20ebcaf501af9487c0957d57f"></a><!-- doxytag: member="RdKafka::KafkaConsumer::commitAsync" ref="a278db6d20ebcaf501af9487c0957d57f" args="(Message *message)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ErrorCode RdKafka::KafkaConsumer::commitAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRdKafka_1_1Message.html">Message</a> *&nbsp;</td>
          <td class="paramname"> <em>message</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Commit offset for a single topic+partition based on <code>message</code>. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is the asynchronous variant.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>RdKafka::KafkaConsummer::commitSync() </dd></dl>

</div>
</div>
<a class="anchor" id="a892f5ec51f898b67a19d892b9ab08177"></a><!-- doxytag: member="RdKafka::KafkaConsumer::commitSync" ref="a892f5ec51f898b67a19d892b9ab08177" args="(std::vector&lt; TopicPartition * &gt; &amp;offsets)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ErrorCode RdKafka::KafkaConsumer::commitSync </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>offsets</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Commit offsets for the provided list of partitions. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is the synchronous variant. </dd></dl>

</div>
</div>
<a class="anchor" id="a66a2c7639521e0c9eb25c3417921e318"></a><!-- doxytag: member="RdKafka::KafkaConsumer::commitAsync" ref="a66a2c7639521e0c9eb25c3417921e318" args="(const std::vector&lt; TopicPartition * &gt; &amp;offsets)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ErrorCode RdKafka::KafkaConsumer::commitAsync </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>offsets</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Commit offset for the provided list of partitions. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is the asynchronous variant. </dd></dl>

</div>
</div>
<a class="anchor" id="a6791befdd7d705be26e5ed69cf219376"></a><!-- doxytag: member="RdKafka::KafkaConsumer::commitSync" ref="a6791befdd7d705be26e5ed69cf219376" args="(OffsetCommitCb *offset_commit_cb)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ErrorCode RdKafka::KafkaConsumer::commitSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRdKafka_1_1OffsetCommitCb.html">OffsetCommitCb</a> *&nbsp;</td>
          <td class="paramname"> <em>offset_commit_cb</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Commit offsets for the current assignment. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is the synchronous variant that blocks until offsets are committed or the commit fails (see return value).</dd>
<dd>
The provided callback will be called from this function.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ERR_NO_ERROR or error code. </dd></dl>

</div>
</div>
<a class="anchor" id="aaa28c44fe9505f48644f06f49403fcc3"></a><!-- doxytag: member="RdKafka::KafkaConsumer::commitSync" ref="aaa28c44fe9505f48644f06f49403fcc3" args="(std::vector&lt; TopicPartition * &gt; &amp;offsets, OffsetCommitCb *offset_commit_cb)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ErrorCode RdKafka::KafkaConsumer::commitSync </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRdKafka_1_1OffsetCommitCb.html">OffsetCommitCb</a> *&nbsp;</td>
          <td class="paramname"> <em>offset_commit_cb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Commit offsets for the provided list of partitions. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is the synchronous variant that blocks until offsets are committed or the commit fails (see return value).</dd>
<dd>
The provided callback will be called from this function.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ERR_NO_ERROR or error code. </dd></dl>

</div>
</div>
<a class="anchor" id="aad4b300803fd1c9403c165b9a6431612"></a><!-- doxytag: member="RdKafka::KafkaConsumer::committed" ref="aad4b300803fd1c9403c165b9a6431612" args="(std::vector&lt; TopicPartition * &gt; &amp;partitions, int timeout_ms)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ErrorCode RdKafka::KafkaConsumer::committed </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout_ms</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve committed offsets for topics+partitions. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success in which case the <code>offset</code> or <code>err</code> field of each <code>partitions'</code> element is filled in with the stored offset, or a partition specific error. Else returns an error code. </dd></dl>

</div>
</div>
<a class="anchor" id="a49705c19baac7e00f6558fb7b4410a57"></a><!-- doxytag: member="RdKafka::KafkaConsumer::position" ref="a49705c19baac7e00f6558fb7b4410a57" args="(std::vector&lt; TopicPartition * &gt; &amp;partitions)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ErrorCode RdKafka::KafkaConsumer::position </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>partitions</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve current positions (offsets) for topics+partitions. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success in which case the <code>offset</code> or <code>err</code> field of each <code>partitions'</code> element is filled in with the stored offset, or a partition specific error. Else returns an error code. </dd></dl>

</div>
</div>
<a class="anchor" id="a5c78a721aa91f3be9903f09ddf084644"></a><!-- doxytag: member="RdKafka::KafkaConsumer::close" ref="a5c78a721aa91f3be9903f09ddf084644" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ErrorCode RdKafka::KafkaConsumer::close </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close and shut down the proper. </p>
<p>For pausing and resuming consumption, see </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classRdKafka_1_1Handle.html#a6be6579b7e2a0427b4595fb559e58d0f" title="Pause producing or consumption for the provided list of partitions.">RdKafka::Handle::pause()</a> and <a class="el" href="classRdKafka_1_1Handle.html#a322d16d6786da2b4b20505f19325fcec" title="Resume producing or consumption for the provided list of partitions.">RdKafka::Handle::resume()</a> This call will block until the following operations are finished:<ul>
<li>Trigger a local rebalance to void the current <a class="el" href="classRdKafka_1_1KafkaConsumer.html#afd22626a2b370f378272e30411df6f78" title="Returns the current partition assignment as set by RdKafka::KafkaConsumer::assign()...">assignment</a></li>
<li>Stop consumption for current <a class="el" href="classRdKafka_1_1KafkaConsumer.html#afd22626a2b370f378272e30411df6f78" title="Returns the current partition assignment as set by RdKafka::KafkaConsumer::assign()...">assignment</a></li>
<li>Commit offsets</li>
<li>Leave group</li>
</ul>
</dd></dl>
<p>The maximum blocking time is roughly limited to session.timeout.ms.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Callbacks, such as <a class="el" href="classRdKafka_1_1RebalanceCb.html" title="KafkaConsunmer: Rebalance callback class">RdKafka::RebalanceCb</a> and <a class="el" href="classRdKafka_1_1OffsetCommitCb.html" title="Offset Commit callback class.">RdKafka::OffsetCommitCb</a>, etc, may be called.</dd>
<dd>
The consumer object must later be freed with <code>delete</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ab08a9a8175edd12ae4e1d5bb0eb50479"></a><!-- doxytag: member="RdKafka::KafkaConsumer::seek" ref="ab08a9a8175edd12ae4e1d5bb0eb50479" args="(const TopicPartition &amp;partition, int timeout_ms)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ErrorCode RdKafka::KafkaConsumer::seek </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout_ms</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Seek consumer for topic+partition to offset which is either an absolute or logical offset. </p>
<p>If <code>timeout_ms</code> is not 0 the call will wait this long for the seek to be performed. If the timeout is reached the internal state will be unknown and this function returns `ERR__TIMED_OUT`. If <code>timeout_ms</code> is 0 it will initiate the seek but return immediately without any error reporting (e.g., async).</p>
<p>This call triggers a fetch queue barrier flush.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Consumtion for the given partition must have started for the seek to work. Use <a class="el" href="classRdKafka_1_1KafkaConsumer.html#af3f872bcb7d46febbaea63518f854b46" title="Update the assignment set to partitions.">assign()</a> to set the starting offset.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an ErrorCode to indicate success or failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ab693da27c7664692d2247398d483e931"></a><!-- doxytag: member="RdKafka::KafkaConsumer::offsets_store" ref="ab693da27c7664692d2247398d483e931" args="(std::vector&lt; TopicPartition * &gt; &amp;offsets)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ErrorCode RdKafka::KafkaConsumer::offsets_store </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classRdKafka_1_1TopicPartition.html">TopicPartition</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>offsets</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Store offset <code>offset</code> for topic partition <code>partition</code>. The offset will be committed (written) to the offset store according to <code>auto.commit.interval.ms</code> or the next manual offset-less commit*(). </p>
<p>Per-partition success/error status propagated through <a class="el" href="classRdKafka_1_1TopicPartition.html#adf4cd4ca1ed51f1829fddd475b96adee">TopicPartition.err()</a></p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><code>enable.auto.offset.store</code> must be set to <code>false</code> when using this API.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RdKafka::ERR_NO_ERROR on success, or RdKafka::ERR___UNKNOWN_PARTITION if none of the offsets could be stored, or RdKafka::ERR___INVALID_ARG if <code>enable.auto.offset.store</code> is true. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src-cpp/<a class="el" href="rdkafkacpp_8h_source.html">rdkafkacpp.h</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 6 Mar 2018 for librdkafka by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
