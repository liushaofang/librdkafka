<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>librdkafka: RdKafka::Producer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structure&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>RdKafka</b>::<a class="el" href="classRdKafka_1_1Producer.html">Producer</a>
  </div>
</div>
<div class="contents">
<h1>RdKafka::Producer Class Reference</h1><!-- doxytag: class="RdKafka::Producer" --><!-- doxytag: inherits="RdKafka::Handle" -->
<p><a class="el" href="classRdKafka_1_1Producer.html" title="Producer.">Producer</a>.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="rdkafkacpp_8h_source.html">rdkafkacpp.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for RdKafka::Producer:</div>
<div class="dynsection">
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for RdKafka::Producer:</div>
<div class="dynsection">
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <br/>
&nbsp;&nbsp;<a class="el" href="classRdKafka_1_1Producer.html#abe5e3437f8db2600f10a8daa429ab242a1aaa1620d84d2fa797d05a5bfcefd31e">RK_MSG_FREE</a> =  0x1, 
<br/>
&nbsp;&nbsp;<a class="el" href="classRdKafka_1_1Producer.html#abe5e3437f8db2600f10a8daa429ab242aa88d8865f6dcffe75f73536fdf2424a5">RK_MSG_COPY</a> =  0x2, 
<br/>
&nbsp;&nbsp;<a class="el" href="classRdKafka_1_1Producer.html#abe5e3437f8db2600f10a8daa429ab242a6f05ff968fdf3375508238e192e1c03b">RK_MSG_BLOCK</a> =  0x4
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p><a class="el" href="classRdKafka_1_1Producer.html#ab90a30c5e5fb006a3b4004dc4c9a7923" title="Produce and send a single message to broker.">RdKafka::Producer::produce()</a> <code>msgflags</code>. </p>
 <a href="classRdKafka_1_1Producer.html#abe5e3437f8db2600f10a8daa429ab242">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1Producer.html#ab90a30c5e5fb006a3b4004dc4c9a7923">produce</a> (<a class="el" href="classRdKafka_1_1Topic.html">Topic</a> *topic, int32_t partition, int msgflags, void *payload, size_t len, const std::string *key, void *msg_opaque)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Produce and send a single message to broker.  <a href="#ab90a30c5e5fb006a3b4004dc4c9a7923"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7871c00eb302209acb9ea498eda7dee4"></a><!-- doxytag: member="RdKafka::Producer::produce" ref="a7871c00eb302209acb9ea498eda7dee4" args="(Topic *topic, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t key_len, void *msg_opaque)=0" -->
virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1Producer.html#a7871c00eb302209acb9ea498eda7dee4">produce</a> (<a class="el" href="classRdKafka_1_1Topic.html">Topic</a> *topic, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t key_len, void *msg_opaque)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Variant <a class="el" href="classRdKafka_1_1Producer.html#ab90a30c5e5fb006a3b4004dc4c9a7923" title="Produce and send a single message to broker.">produce()</a> that passes the key as a pointer and length instead of as a const std::string *. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d569225be5e98a016f889d54adf4e6c"></a><!-- doxytag: member="RdKafka::Producer::produce" ref="a5d569225be5e98a016f889d54adf4e6c" args="(const std::string topic_name, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t key_len, int64_t timestamp, void *msg_opaque)=0" -->
virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1Producer.html#a5d569225be5e98a016f889d54adf4e6c">produce</a> (const std::string topic_name, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t key_len, int64_t timestamp, void *msg_opaque)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classRdKafka_1_1Producer.html#ab90a30c5e5fb006a3b4004dc4c9a7923" title="Produce and send a single message to broker.">produce()</a> variant that takes topic as a string (no need for creating a <a class="el" href="classRdKafka_1_1Topic.html" title="Topic handle.">Topic</a> object), and also allows providing the message timestamp (microseconds since beginning of epoch, UTC). Otherwise identical to <a class="el" href="classRdKafka_1_1Producer.html#ab90a30c5e5fb006a3b4004dc4c9a7923" title="Produce and send a single message to broker.">produce()</a> above. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac51872fe6252093fc0c271557d132d28"></a><!-- doxytag: member="RdKafka::Producer::produce" ref="ac51872fe6252093fc0c271557d132d28" args="(Topic *topic, int32_t partition, const std::vector&lt; char &gt; *payload, const std::vector&lt; char &gt; *key, void *msg_opaque)=0" -->
virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1Producer.html#ac51872fe6252093fc0c271557d132d28">produce</a> (<a class="el" href="classRdKafka_1_1Topic.html">Topic</a> *topic, int32_t partition, const std::vector&lt; char &gt; *payload, const std::vector&lt; char &gt; *key, void *msg_opaque)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Variant <a class="el" href="classRdKafka_1_1Producer.html#ab90a30c5e5fb006a3b4004dc4c9a7923" title="Produce and send a single message to broker.">produce()</a> that accepts vectors for key and payload. The vector data will be copied. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1Producer.html#afa33f8d26eb49f8cc7988397bbb2db42">flush</a> (int timeout_ms)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait until all outstanding produce requests, et.al, are completed. This should typically be done prior to destroying a producer instance to make sure all queued and in-flight produce requests are completed before terminating.  <a href="#afa33f8d26eb49f8cc7988397bbb2db42"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRdKafka_1_1Producer.html">Producer</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRdKafka_1_1Producer.html#a540569ee0152703cdad4b45419f64b39">create</a> (<a class="el" href="classRdKafka_1_1Conf.html">Conf</a> *conf, std::string &amp;errstr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new Kafka producer handle.  <a href="#a540569ee0152703cdad4b45419f64b39"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="classRdKafka_1_1Producer.html" title="Producer.">Producer</a>. </p>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="abe5e3437f8db2600f10a8daa429ab242"></a><!-- doxytag: member="RdKafka::Producer::@0" ref="abe5e3437f8db2600f10a8daa429ab242" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classRdKafka_1_1Producer.html#ab90a30c5e5fb006a3b4004dc4c9a7923" title="Produce and send a single message to broker.">RdKafka::Producer::produce()</a> <code>msgflags</code>. </p>
<p>These flags are optional and mutually exclusive. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="abe5e3437f8db2600f10a8daa429ab242a1aaa1620d84d2fa797d05a5bfcefd31e"></a><!-- doxytag: member="RK_MSG_FREE" ref="abe5e3437f8db2600f10a8daa429ab242a1aaa1620d84d2fa797d05a5bfcefd31e" args="" -->RK_MSG_FREE</em>&nbsp;</td><td>
<p>rdkafka will free(3) <code>payload</code> when it is done with it. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="abe5e3437f8db2600f10a8daa429ab242aa88d8865f6dcffe75f73536fdf2424a5"></a><!-- doxytag: member="RK_MSG_COPY" ref="abe5e3437f8db2600f10a8daa429ab242aa88d8865f6dcffe75f73536fdf2424a5" args="" -->RK_MSG_COPY</em>&nbsp;</td><td>
<p>the <code>payload</code> data will be copied and the <code>payload</code> pointer will not be used by rdkafka after the call returns. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="abe5e3437f8db2600f10a8daa429ab242a6f05ff968fdf3375508238e192e1c03b"></a><!-- doxytag: member="RK_MSG_BLOCK" ref="abe5e3437f8db2600f10a8daa429ab242a6f05ff968fdf3375508238e192e1c03b" args="" -->RK_MSG_BLOCK</em>&nbsp;</td><td>
<p>Block produce*() on message queue full. WARNING: If a delivery report callback is used the application MUST call <a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4" title="Polls the provided kafka handle for events.">rd_kafka_poll()</a> (or equiv.) to make sure delivered messages are drained from the internal delivery report queue. Failure to do so will result in indefinately blocking on the <a class="el" href="classRdKafka_1_1Producer.html#ab90a30c5e5fb006a3b4004dc4c9a7923" title="Produce and send a single message to broker.">produce()</a> call when the message queue is full. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a540569ee0152703cdad4b45419f64b39"></a><!-- doxytag: member="RdKafka::Producer::create" ref="a540569ee0152703cdad4b45419f64b39" args="(Conf *conf, std::string &amp;errstr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classRdKafka_1_1Producer.html">Producer</a>* RdKafka::Producer::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRdKafka_1_1Conf.html">Conf</a> *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>errstr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new Kafka producer handle. </p>
<p><code>conf</code> is an optional object that will be used instead of the default configuration. The <code>conf</code> object is reusable after this call.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the new handle on success or NULL on error in which case <code>errstr</code> is set to a human readable error message. </dd></dl>

</div>
</div>
<a class="anchor" id="ab90a30c5e5fb006a3b4004dc4c9a7923"></a><!-- doxytag: member="RdKafka::Producer::produce" ref="ab90a30c5e5fb006a3b4004dc4c9a7923" args="(Topic *topic, int32_t partition, int msgflags, void *payload, size_t len, const std::string *key, void *msg_opaque)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ErrorCode RdKafka::Producer::produce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRdKafka_1_1Topic.html">Topic</a> *&nbsp;</td>
          <td class="paramname"> <em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>msgflags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>msg_opaque</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Produce and send a single message to broker. </p>
<p>This is an asynch non-blocking API.</p>
<p><code>partition</code> is the target partition, either:</p>
<ul>
<li><a class="el" href="classRdKafka_1_1Topic.html#ab69c18779df1c8e150648e640b159654" title="Unassigned partition.">RdKafka::Topic::PARTITION_UA</a> (unassigned) for automatic partitioning using the topic's partitioner function, or</li>
<li>a fixed partition (0..N)</li>
</ul>
<p><code>msgflags</code> is zero or more of the following flags OR:ed together: RK_MSG_BLOCK - block <code>produce*</code>() call if <code>queue.buffering.max.messages</code> or <code>queue.buffering.max.kbytes</code> are exceeded. Messages are considered in-queue from the point they are accepted by <a class="el" href="classRdKafka_1_1Producer.html#ab90a30c5e5fb006a3b4004dc4c9a7923" title="Produce and send a single message to broker.">produce()</a> until their corresponding delivery report callback/event returns. It is thus a requirement to call <a class="el" href="classRdKafka_1_1Handle.html#a98d3b4ee48457ff13e4d5155e3fc5ea4" title="Polls the provided kafka handle for events.">poll()</a> (or equiv.) from a separate thread when RK_MSG_BLOCK is used. See WARNING on <code>RK_MSG_BLOCK</code> above. RK_MSG_FREE - rdkafka will free(3) <code>payload</code> when it is done with it. RK_MSG_COPY - the <code>payload</code> data will be copied and the <code>payload</code> pointer will not be used by rdkafka after the call returns.</p>
<p>NOTE: RK_MSG_FREE and RK_MSG_COPY are mutually exclusive.</p>
<p>If the function returns an error code and RK_MSG_FREE was specified, then the memory associated with the payload is still the caller's responsibility.</p>
<p><code>payload</code> is the message payload of size <code>len</code> bytes.</p>
<p><code>key</code> is an optional message key, if non-NULL it will be passed to the topic partitioner as well as be sent with the message to the broker and passed on to the consumer.</p>
<p><code>msg_opaque</code> is an optional application-provided per-message opaque pointer that will provided in the delivery report callback (<code>dr_cb</code>) for referencing this message.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an ErrorCode to indicate success or failure:<ul>
<li>ERR_NO_ERROR - message successfully enqueued for transmission.</li>
</ul>
</dd></dl>
<ul>
<li>ERR__QUEUE_FULL - maximum number of outstanding messages has been reached: <code>queue.buffering.max.message</code> </li>
</ul>
<ul>
<li>ERR_MSG_SIZE_TOO_LARGE - message is larger than configured max size: <code>messages.max.bytes</code> </li>
</ul>
<ul>
<li>ERR__UNKNOWN_PARTITION - requested <code>partition</code> is unknown in the Kafka cluster.</li>
</ul>
<ul>
<li>ERR__UNKNOWN_TOPIC - topic is unknown in the Kafka cluster. </li>
</ul>

</div>
</div>
<a class="anchor" id="afa33f8d26eb49f8cc7988397bbb2db42"></a><!-- doxytag: member="RdKafka::Producer::flush" ref="afa33f8d26eb49f8cc7988397bbb2db42" args="(int timeout_ms)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ErrorCode RdKafka::Producer::flush </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout_ms</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait until all outstanding produce requests, et.al, are completed. This should typically be done prior to destroying a producer instance to make sure all queued and in-flight produce requests are completed before terminating. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This function will call <a class="el" href="classRdKafka_1_1Handle.html#a98d3b4ee48457ff13e4d5155e3fc5ea4" title="Polls the provided kafka handle for events.">poll()</a> and thus trigger callbacks.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ERR__TIMED_OUT if <code>timeout_ms</code> was reached before all outstanding requests were completed, else ERR_NO_ERROR </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src-cpp/<a class="el" href="rdkafkacpp_8h_source.html">rdkafkacpp.h</a></li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 6 Mar 2018 for librdkafka by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
