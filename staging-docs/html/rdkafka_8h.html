<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>librdkafka: src/rdkafka.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>src/rdkafka.h File Reference</h1>
<p>Apache Kafka C/C++ consumer and producer client library.  
<a href="#_details">More...</a></p>
<code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;inttypes.h&gt;</code><br/>
<code>#include &lt;sys/types.h&gt;</code><br/>
<code>#include &lt;sys/socket.h&gt;</code><br/>
<div class="dynheader">
Include dependency graph for rdkafka.h:</div>
<div class="dynsection">
</div>

<p><a href="rdkafka_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrd__kafka__err__desc.html">rd_kafka_err_desc</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Error code value, name and description. Typically for use with language bindings to automatically expose the full set of librdkafka error codes.  <a href="structrd__kafka__err__desc.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrd__kafka__topic__partition__t.html">rd_kafka_topic_partition_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Topic+Partition place holder.  <a href="structrd__kafka__topic__partition__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A growable list of Topic+Partitions.  <a href="structrd__kafka__topic__partition__list__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A Kafka message as returned by the <code>rd_kafka_consume*</code>() family of functions as well as provided to the Producer <code>dr_msg_cb()</code>.  <a href="structrd__kafka__message__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrd__kafka__metadata__broker__t.html">rd_kafka_metadata_broker_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Broker information.  <a href="structrd__kafka__metadata__broker__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrd__kafka__metadata__partition__t.html">rd_kafka_metadata_partition_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Partition information.  <a href="structrd__kafka__metadata__partition__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrd__kafka__metadata__topic__t.html">rd_kafka_metadata_topic_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Topic information.  <a href="structrd__kafka__metadata__topic__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrd__kafka__metadata__t.html">rd_kafka_metadata_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Metadata container.  <a href="structrd__kafka__metadata__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrd__kafka__group__member__info.html">rd_kafka_group_member_info</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Group member information.  <a href="structrd__kafka__group__member__info.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrd__kafka__group__info.html">rd_kafka_group_info</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Group information.  <a href="structrd__kafka__group__info.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrd__kafka__group__list.html">rd_kafka_group_list</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List of groups.  <a href="structrd__kafka__group__list.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Plugin interface</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpace149ed32fba50178284999ac0961ab"></a>A plugin interface that allows external runtime-loaded libraries to integrate with a client instance without modifications to the application code.</p>
<p>Plugins are loaded when referenced through the `plugin.library.paths` configuration property and operates on the <code>rd_kafka_conf_t</code> object prior <code>rd_kafka_t</code> instance creation.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Plugins require the application to link librdkafka dynamically and not statically. Failure to do so will lead to missing symbols or finding symbols in another librdkafka library than the application was linked with. </dd></dl>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>(&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a15f8730945790c3c5fb366f2970f73b8">rd_kafka_plugin_f_conf_init_t</a> )(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plugin's configuration initializer method called each time the library is referenced from configuration (even if previously loaded by another client instance).  <a href="#a15f8730945790c3c5fb366f2970f73b8"></a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Kafka messages</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpa5211436b24e4fb33e041bb89ea005e5"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35e0c519209d1afe9e29468f766c1c24"></a><!-- doxytag: member="rdkafka.h::rd_kafka_message_destroy" ref="a35e0c519209d1afe9e29468f766c1c24" args="(rd_kafka_message_t *rkmessage)" -->
RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a35e0c519209d1afe9e29468f766c1c24">rd_kafka_message_destroy</a> (<a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees resources for <code>rkmessage</code> and hands ownership back to rdkafka. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static RD_INLINE const char <br class="typebreak"/>
*RD_UNUSED&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a929ad59ee41ceb4e2f36c8212a5a54ec">rd_kafka_message_errstr</a> (const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the error string for an errored <a class="el" href="structrd__kafka__message__t.html" title="A Kafka message as returned by the rd_kafka_consume*() family of functions as well...">rd_kafka_message_t</a> or NULL if there was no error.  <a href="#a929ad59ee41ceb4e2f36c8212a5a54ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a4371deba4afe6941cc5f9e80df5ca3e7">rd_kafka_message_timestamp</a> (const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, <a class="el" href="rdkafka_8h.html#af7cb459a230a61489234823da2beb3f3">rd_kafka_timestamp_type_t</a> *tstype)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the message timestamp for a consumed message.  <a href="#a4371deba4afe6941cc5f9e80df5ca3e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aba20435b42efef7a3c38dee3fb58c27b">rd_kafka_message_latency</a> (const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the latency for a produced message measured from the produce() call.  <a href="#aba20435b42efef7a3c38dee3fb58c27b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aaccd9ee7e1c73b89d86ed41db3b86e68">rd_kafka_message_headers</a> (const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, rd_kafka_headers_t **hdrsp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the message header list.  <a href="#aaccd9ee7e1c73b89d86ed41db3b86e68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#af89ef912d3c1ff66ea612fda27c0a643">rd_kafka_message_detach_headers</a> (<a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, rd_kafka_headers_t **hdrsp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the message header list and detach the list from the message making the application the owner of the headers. The application must eventually destroy the headers using <a class="el" href="rdkafka_8h.html#aa31d7a8707a729839e54422ca976d8b1" title="Destroy the headers list. The object and any returned value pointers are not usable...">rd_kafka_headers_destroy()</a>. The message's headers will be set to NULL.  <a href="#af89ef912d3c1ff66ea612fda27c0a643"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a99e46233e57fc4f5783d8ae374584bbe">rd_kafka_message_set_headers</a> (<a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, rd_kafka_headers_t *hdrs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace the message's current headers with a new list.  <a href="#a99e46233e57fc4f5783d8ae374584bbe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#af8ce5228eef3ea0a9209965902b6fcdd">rd_kafka_header_cnt</a> (const rd_kafka_headers_t *hdrs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of header key/value pairs.  <a href="#af8ce5228eef3ea0a9209965902b6fcdd"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Topic configuration</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp420ffc8261efd5b893ef65c195bcfce2"></a>Topic configuration property interface </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT rd_kafka_topic_conf_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a1a7032f87e7d868b80e38d0fd0ad119e">rd_kafka_topic_conf_new</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create topic configuration object.  <a href="#a1a7032f87e7d868b80e38d0fd0ad119e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15de16feecd5fd5ce60e90126d83a062"></a><!-- doxytag: member="rdkafka.h::rd_kafka_topic_conf_dup" ref="a15de16feecd5fd5ce60e90126d83a062" args="(const rd_kafka_topic_conf_t *conf)" -->
RD_EXPORT rd_kafka_topic_conf_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a15de16feecd5fd5ce60e90126d83a062">rd_kafka_topic_conf_dup</a> (const rd_kafka_topic_conf_t *conf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a copy/duplicate of topic configuration object <code>conf</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ac06e9631cfaf4cff1130bc28a538d9"></a><!-- doxytag: member="rdkafka.h::rd_kafka_default_topic_conf_dup" ref="a8ac06e9631cfaf4cff1130bc28a538d9" args="(rd_kafka_t *rk)" -->
RD_EXPORT rd_kafka_topic_conf_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a8ac06e9631cfaf4cff1130bc28a538d9">rd_kafka_default_topic_conf_dup</a> (rd_kafka_t *rk)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a copy/duplicate of <code>rk</code> 's default topic configuration object. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3f83e53bd89531f662644f549c85d9f"></a><!-- doxytag: member="rdkafka.h::rd_kafka_topic_conf_destroy" ref="ac3f83e53bd89531f662644f549c85d9f" args="(rd_kafka_topic_conf_t *topic_conf)" -->
RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ac3f83e53bd89531f662644f549c85d9f">rd_kafka_topic_conf_destroy</a> (rd_kafka_topic_conf_t *topic_conf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroys a topic conf object. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ac91b47f7733b324bf4159427e90ccd01">rd_kafka_topic_conf_set</a> (rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a single rd_kafka_topic_conf_t value by property name.  <a href="#ac91b47f7733b324bf4159427e90ccd01"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade099479af64ad87af7c5c6c953f18e0"></a><!-- doxytag: member="rdkafka.h::rd_kafka_topic_conf_set_opaque" ref="ade099479af64ad87af7c5c6c953f18e0" args="(rd_kafka_topic_conf_t *conf, void *opaque)" -->
RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ade099479af64ad87af7c5c6c953f18e0">rd_kafka_topic_conf_set_opaque</a> (rd_kafka_topic_conf_t *conf, void *opaque)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the application's opaque pointer that will be passed to all topic callbacks as the <code>rkt_opaque</code> argument. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#abfc790b5e36c56ea6d79fdc32c57becf">rd_kafka_topic_conf_set_partitioner_cb</a> (rd_kafka_topic_conf_t *topic_conf, int32_t(*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Producer:</b> Set partitioner callback in provided topic conf object.  <a href="#abfc790b5e36c56ea6d79fdc32c57becf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a760cee234c441d32f9421874a74e06d4">rd_kafka_topic_conf_set_msg_order_cmp</a> (rd_kafka_topic_conf_t *topic_conf, int(*msg_order_cmp)(const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *a, const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *b))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Producer:</b> Set message queueing order comparator callback.  <a href="#a760cee234c441d32f9421874a74e06d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ad24c6cc7f37271e292f8105c64d77758">rd_kafka_topic_partition_available</a> (const rd_kafka_topic_t *rkt, int32_t partition)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if partition is available (has a leader broker).  <a href="#ad24c6cc7f37271e292f8105c64d77758"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ae8690da243d6d22f52cf8a6f0e90d7e8">rd_kafka_msg_partitioner_random</a> (const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Random partitioner.  <a href="#ae8690da243d6d22f52cf8a6f0e90d7e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a09edd9204e8fb28dae7a8b000d4492ef">rd_kafka_msg_partitioner_consistent</a> (const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Consistent partitioner.  <a href="#a09edd9204e8fb28dae7a8b000d4492ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a2b79580e110b06ea5434fb71abc0b4eb">rd_kafka_msg_partitioner_consistent_random</a> (const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Consistent-Random partitioner.  <a href="#a2b79580e110b06ea5434fb71abc0b4eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a009f294dc88a214850760216d3fe2d5f">rd_kafka_msg_partitioner_murmur2</a> (const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Murmur2 partitioner (Java compatible).  <a href="#a009f294dc88a214850760216d3fe2d5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ab5dab15f3d0a293db43338f17544e26a">rd_kafka_msg_partitioner_murmur2_random</a> (const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Consistent-Random Murmur2 partitioner (Java compatible).  <a href="#ab5dab15f3d0a293db43338f17544e26a"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Queue API</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpd8cb6f5e9bac7d1d98d55db787f9bef3"></a> Message queues allows the application to re-route consumed messages from multiple topic+partitions into one single queue point. This queue point containing messages from a number of topic+partitions may then be served by a single rd_kafka_consume*_queue() call, rather than one call per topic+partition combination. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT rd_kafka_queue_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a2b59178eb7e88d40510a89f3f2d98b44">rd_kafka_queue_new</a> (rd_kafka_t *rk)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new message queue.  <a href="#a2b59178eb7e88d40510a89f3f2d98b44"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a9421b3d450f1489cf46f68d49c5ea61e">rd_kafka_queue_destroy</a> (rd_kafka_queue_t *rkqu)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT rd_kafka_queue_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a7f3d675ee029a52bf85fb28f83c38863">rd_kafka_queue_get_main</a> (rd_kafka_t *rk)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT rd_kafka_queue_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#acacdb55ae7cb6abfbde89621e512b078">rd_kafka_queue_get_consumer</a> (rd_kafka_t *rk)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT rd_kafka_queue_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ad5319a26efb9f843c6029f7dd54b742d">rd_kafka_queue_get_partition</a> (rd_kafka_t *rk, const char *topic, int32_t partition)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a5e2e5571d14636d289f963a270b8e338">rd_kafka_queue_forward</a> (rd_kafka_queue_t *src, rd_kafka_queue_t *dst)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Forward/re-route queue <code>src</code> to <code>dst</code>. If <code>dst</code> is <code>NULL</code> the forwarding is removed.  <a href="#a5e2e5571d14636d289f963a270b8e338"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a5c8a3be2f797560b2a39bf56dbd7622d">rd_kafka_set_log_queue</a> (rd_kafka_t *rk, rd_kafka_queue_t *rkqu)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Forward librdkafka logs (and debug) to the specified queue for serving with one of the ..poll() calls.  <a href="#a5c8a3be2f797560b2a39bf56dbd7622d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a8f24368f4ff0e042907773f532f62e57">rd_kafka_queue_length</a> (rd_kafka_queue_t *rkqu)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#acbdd13ab480f6320b2842981eebce784">rd_kafka_queue_io_event_enable</a> (rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable IO event triggering for queue.  <a href="#acbdd13ab480f6320b2842981eebce784"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Simple Consumer API (legacy): Queue consumers</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp58dc5b27c8fc392b2ae0604b998647a4"></a> The following `..._queue()` functions are analogue to the functions above but reads messages from the provided queue <code>rkqu</code> instead. <code>rkqu</code> must have been previously created with `rd_kafka_queue_new()` and the topic consumer must have been started with `rd_kafka_consume_start_queue()` utilising the the same queue. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a8ff0b80fccb3a5bd31b1baaf20e4ca16">rd_kafka_consume_queue</a> (rd_kafka_queue_t *rkqu, int timeout_ms)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Consume from queue.  <a href="#a8ff0b80fccb3a5bd31b1baaf20e4ca16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a3d949238471993b18537855aad28fa23">rd_kafka_consume_batch_queue</a> (rd_kafka_queue_t *rkqu, int timeout_ms, <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> **rkmessages, size_t rkmessages_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Consume batch of messages from queue.  <a href="#a3d949238471993b18537855aad28fa23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#abb1aaca2499c2e7d6da37dc28953d532">rd_kafka_consume_callback_queue</a> (rd_kafka_queue_t *rkqu, int timeout_ms, void(*consume_cb)(<a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, void *opaque), void *opaque)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Consume multiple messages from queue with callback.  <a href="#abb1aaca2499c2e7d6da37dc28953d532"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Simple Consumer API (legacy): Topic+partition offset store.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp5a977c4a23acc90ec732c1fac6f92980"></a> If <code>auto.commit.enable</code> is true the offset is stored automatically prior to returning of the message(s) in each of the rd_kafka_consume*() functions above. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a784186db1d2cb6ceebcd5606d38db4c4">rd_kafka_offset_store</a> (rd_kafka_topic_t *rkt, int32_t partition, int64_t offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store offset <code>offset</code> for topic <code>rkt</code> partition <code>partition</code>.  <a href="#a784186db1d2cb6ceebcd5606d38db4c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a047b1e21236fba30898c7c563c2c6777">rd_kafka_offsets_store</a> (rd_kafka_t *rk, <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *offsets)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store offsets for next auto-commit for one or more partitions.  <a href="#a047b1e21236fba30898c7c563c2c6777"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">KafkaConsumer (C)</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp36573974f5c363f8f9198facbab2a4f4"></a>High-level KafkaConsumer C API </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a0ebe15e9d0f39ccc84e9686f0fcf46f1">rd_kafka_subscribe</a> (rd_kafka_t *rk, const <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *topics)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subscribe to topic set using balanced consumer groups.  <a href="#a0ebe15e9d0f39ccc84e9686f0fcf46f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ca43b89dd1696f1d22e4e4ad49345b9"></a><!-- doxytag: member="rdkafka.h::rd_kafka_unsubscribe" ref="a3ca43b89dd1696f1d22e4e4ad49345b9" args="(rd_kafka_t *rk)" -->
RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a3ca43b89dd1696f1d22e4e4ad49345b9">rd_kafka_unsubscribe</a> (rd_kafka_t *rk)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unsubscribe from the current subscription set. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ab66a2c014db2e652aa12466b137a6200">rd_kafka_subscription</a> (rd_kafka_t *rk, <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> **topics)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current topic subscription.  <a href="#ab66a2c014db2e652aa12466b137a6200"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a65cc6cb9bd72c4084f074af0361ceddf">rd_kafka_consumer_poll</a> (rd_kafka_t *rk, int timeout_ms)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Poll the consumer for messages or events.  <a href="#a65cc6cb9bd72c4084f074af0361ceddf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a37b54d329e12d745889defe96e7d043d">rd_kafka_consumer_close</a> (rd_kafka_t *rk)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close down the KafkaConsumer.  <a href="#a37b54d329e12d745889defe96e7d043d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a0566419eff2001f8371e3b50aa7d26e9">rd_kafka_assign</a> (rd_kafka_t *rk, const <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *partitions)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Atomic assignment of partitions to consume.  <a href="#a0566419eff2001f8371e3b50aa7d26e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a10a00cc624a46209fe1192cfc56cce59">rd_kafka_assignment</a> (rd_kafka_t *rk, <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> **partitions)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current partition assignment.  <a href="#a10a00cc624a46209fe1192cfc56cce59"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ab96539928328f14c3c9177ea0c896c87">rd_kafka_commit</a> (rd_kafka_t *rk, const <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *offsets, int async)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Commit offsets on broker for the provided list of partitions.  <a href="#ab96539928328f14c3c9177ea0c896c87"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a99fb25d50216e4e20d303bf8a4a62883">rd_kafka_commit_message</a> (rd_kafka_t *rk, const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, int async)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Commit message's offset on broker for the message's partition.  <a href="#a99fb25d50216e4e20d303bf8a4a62883"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aa793dd9c195f39bcb69465cebf534c47">rd_kafka_commit_queue</a> (rd_kafka_t *rk, const <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *offsets, rd_kafka_queue_t *rkqu, void(*cb)(rd_kafka_t *rk, <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> err, <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *offsets, void *opaque), void *opaque)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Commit offsets on broker for the provided list of partitions.  <a href="#aa793dd9c195f39bcb69465cebf534c47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a39846ae321a03c4679c9c659f18adf13">rd_kafka_committed</a> (rd_kafka_t *rk, <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *partitions, int timeout_ms)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve committed offsets for topics+partitions.  <a href="#a39846ae321a03c4679c9c659f18adf13"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a6e9e36bd9e6bf84a9f3092fcbfa3a9ac">rd_kafka_position</a> (rd_kafka_t *rk, <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *partitions)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve current positions (offsets) for topics+partitions.  <a href="#a6e9e36bd9e6bf84a9f3092fcbfa3a9ac"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Metadata API</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp94b5794f4d8ae2544a962c0a639f635d"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a84bba4a4b13fdb515f1a22d6fd4f7344">rd_kafka_metadata</a> (rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request Metadata from broker.  <a href="#a84bba4a4b13fdb515f1a22d6fd4f7344"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b4ee98ab1c76f3504edf9eed986844e"></a><!-- doxytag: member="rdkafka.h::rd_kafka_metadata_destroy" ref="a0b4ee98ab1c76f3504edf9eed986844e" args="(const struct rd_kafka_metadata *metadata)" -->
RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a0b4ee98ab1c76f3504edf9eed986844e">rd_kafka_metadata_destroy</a> (const struct rd_kafka_metadata *metadata)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release metadata memory. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Client group information</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpf80e2c9777f60e97429463ee9c73b67e"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a6cfc79819453ecd4aa94fbae6dbbea0a">rd_kafka_list_groups</a> (rd_kafka_t *rk, const char *group, const struct <a class="el" href="structrd__kafka__group__list.html">rd_kafka_group_list</a> **grplistp, int timeout_ms)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List and describe client groups in cluster.  <a href="#a6cfc79819453ecd4aa94fbae6dbbea0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab28e1cb749e7e62168107ccdee1960ea"></a><!-- doxytag: member="rdkafka.h::rd_kafka_group_list_destroy" ref="ab28e1cb749e7e62168107ccdee1960ea" args="(const struct rd_kafka_group_list *grplist)" -->
RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ab28e1cb749e7e62168107ccdee1960ea">rd_kafka_group_list_destroy</a> (const struct <a class="el" href="structrd__kafka__group__list.html">rd_kafka_group_list</a> *grplist)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release list memory. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous APIs</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp2d330f86646ec7acacedf7876d458b15"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ab83da8da989fe41693d78d982c7ae6b7">rd_kafka_brokers_add</a> (rd_kafka_t *rk, const char *brokerlist)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds one or more brokers to the kafka handle's list of initial bootstrap brokers.  <a href="#ab83da8da989fe41693d78d982c7ae6b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT RD_DEPRECATED void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a9e4af9adee414af74c7817403f7c4a53">rd_kafka_set_logger</a> (rd_kafka_t *rk, void(*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set logger function.  <a href="#a9e4af9adee414af74c7817403f7c4a53"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#acadeefced6bb60acd27e7a0dad553aa4">rd_kafka_set_log_level</a> (rd_kafka_t *rk, int level)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specifies the maximum logging level produced by internal kafka logging and debugging.  <a href="#acadeefced6bb60acd27e7a0dad553aa4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d37a5cef2d6aa0077fdfd23e3020ca7"></a><!-- doxytag: member="rdkafka.h::rd_kafka_log_print" ref="a3d37a5cef2d6aa0077fdfd23e3020ca7" args="(const rd_kafka_t *rk, int level, const char *fac, const char *buf)" -->
RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a3d37a5cef2d6aa0077fdfd23e3020ca7">rd_kafka_log_print</a> (const rd_kafka_t *rk, int level, const char *fac, const char *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builtin (default) log sink: print to stderr. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a748d5eaca75f94bb4ff4217ae824385d"></a><!-- doxytag: member="rdkafka.h::rd_kafka_log_syslog" ref="a748d5eaca75f94bb4ff4217ae824385d" args="(const rd_kafka_t *rk, int level, const char *fac, const char *buf)" -->
RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a748d5eaca75f94bb4ff4217ae824385d">rd_kafka_log_syslog</a> (const rd_kafka_t *rk, int level, const char *fac, const char *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builtin log sink: print to syslog. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ad4b3b7659cf9a79d3353810d6b625bb7">rd_kafka_outq_len</a> (rd_kafka_t *rk)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current out queue length.  <a href="#ad4b3b7659cf9a79d3353810d6b625bb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a27a46f74ec4ccc9c0b36dbcf546908a1">rd_kafka_dump</a> (FILE *fp, rd_kafka_t *rk)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dumps rdkafka's internal state for handle <code>rk</code> to stream <code>fp</code>.  <a href="#a27a46f74ec4ccc9c0b36dbcf546908a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a0901699375c972b807ba5255773f017f">rd_kafka_thread_cnt</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the current number of threads in use by librdkafka.  <a href="#a0901699375c972b807ba5255773f017f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aa90f2c92a382dbd0a090d40caa73356d">rd_kafka_wait_destroyed</a> (int timeout_ms)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for all rd_kafka_t objects to be destroyed.  <a href="#aa90f2c92a382dbd0a090d40caa73356d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ab932d463be030a5e83ebfc5186ff20b8">rd_kafka_unittest</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Run librdkafka's built-in unit-tests.  <a href="#ab932d463be030a5e83ebfc5186ff20b8"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Experimental APIs</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp5208c0e673c09734d7dcea4bb733ff14"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a9bfa0a1dd3f866cbf0c82fc089bd7904">rd_kafka_poll_set_consumer</a> (rd_kafka_t *rk)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Redirect the main (<a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4" title="Polls the provided kafka handle for events.">rd_kafka_poll()</a>) queue to the KafkaConsumer's queue (<a class="el" href="rdkafka_8h.html#a65cc6cb9bd72c4084f074af0361ceddf" title="Poll the consumer for messages or events.">rd_kafka_consumer_poll()</a>).  <a href="#a9bfa0a1dd3f866cbf0c82fc089bd7904"></a><br/></td></tr>
<tr><td colspan="2"><h2>librdkafka version</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp932136577c7cf10146d19d48ff98324b"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aa2e242fb8620a32b650a40575bc7f98e">RD_KAFKA_VERSION</a>&nbsp;&nbsp;&nbsp;0x000b04c9</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">librdkafka version  <a href="#aa2e242fb8620a32b650a40575bc7f98e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a83e363606ef2da2e91b7429b229dbc8e">rd_kafka_version</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the librdkafka version as integer.  <a href="#a83e363606ef2da2e91b7429b229dbc8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a0cc60434083686fd8e379a905652d34a">rd_kafka_version_str</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the librdkafka version as string.  <a href="#a0cc60434083686fd8e379a905652d34a"></a><br/></td></tr>
<tr><td colspan="2"><h2>Constants, errors, types</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpbe91c33b68b07612917c92960fef9c97"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aed25dba90c47adc8ae51d098dca2aed9">RD_KAFKA_DEBUG_CONTEXTS</a>&nbsp;&nbsp;&nbsp;&quot;all,generic,broker,topic,metadata,feature,queue,msg,protocol,cgrp,security,fetch,interceptor,plugin,consumer&quot;</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Supported debug contexts. (compile time).  <a href="#aed25dba90c47adc8ae51d098dca2aed9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831">rd_kafka_type_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831ae6134e8d67bee67bfe5e90783f3b9dc8">RD_KAFKA_PRODUCER</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831abdc1bc1d648fb12ee3f7d42de732e049">RD_KAFKA_CONSUMER</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>rd_kafka_t handle type. </p>
 <a href="rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#af7cb459a230a61489234823da2beb3f3">rd_kafka_timestamp_type_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#af7cb459a230a61489234823da2beb3f3a9787f345653eaccb6b0020d8eb36d647">RD_KAFKA_TIMESTAMP_NOT_AVAILABLE</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#af7cb459a230a61489234823da2beb3f3af59e58fbfe91ffafad1c1b107e32022e">RD_KAFKA_TIMESTAMP_CREATE_TIME</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#af7cb459a230a61489234823da2beb3f3afb39205b4fd7d71547c05f94bf8d70a8">RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME</a>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba2142df2480425e88d9d96b1b08cc7c67">RD_KAFKA_RESP_ERR__BEGIN</a> =  -200, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba807f99673a16c6dfc2d6711a142fdf63">RD_KAFKA_RESP_ERR__BAD_MSG</a> =  -199, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba83f21df6d9e4919fa6f63f4978d92e31">RD_KAFKA_RESP_ERR__BAD_COMPRESSION</a> =  -198, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba9701b1e8dbfd8514773837924607985d">RD_KAFKA_RESP_ERR__DESTROY</a> =  -197, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba499a09426c7317e0c8030be5bfadd6a2">RD_KAFKA_RESP_ERR__FAIL</a> =  -196, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaa2e905024b42d56f177547ef2c6921f2">RD_KAFKA_RESP_ERR__TRANSPORT</a> =  -195, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbad854e2c94bb5b92e83cdbe5d1b1a98ab">RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE</a> =  -194, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba86ca698f5d4d99a0d61b0ec62c6ab093">RD_KAFKA_RESP_ERR__RESOLVE</a> =  -193, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbacb94a826892b8fef52de2c326f765172">RD_KAFKA_RESP_ERR__MSG_TIMED_OUT</a> =  -192, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaffd61f12a5298f508039a9e2521752a5">RD_KAFKA_RESP_ERR__PARTITION_EOF</a> =  -191, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba1703a6690b6278c4ce60a7745d81c435">RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION</a> =  -190, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba184f6fcda3fe1f6549c45f621dc456bf">RD_KAFKA_RESP_ERR__FS</a> =  -189, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbacc9b54e879dba9f6ed3c6e4492a4ae9e">RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC</a> =  -188, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbadf1a1cc2d9244d10b5d9b2176da1a7b1">RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN</a> =  -187, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba44458ff21ab957663118decae3fe0a31">RD_KAFKA_RESP_ERR__INVALID_ARG</a> =  -186, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba191a3d68aab046a25af5e861a5ce394e">RD_KAFKA_RESP_ERR__TIMED_OUT</a> =  -185, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba8614bce6b6367c95e05003ed953abefa">RD_KAFKA_RESP_ERR__QUEUE_FULL</a> =  -184, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba35e614340fa0417a954a94d9ed252be3">RD_KAFKA_RESP_ERR__ISR_INSUFF</a> =  -183, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbad6b23970e00b4575556e8bf6669b1907">RD_KAFKA_RESP_ERR__NODE_UPDATE</a> =  -182, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbafa666e504c1c4db6132bb8cc62789bd7">RD_KAFKA_RESP_ERR__SSL</a> =  -181, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaff33cdcf5c414f862d30bfc971d9b883">RD_KAFKA_RESP_ERR__WAIT_COORD</a> =  -180, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba34f3842df468d18d83eaf06fcb1ec133">RD_KAFKA_RESP_ERR__UNKNOWN_GROUP</a> =  -179, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba3aa91f47659cd8db6e526d61bd801bb0">RD_KAFKA_RESP_ERR__IN_PROGRESS</a> =  -178, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba7e8c91550c7f80e3bde03d2e2a26a13f">RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS</a> =  -177, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba564de373d65dea2640f879b8f38032ba">RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION</a> =  -176, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba4eab145a6f57f455bdde22cb94b61e90">RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS</a> =  -175, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba52a7ba59b755f419beec0433cb1633bb">RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS</a> =  -174, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbab7a5dd3646ae093462cd3bb7add5c591">RD_KAFKA_RESP_ERR__CONFLICT</a> =  -173, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba6953cd96832fca9dab355a87dd83ac0d">RD_KAFKA_RESP_ERR__STATE</a> =  -172, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba8c92444502a2e12e78e34c293bcdd341">RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL</a> =  -171, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba8a4196c480d8dde72c14c390fe94b113">RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED</a> =  -170, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba87e67feaf9a884055ca195ece3ccf1c4">RD_KAFKA_RESP_ERR__AUTHENTICATION</a> =  -169, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbada22593237070471d4ce1de595d1a0ae">RD_KAFKA_RESP_ERR__NO_OFFSET</a> =  -168, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba48d28854717a35c7607ce851a75bcdc7">RD_KAFKA_RESP_ERR__OUTDATED</a> =  -167, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbac0bdc2e1ad2796d55446e038af7b24aa">RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE</a> =  -166, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbae7d5f35c2cf0641d7952d6cdf8b065ee">RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE</a> =  -165, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba86c020648a3e8257a018955196efea23">RD_KAFKA_RESP_ERR__WAIT_CACHE</a> =  -164, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaef87b84297d178bfe7938e21916f7283">RD_KAFKA_RESP_ERR__INTR</a> =  -163, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba97ca26a246e51745da9d3859f5640839">RD_KAFKA_RESP_ERR__KEY_SERIALIZATION</a> =  -162, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba50ccfe49dddd07786207cb0a126ea300">RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION</a> =  -161, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaf806877fb6d670e586bffc367f4dec55">RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION</a> =  -160, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbad9d20886a20fbace5a8768f5c817cc96">RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION</a> =  -159, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba8cc1816a0044ca635671d88389e39729">RD_KAFKA_RESP_ERR__PARTIAL</a> =  -158, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba3b8c36bb901214ee29c1f912cbb1b669">RD_KAFKA_RESP_ERR__READ_ONLY</a> =  -157, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba22abafa69d4f05fdbaf08ed0b56fec47">RD_KAFKA_RESP_ERR__NOENT</a> =  -156, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba204a75c2a865248e4a2d4aaa167ab6bc">RD_KAFKA_RESP_ERR__UNDERFLOW</a> =  -155, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaebda7d93e71b33ea682f2cdb2d025c0c">RD_KAFKA_RESP_ERR__END</a> =  -100, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbafd4f4e867c50ec320e86871b98b7b15e">RD_KAFKA_RESP_ERR_UNKNOWN</a> =  -1, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaeb15f812641343033e3939df4adfff0a">RD_KAFKA_RESP_ERR_NO_ERROR</a> =  0, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaab466ebc9f9efcdbedfef4e57449adf4">RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE</a> =  1, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbadaaa397721f1566aa1befbb42635c6c9">RD_KAFKA_RESP_ERR_INVALID_MSG</a> =  2, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba22f2b9f295640b43bbd20b064931eaa4">RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART</a> =  3, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba4a78c95be9dce44441151db0f064939e">RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE</a> =  4, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba1b8fa864f8174e650a362d6c85c4acac">RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE</a> =  5, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba48f7ea11514f0d02c090a0bf52deabb8">RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION</a> =  6, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba1944ffe5311ce97d4f71133efd5f745f">RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT</a> =  7, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba7021ad7d7486a4a33e19df226908f6f4">RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE</a> =  8, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba550f9d64d5e2d05c61b5f18942832854">RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE</a> =  9, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba2c5f25f8d58662c06485884c62ccd728">RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE</a> =  10, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba901383ac11a5068e5cfa64fe0899ef42">RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH</a> =  11, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbad1ace41b4944aa8510d001cc0750af3d">RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE</a> =  12, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba24a154a4fd4b62b7a7fa77b816561c49">RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION</a> =  13, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba837e05b8dc24415d0cdd24fa90c94c2b">RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS</a> =  14, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba4b2032a44b39cfcf79af6d38cfee53d6">RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE</a> =  15, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbae3cca426eb84d8c987fcd22d93e3b042">RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP</a> =  16, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaffe696a1bb54ec33b8d258a71d138630">RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION</a> =  17, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba2427070db08c0dbf603d7a439ecafa4e">RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE</a> =  18, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba963396ec3f0141e7cd64eb9103ba025a">RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS</a> =  19, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba3c6bd5bd0a338857481157ad58701285">RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND</a> =  20, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba1bcf9b14d3109e0906710f3fedf6bfa0">RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS</a> =  21, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba7ef65ef4b7e4883d37f07edb2b9299cf">RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION</a> =  22, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba3d611434978ee6c5d1e2c031eae22851">RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL</a> =  23, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba617af6d0a3be8be217a6d4097fe08d93">RD_KAFKA_RESP_ERR_INVALID_GROUP_ID</a> =  24, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba98ba2fb36473df8aa20eece119b5c371">RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID</a> =  25, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbacbf57dcb89cbe4e8109009235c3a38a3">RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT</a> =  26, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbafacbf6cd012723e9deeffdbedb086c34">RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS</a> =  27, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbabce6dddfb9449a93d89f5175259b01f5">RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE</a> =  28, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbac3ca8f351f7f49bc644360d70def9d15">RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED</a> =  29, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaf6a3717285b4de6d098778d5abff62d3">RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED</a> =  30, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba91be303afca8631793ae36cd7fa5eb9b">RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED</a> =  31, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaa36b8c17d6e57243b85992c8a4c4fbf8">RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP</a> =  32, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbab6e2e19fa13d5a65dcd0a09cc00e94fa">RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM</a> =  33, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaf2c0ee45c60d46a1dfb209afcbc97e3f">RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE</a> =  34, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba46f16f7c02e3798695feff061acd3f72">RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION</a> =  35, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba2bbe3972fadcb5659de8ba452ba9930d">RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS</a> =  36, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbae389ad18fd247f5194ecd8b06bab8af0">RD_KAFKA_RESP_ERR_INVALID_PARTITIONS</a> =  37, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba79bf494e4989ba2d6ef2d5dfe35e07d4">RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR</a> =  38, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbae2bc328101f522588761a21bd1e92d33">RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT</a> =  39, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba31a534f09b2d2be5e31186ee019be02d">RD_KAFKA_RESP_ERR_INVALID_CONFIG</a> =  40, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba57763f968ed247ada93b95f5871c6421">RD_KAFKA_RESP_ERR_NOT_CONTROLLER</a> =  41, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaa9136aa227a79576e599b693280e47f4">RD_KAFKA_RESP_ERR_INVALID_REQUEST</a> =  42, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba09cc6445761305511ec565a1fb578e63">RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT</a> =  43, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba008f9c1a7d4dbbb7b8629329cb94f4d4">RD_KAFKA_RESP_ERR_POLICY_VIOLATION</a> =  44, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbaf78bc9392ecbb491f44f00304db31c5d">RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER</a> =  45, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbac29fba93ef898d51228e3b5254f89e93">RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER</a> =  46, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba246438ea75f6160876ac25460e1e2a76">RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH</a> =  47, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba967df10eecf66034efc36e76eb5d4da8">RD_KAFKA_RESP_ERR_INVALID_TXN_STATE</a> =  48, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba386fa6212eb07e2e81ed0b30d03f975b">RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING</a> =  49, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba0e1a90d8d8a6b03e51d2bdcd61c84977">RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT</a> =  50, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba9cc06f97e19cb867471f4fc3039cb92e">RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS</a> =  51, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba01826892e952e952e5cd0a3a025e3ff3">RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED</a> =  52, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cbac8538f30651540470a5d9691cdfeb6ac">RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED</a> =  53, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba3fcd641c7927aee35edd5766bd694ec9">RD_KAFKA_RESP_ERR_SECURITY_DISABLED</a> =  54, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba0c64f1f4d8901d3266ea8bf89f994119">RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED</a> =  55, 
<br/>
&nbsp;&nbsp;<b>RD_KAFKA_RESP_ERR_END_ALL</b>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Error codes. </p>
 <a href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#adece97d3cbdd6ca936df5b0663118c45">rd_kafka_get_debug_contexts</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve supported debug contexts for use with the <code>\"debug\"</code> configuration property. (runtime).  <a href="#adece97d3cbdd6ca936df5b0663118c45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0475de10b4ad6c20f722fcacbd85aacd"></a><!-- doxytag: member="rdkafka.h::rd_kafka_get_err_descs" ref="a0475de10b4ad6c20f722fcacbd85aacd" args="(const struct rd_kafka_err_desc **errdescs, size_t *cntp)" -->
RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a0475de10b4ad6c20f722fcacbd85aacd">rd_kafka_get_err_descs</a> (const struct <a class="el" href="structrd__kafka__err__desc.html">rd_kafka_err_desc</a> **errdescs, size_t *cntp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the full list of error codes. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ab7bfc925e8d63851511b88a1cee94d6d">rd_kafka_err2str</a> (<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a human readable representation of a kafka error.  <a href="#ab7bfc925e8d63851511b88a1cee94d6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a8d5f6f2775ec67b124abeb5dfada2d77">rd_kafka_err2name</a> (<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the error code name (enum name).  <a href="#a8d5f6f2775ec67b124abeb5dfada2d77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ae7b90c323d460e0276d79f6ab69e93b7">rd_kafka_last_error</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the last error code generated by a legacy API call in the current thread.  <a href="#ae7b90c323d460e0276d79f6ab69e93b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT RD_DEPRECATED <br class="typebreak"/>
<a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#abeabf8589c657d7a3ec5a1411a7de91d">rd_kafka_errno2err</a> (int errnox)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts the system errno value <code>errnox</code> to a rd_kafka_resp_err_t error code upon failure from the following functions:</p>
<ul>
<li><a class="el" href="rdkafka_8h.html#ab1dcba74a35e8f3bfe3270ff600581d8" title="Creates a new topic handle for topic named topic.">rd_kafka_topic_new()</a></li>
<li><a class="el" href="rdkafka_8h.html#ae21dcd2d8c6195baf7f9f4952d7e12d4" title="Start consuming messages for topic rkt and partition at offset offset which may either...">rd_kafka_consume_start()</a></li>
<li><a class="el" href="rdkafka_8h.html#acf07475e5e85e63fc5321a1087288cd4" title="Stop consuming messages for topic rkt and partition, purging all messages currently...">rd_kafka_consume_stop()</a></li>
<li><a class="el" href="rdkafka_8h.html#aa49d14e8b742365f9f25d35318ff0b7e" title="Consume a single message from topic rkt and partition.">rd_kafka_consume()</a></li>
<li><a class="el" href="rdkafka_8h.html#a53511739a2cf498b8d88287fef6873ce" title="Consume up to rkmessages_size from topic rkt and partition putting a pointer to each...">rd_kafka_consume_batch()</a></li>
<li><a class="el" href="rdkafka_8h.html#a303fa0f0da7f3c28bed35570adc983c6" title="Consumes messages from topic rkt and partition, calling the provided callback for...">rd_kafka_consume_callback()</a></li>
<li><a class="el" href="rdkafka_8h.html#a8ff0b80fccb3a5bd31b1baaf20e4ca16" title="Consume from queue.">rd_kafka_consume_queue()</a></li>
<li><a class="el" href="rdkafka_8h.html#ae24d8ebf1ea15ed8ea0ea40f74662736" title="Produce and send a single message to broker.">rd_kafka_produce()</a>. </li>
</ul>
 <a href="#abeabf8589c657d7a3ec5a1411a7de91d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT RD_DEPRECATED int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a8aa1b1a41d2fc0c487f519663609df4f">rd_kafka_errno</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the thread-local system errno.  <a href="#a8aa1b1a41d2fc0c487f519663609df4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ac5a7b02e3af816cfacbcfa6468c40c9a">rd_kafka_topic_partition_destroy</a> (<a class="el" href="structrd__kafka__topic__partition__t.html">rd_kafka_topic_partition_t</a> *rktpar)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a <a class="el" href="structrd__kafka__topic__partition__t.html" title="Topic+Partition place holder.">rd_kafka_topic_partition_t</a>.  <a href="#ac5a7b02e3af816cfacbcfa6468c40c9a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <br class="typebreak"/>
<a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#afb87d24333b6ad5a7415b06882f06b2a">rd_kafka_topic_partition_list_new</a> (int size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new list/vector Topic+Partition container.  <a href="#afb87d24333b6ad5a7415b06882f06b2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c0ab2640e5e96113ce108ab78f475d0"></a><!-- doxytag: member="rdkafka.h::rd_kafka_topic_partition_list_destroy" ref="a0c0ab2640e5e96113ce108ab78f475d0" args="(rd_kafka_topic_partition_list_t *rkparlist)" -->
RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a0c0ab2640e5e96113ce108ab78f475d0">rd_kafka_topic_partition_list_destroy</a> (<a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *rkparlist)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free all resources used by the list and the list itself. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <br class="typebreak"/>
<a class="el" href="structrd__kafka__topic__partition__t.html">rd_kafka_topic_partition_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a123ce30e08b31d4ff0fcf6ebe876173d">rd_kafka_topic_partition_list_add</a> (<a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *rktparlist, const char *topic, int32_t partition)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add topic+partition to list.  <a href="#a123ce30e08b31d4ff0fcf6ebe876173d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a6365695de425e7866ddd0c59d704111b">rd_kafka_topic_partition_list_add_range</a> (<a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *rktparlist, const char *topic, int32_t start, int32_t stop)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add range of partitions from <code>start</code> to <code>stop</code> inclusive.  <a href="#a6365695de425e7866ddd0c59d704111b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a94a8195aa5f0195d020494bced858a97">rd_kafka_topic_partition_list_del</a> (<a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *rktparlist, const char *topic, int32_t partition)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete partition from list.  <a href="#a94a8195aa5f0195d020494bced858a97"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a8476ebf3c2f54ddee53e0863feb85463">rd_kafka_topic_partition_list_del_by_idx</a> (<a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *rktparlist, int idx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete partition from list by elems[] index.  <a href="#a8476ebf3c2f54ddee53e0863feb85463"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <br class="typebreak"/>
<a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a66fd3f8c00ffbd0ea740a638dd0a95f7">rd_kafka_topic_partition_list_copy</a> (const <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a copy of an existing list.  <a href="#a66fd3f8c00ffbd0ea740a638dd0a95f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a102b340b901babb247d2c0a8580a094d">rd_kafka_topic_partition_list_set_offset</a> (<a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *rktparlist, const char *topic, int32_t partition, int64_t offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set offset to <code>offset</code> for <code>topic</code> and <code>partition</code>.  <a href="#a102b340b901babb247d2c0a8580a094d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <br class="typebreak"/>
<a class="el" href="structrd__kafka__topic__partition__t.html">rd_kafka_topic_partition_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ab25d8e4e58c891bdc533471c210697fa">rd_kafka_topic_partition_list_find</a> (<a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *rktparlist, const char *topic, int32_t partition)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find element by <code>topic</code> and <code>partition</code>.  <a href="#ab25d8e4e58c891bdc533471c210697fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ab72ed92794eabf2e7ba1b7be9c94de1f">rd_kafka_topic_partition_list_sort</a> (<a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *rktparlist, int(*cmp)(const void *a, const void *b, void *opaque), void *opaque)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sort list using comparator <code>cmp</code>.  <a href="#ab72ed92794eabf2e7ba1b7be9c94de1f"></a><br/></td></tr>
<tr><td colspan="2"><h2>Var-arg tag types</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpe5bda31d3506867d32d12144ddf9a71e"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a03c74ceba678b4e7a624310160a02165">RD_KAFKA_V_END</a>&nbsp;&nbsp;&nbsp;RD_KAFKA_VTYPE_END</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience macros for rd_kafka_vtype_t that takes the correct arguments for each vtype.  <a href="#a03c74ceba678b4e7a624310160a02165"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a6e7b87a5507f79819059f11ded369786">RD_KAFKA_V_TOPIC</a>(topic)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a64fb46a5855c6a2bd0c642fa639bff37">RD_KAFKA_V_RKT</a>(rkt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ab8ee15fd5d9f441f5b0bba62815ea2f3">RD_KAFKA_V_PARTITION</a>(partition)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ae8ec8f37eff67ab3b2321329870d4c08">RD_KAFKA_V_VALUE</a>(VALUE, LEN)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aac7c275dc2b977f4aa761962a4008144">RD_KAFKA_V_KEY</a>(KEY, LEN)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a3b18233761cb0f59215b49108e41ee9b">RD_KAFKA_V_OPAQUE</a>(opaque)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a10d50abbc375a50ed9ec26972cf72bb0">RD_KAFKA_V_MSGFLAGS</a>(msgflags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#afc05e7e3d017c9a07da61c3edb69f61b">RD_KAFKA_V_TIMESTAMP</a>(timestamp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a2a6b8f2572433964f73f23cf9c13a619">RD_KAFKA_V_HEADER</a>(NAME, VALUE, LEN)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a6d4dd1a47c26763fb24e2c422672aa9d">RD_KAFKA_V_HEADERS</a>(HDRS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b">rd_kafka_vtype_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6ba8392cf8f43a2127fc4fbb1ae50af6f8f">RD_KAFKA_VTYPE_END</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6ba2963e9a4838eb825ad954757a965fd45">RD_KAFKA_VTYPE_TOPIC</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6ba37f0b8d0b3add4ad93bdf7ef6863abd9">RD_KAFKA_VTYPE_RKT</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6ba2374c0d8cd0d293aebd40b687db16b12">RD_KAFKA_VTYPE_PARTITION</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6baa5c06c93cea11334ee6fd41379dd849d">RD_KAFKA_VTYPE_VALUE</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6ba83433ee19c9f47e5f561649ab7768cdf">RD_KAFKA_VTYPE_KEY</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6baa3db5c202df5e978f003cd1c0f1fec29">RD_KAFKA_VTYPE_OPAQUE</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6ba2f55d9d2b0729843f99c758155e948da">RD_KAFKA_VTYPE_MSGFLAGS</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6baf2f1861778d90a40cf0c498985fbc768">RD_KAFKA_VTYPE_TIMESTAMP</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6ba5ee53e13817abfea4e94590892cb57f8">RD_KAFKA_VTYPE_HEADER</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6ba26701ae2fe9028f50386a2417ace24a9">RD_KAFKA_VTYPE_HEADERS</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Var-arg tag types. </p>
 <a href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Main Kafka and Topic object handles</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp4ab791e9ce05e439ebcde994ba073fd4"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a3002d1858385de283ea004893e352863">RD_KAFKA_PARTITION_UA</a>&nbsp;&nbsp;&nbsp;((int32_t)-1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unassigned partition.  <a href="#a3002d1858385de283ea004893e352863"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT rd_kafka_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a63d5cd86ab1f77772b2be170e1c09c24">rd_kafka_new</a> (<a class="el" href="rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831">rd_kafka_type_t</a> type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new Kafka handle and starts its operation according to the specified <code>type</code> (<code>RD_KAFKA_CONSUMER</code> or <code>RD_KAFKA_PRODUCER</code>).  <a href="#a63d5cd86ab1f77772b2be170e1c09c24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ac052e92621dcaa3a336dbf826e0d7794">rd_kafka_destroy</a> (rd_kafka_t *rk)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy Kafka handle.  <a href="#ac052e92621dcaa3a336dbf826e0d7794"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b15780ab1691b38b7b59e823484e1d2"></a><!-- doxytag: member="rdkafka.h::rd_kafka_name" ref="a9b15780ab1691b38b7b59e823484e1d2" args="(const rd_kafka_t *rk)" -->
RD_EXPORT const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a9b15780ab1691b38b7b59e823484e1d2">rd_kafka_name</a> (const rd_kafka_t *rk)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns Kafka handle name. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6a4a052441322268b3d787d05d70e74"></a><!-- doxytag: member="rdkafka.h::rd_kafka_type" ref="ab6a4a052441322268b3d787d05d70e74" args="(const rd_kafka_t *rk)" -->
RD_EXPORT <a class="el" href="rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831">rd_kafka_type_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ab6a4a052441322268b3d787d05d70e74">rd_kafka_type</a> (const rd_kafka_t *rk)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns Kafka handle type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a856d7ecba1aa64e5c89ac92b445cdda6">rd_kafka_memberid</a> (const rd_kafka_t *rk)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns this client's broker-assigned group member id.  <a href="#a856d7ecba1aa64e5c89ac92b445cdda6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a261ba8c649756fbc7fbcd442ae481a18">rd_kafka_clusterid</a> (rd_kafka_t *rk, int timeout_ms)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the ClusterId as reported in broker metadata.  <a href="#a261ba8c649756fbc7fbcd442ae481a18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT rd_kafka_topic_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ab1dcba74a35e8f3bfe3270ff600581d8">rd_kafka_topic_new</a> (rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new topic handle for topic named <code>topic</code>.  <a href="#ab1dcba74a35e8f3bfe3270ff600581d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a91f46cd29d4f9abacd3ee3633c01d8ff">rd_kafka_topic_destroy</a> (rd_kafka_topic_t *rkt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loose application's topic handle refcount as previously created with `rd_kafka_topic_new()`.  <a href="#a91f46cd29d4f9abacd3ee3633c01d8ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ea8248521e63b4afb1d292fbcc584e2"></a><!-- doxytag: member="rdkafka.h::rd_kafka_topic_name" ref="a3ea8248521e63b4afb1d292fbcc584e2" args="(const rd_kafka_topic_t *rkt)" -->
RD_EXPORT const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a3ea8248521e63b4afb1d292fbcc584e2">rd_kafka_topic_name</a> (const rd_kafka_topic_t *rkt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the topic name. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a022c498c5593a4bbfa978753cf250aed"></a><!-- doxytag: member="rdkafka.h::rd_kafka_topic_opaque" ref="a022c498c5593a4bbfa978753cf250aed" args="(const rd_kafka_topic_t *rkt)" -->
RD_EXPORT void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a022c498c5593a4bbfa978753cf250aed">rd_kafka_topic_opaque</a> (const rd_kafka_topic_t *rkt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the <code>rkt_opaque</code> pointer that was set in the topic configuration. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4">rd_kafka_poll</a> (rd_kafka_t *rk, int timeout_ms)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Polls the provided kafka handle for events.  <a href="#ad50c431e3a29d14da534db49bd0682a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a111628df6c84716c4b550f8509ac6a6d">rd_kafka_yield</a> (rd_kafka_t *rk)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancels the current callback dispatcher (<a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4" title="Polls the provided kafka handle for events.">rd_kafka_poll()</a>, <a class="el" href="rdkafka_8h.html#a303fa0f0da7f3c28bed35570adc983c6" title="Consumes messages from topic rkt and partition, calling the provided callback for...">rd_kafka_consume_callback()</a>, etc).  <a href="#a111628df6c84716c4b550f8509ac6a6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a293cb2aac290c157702d3b82f5c14fce">rd_kafka_pause_partitions</a> (rd_kafka_t *rk, <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *partitions)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pause producing or consumption for the provided list of partitions.  <a href="#a293cb2aac290c157702d3b82f5c14fce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ad05819f26887a916ad2047d96a7b4bf2">rd_kafka_resume_partitions</a> (rd_kafka_t *rk, <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *partitions)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resume producing consumption for the provided list of partitions.  <a href="#ad05819f26887a916ad2047d96a7b4bf2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a4550ff7d014f08406666124573f70495">rd_kafka_query_watermark_offsets</a> (rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query broker for low (oldest/beginning) and high (newest/end) offsets for partition.  <a href="#a4550ff7d014f08406666124573f70495"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ad1d338cebde98a76050e61301f631d82">rd_kafka_get_watermark_offsets</a> (rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get last known low (oldest/beginning) and high (newest/end) offsets for partition.  <a href="#ad1d338cebde98a76050e61301f631d82"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ae308aaf534807cfd4c71e423fc214929">rd_kafka_offsets_for_times</a> (rd_kafka_t *rk, <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *offsets, int timeout_ms)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Look up the offsets for the given partitions by timestamp.  <a href="#ae308aaf534807cfd4c71e423fc214929"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a50178b3d3266c9eeb0b5981377833572">rd_kafka_mem_free</a> (rd_kafka_t *rk, void *ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free pointer returned by librdkafka.  <a href="#a50178b3d3266c9eeb0b5981377833572"></a><br/></td></tr>
<tr><td colspan="2"><h2>Simple Consumer API (legacy)</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp8d3d618715f2cea4eabd9c9fbdb0bc74"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a32dc6dd93c16e3aac9b89804c4817fba">RD_KAFKA_OFFSET_BEGINNING</a>&nbsp;&nbsp;&nbsp;-2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aa7aaaf16e5bd7c0a8a8cb014275c3e06">RD_KAFKA_OFFSET_END</a>&nbsp;&nbsp;&nbsp;-1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a727dc7080140da43adbd5d0b170d49be">RD_KAFKA_OFFSET_STORED</a>&nbsp;&nbsp;&nbsp;-1000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ac2e48c4fef9e959ab43cad60ade84af1">RD_KAFKA_OFFSET_INVALID</a>&nbsp;&nbsp;&nbsp;-1001</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ae26a2522ce2d8ef8ce6c0235e8cfd409">RD_KAFKA_OFFSET_TAIL</a>(CNT)&nbsp;&nbsp;&nbsp;(RD_KAFKA_OFFSET_TAIL_BASE - (CNT))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start consuming <code>CNT</code> messages from topic's current end offset.  <a href="#ae26a2522ce2d8ef8ce6c0235e8cfd409"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ae21dcd2d8c6195baf7f9f4952d7e12d4">rd_kafka_consume_start</a> (rd_kafka_topic_t *rkt, int32_t partition, int64_t offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start consuming messages for topic <code>rkt</code> and <code>partition</code> at offset <code>offset</code> which may either be an absolute <code></code>(0..N) or one of the logical offsets:</p>
<ul>
<li>RD_KAFKA_OFFSET_BEGINNING</li>
<li>RD_KAFKA_OFFSET_END</li>
<li>RD_KAFKA_OFFSET_STORED</li>
<li>RD_KAFKA_OFFSET_TAIL. </li>
</ul>
 <a href="#ae21dcd2d8c6195baf7f9f4952d7e12d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a8e952d7961169471f69c7ddc87041258">rd_kafka_consume_start_queue</a> (rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as <a class="el" href="rdkafka_8h.html#ae21dcd2d8c6195baf7f9f4952d7e12d4" title="Start consuming messages for topic rkt and partition at offset offset which may either...">rd_kafka_consume_start()</a> but re-routes incoming messages to the provided queue <code>rkqu</code> (which must have been previously allocated with `rd_kafka_queue_new()`.  <a href="#a8e952d7961169471f69c7ddc87041258"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#acf07475e5e85e63fc5321a1087288cd4">rd_kafka_consume_stop</a> (rd_kafka_topic_t *rkt, int32_t partition)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stop consuming messages for topic <code>rkt</code> and <code>partition</code>, purging all messages currently in the local queue.  <a href="#acf07475e5e85e63fc5321a1087288cd4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a6667b162931982e9827e3d86ad22ec7d">rd_kafka_seek</a> (rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Seek consumer for topic+partition to <code>offset</code> which is either an absolute or logical offset.  <a href="#a6667b162931982e9827e3d86ad22ec7d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aa49d14e8b742365f9f25d35318ff0b7e">rd_kafka_consume</a> (rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Consume a single message from topic <code>rkt</code> and <code>partition</code>.  <a href="#aa49d14e8b742365f9f25d35318ff0b7e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a53511739a2cf498b8d88287fef6873ce">rd_kafka_consume_batch</a> (rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> **rkmessages, size_t rkmessages_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Consume up to <code>rkmessages_size</code> from topic <code>rkt</code> and <code>partition</code> putting a pointer to each message in the application provided array <code>rkmessages</code> (of size <code>rkmessages_size</code> entries).  <a href="#a53511739a2cf498b8d88287fef6873ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a303fa0f0da7f3c28bed35570adc983c6">rd_kafka_consume_callback</a> (rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void(*consume_cb)(<a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, void *opaque), void *opaque)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Consumes messages from topic <code>rkt</code> and <code>partition</code>, calling the provided callback for each consumed messsage.  <a href="#a303fa0f0da7f3c28bed35570adc983c6"></a><br/></td></tr>
<tr><td colspan="2"><h2>Producer API</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp8d1b3da22edbffd6567191366f10fea4"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a21be13f8a4cb1d5aff01419f333e5ea7">RD_KAFKA_MSG_F_FREE</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Producer message flags.  <a href="#a21be13f8a4cb1d5aff01419f333e5ea7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ad7468ab0ece73cc9cb6253a3dcfe702d">RD_KAFKA_MSG_F_COPY</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aca3cdf1c55668f4aa1c2391ddd39c9c2">RD_KAFKA_MSG_F_BLOCK</a>&nbsp;&nbsp;&nbsp;0x4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a991bd9378d2fc5b2102ce3a29805b345">RD_KAFKA_MSG_F_PARTITION</a>&nbsp;&nbsp;&nbsp;0x8</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ae24d8ebf1ea15ed8ea0ea40f74662736">rd_kafka_produce</a> (rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Produce and send a single message to broker.  <a href="#ae24d8ebf1ea15ed8ea0ea40f74662736"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ac3a111ec3e6729609d498fec7b619efc">rd_kafka_producev</a> (rd_kafka_t *rk,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Produce and send a single message to broker.  <a href="#ac3a111ec3e6729609d498fec7b619efc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a7ad15c71f228c47946500a0e5c6f88ed">rd_kafka_produce_batch</a> (rd_kafka_topic_t *rkt, int32_t partition, int msgflags, <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessages, int message_cnt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Produce multiple messages.  <a href="#a7ad15c71f228c47946500a0e5c6f88ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aaff06c4372bce917c17f3c1a5d8b205d">rd_kafka_flush</a> (rd_kafka_t *rk, int timeout_ms)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait until all outstanding produce requests, et.al, are completed. This should typically be done prior to destroying a producer instance to make sure all queued and in-flight produce requests are completed before terminating.  <a href="#aaff06c4372bce917c17f3c1a5d8b205d"></a><br/></td></tr>
<tr><td colspan="2"><h2>Event interface</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp8f8d406360749fdc432d935b2330a31a"></a>The event API provides an alternative pollable non-callback interface to librdkafka's message and event queues. </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2707dd1a6225e7649fd5d825284da4d"></a><!-- doxytag: member="rdkafka.h::RD_KAFKA_EVENT_NONE" ref="aa2707dd1a6225e7649fd5d825284da4d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>RD_KAFKA_EVENT_NONE</b>&nbsp;&nbsp;&nbsp;0x0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#abfe880d05ff52138b26dbe8b8e0d2132">RD_KAFKA_EVENT_DR</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#acfddfd9f3d49591dcd9e7f323dbcd865">RD_KAFKA_EVENT_FETCH</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a6265a9eeee57e83eb9f3bbd33d92700f">RD_KAFKA_EVENT_LOG</a>&nbsp;&nbsp;&nbsp;0x4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a080a7ad60de643f47424031ee95da103">RD_KAFKA_EVENT_ERROR</a>&nbsp;&nbsp;&nbsp;0x8</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a271e6a5984932015585dd5248535aa2b">RD_KAFKA_EVENT_REBALANCE</a>&nbsp;&nbsp;&nbsp;0x10</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a73a29f22b22433a93253a5f77c866437">RD_KAFKA_EVENT_OFFSET_COMMIT</a>&nbsp;&nbsp;&nbsp;0x20</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a67070a77150f54039273097c57da5965">RD_KAFKA_EVENT_STATS</a>&nbsp;&nbsp;&nbsp;0x40</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ea376a6d5fe278df583e873109b3c2f"></a><!-- doxytag: member="rdkafka.h::rd_kafka_event_type_t" ref="a8ea376a6d5fe278df583e873109b3c2f" args="" -->
typedef int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a8ea376a6d5fe278df583e873109b3c2f">rd_kafka_event_type_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Event types. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0b8cda889b33f5901c8aadb6c3e0d81"></a><!-- doxytag: member="rdkafka.h::rd_kafka_event_t" ref="ae0b8cda889b33f5901c8aadb6c3e0d81" args="" -->
typedef struct rd_kafka_op_s&nbsp;</td><td class="memItemRight" valign="bottom"><b>rd_kafka_event_t</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a8ea376a6d5fe278df583e873109b3c2f">rd_kafka_event_type_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a108de3729a4aa609a72a458a9de02d1d">rd_kafka_event_type</a> (const rd_kafka_event_t *rkev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a608193d1fb486f78c79497c8c5b63866">rd_kafka_event_name</a> (const rd_kafka_event_t *rkev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#af1835c85aa202caf629861f29f475099">rd_kafka_event_destroy</a> (rd_kafka_event_t *rkev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy an event.  <a href="#af1835c85aa202caf629861f29f475099"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT const <br class="typebreak"/>
<a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a3a855eb7bdf17f5797d4911362a5fc7c">rd_kafka_event_message_next</a> (rd_kafka_event_t *rkev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a18a17000ebe58eabcdafab37924442b8">rd_kafka_event_message_array</a> (rd_kafka_event_t *rkev, const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> **rkmessages, size_t size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extacts <code>size</code> message(s) from the event into the pre-allocated array <code>rkmessages</code>.  <a href="#a18a17000ebe58eabcdafab37924442b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a61d9d106c8956f379bb77d393b8acf90">rd_kafka_event_message_count</a> (rd_kafka_event_t *rkev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aa28b7d6bb4885843f9a8b9bafa0e15a5">rd_kafka_event_error</a> (rd_kafka_event_t *rkev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ad76a1b2d6c4f1727725b075678b88793">rd_kafka_event_error_string</a> (rd_kafka_event_t *rkev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a8650ed2a19108d490a65c9aff3e66525">rd_kafka_event_opaque</a> (rd_kafka_event_t *rkev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a535efaa16772642d724bedca414c17c7">rd_kafka_event_log</a> (rd_kafka_event_t *rkev, const char **fac, const char **str, int *level)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract log message from the event.  <a href="#a535efaa16772642d724bedca414c17c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ae8572e38ffb452f96d13a2d046fb71d9">rd_kafka_event_stats</a> (rd_kafka_event_t *rkev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract stats from the event.  <a href="#ae8572e38ffb452f96d13a2d046fb71d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <br class="typebreak"/>
<a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#abc8f98c9b35be497251fb8515e9e6633">rd_kafka_event_topic_partition_list</a> (rd_kafka_event_t *rkev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <br class="typebreak"/>
<a class="el" href="structrd__kafka__topic__partition__t.html">rd_kafka_topic_partition_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#abf4cce46d6e566dd35865c0451b76afe">rd_kafka_event_topic_partition</a> (rd_kafka_event_t *rkev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT rd_kafka_event_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a2f147ed1c554c9048893fb1adde86dfa">rd_kafka_queue_poll</a> (rd_kafka_queue_t *rkqu, int timeout_ms)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Poll a queue for an event for max <code>timeout_ms</code>.  <a href="#a2f147ed1c554c9048893fb1adde86dfa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a13d80084f20a2800e863b97e465ce98e">rd_kafka_queue_poll_callback</a> (rd_kafka_queue_t *rkqu, int timeout_ms)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Poll a queue for events served through callbacks for max <code>timeout_ms</code>.  <a href="#a13d80084f20a2800e863b97e465ce98e"></a><br/></td></tr>
<tr><td colspan="2"><h2>Configuration interface</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp3b07a21937d806e0679159e87f933b8e"></a>Main/global configuration property interface </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4aa1a1dc8e18c730866165853ad819054e">RD_KAFKA_CONF_UNKNOWN</a> =  -2, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4a4461e999ca6c9837a9265dad6f2a0d1e">RD_KAFKA_CONF_INVALID</a> =  -1, 
<br/>
&nbsp;&nbsp;<a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4a12343fa082ab52164a17130d6b0d0f5b">RD_KAFKA_CONF_OK</a> =  0
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Configuration result type. </p>
 <a href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT rd_kafka_conf_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aa7459bd22e8cfa81aa8c2480a4a0304c">rd_kafka_conf_new</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create configuration object.  <a href="#aa7459bd22e8cfa81aa8c2480a4a0304c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3669dacf78c5c0eb536d65cb45d0491"></a><!-- doxytag: member="rdkafka.h::rd_kafka_conf_destroy" ref="af3669dacf78c5c0eb536d65cb45d0491" args="(rd_kafka_conf_t *conf)" -->
RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#af3669dacf78c5c0eb536d65cb45d0491">rd_kafka_conf_destroy</a> (rd_kafka_conf_t *conf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroys a conf object. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT rd_kafka_conf_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a8cbfe15c6978ff09870e82cb524c673d">rd_kafka_conf_dup</a> (const rd_kafka_conf_t *conf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a copy/duplicate of configuration object <code>conf</code>.  <a href="#a8cbfe15c6978ff09870e82cb524c673d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ba6e2f87d41f38217eefe920b143189"></a><!-- doxytag: member="rdkafka.h::rd_kafka_conf_dup_filter" ref="a2ba6e2f87d41f38217eefe920b143189" args="(const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter)" -->
RD_EXPORT rd_kafka_conf_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a2ba6e2f87d41f38217eefe920b143189">rd_kafka_conf_dup_filter</a> (const rd_kafka_conf_t *conf, size_t filter_cnt, const char **filter)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as <a class="el" href="rdkafka_8h.html#a8cbfe15c6978ff09870e82cb524c673d" title="Creates a copy/duplicate of configuration object conf.">rd_kafka_conf_dup()</a> but with an array of property name prefixes to filter out (ignore) when copying. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#abb1b319278333e8cdee9442da7f135e8">rd_kafka_conf_set</a> (rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a configuration property.  <a href="#abb1b319278333e8cdee9442da7f135e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe702657b91a99f537f4d772ca9bd839"></a><!-- doxytag: member="rdkafka.h::rd_kafka_conf_set_events" ref="abe702657b91a99f537f4d772ca9bd839" args="(rd_kafka_conf_t *conf, int events)" -->
RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#abe702657b91a99f537f4d772ca9bd839">rd_kafka_conf_set_events</a> (rd_kafka_conf_t *conf, int events)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable event sourcing. <code>events</code> is a bitmask of <code>RD_KAFKA_EVENT_*</code> of events to enable for consumption by `rd_kafka_queue_poll()`. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a075b15c4141784fdc271de217005a41f">rd_kafka_conf_set_dr_cb</a> (rd_kafka_conf_t *conf, void(*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> err, void *opaque, void *msg_opaque))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ac1c9946aee26e10de2661fcf2242ea8a">rd_kafka_conf_set_dr_msg_cb</a> (rd_kafka_conf_t *conf, void(*dr_msg_cb)(rd_kafka_t *rk, const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, void *opaque))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Producer:</b> Set delivery report callback in provided <code>conf</code> object.  <a href="#ac1c9946aee26e10de2661fcf2242ea8a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65eaf45e9b26bcb085f4651634ce06a5"></a><!-- doxytag: member="rdkafka.h::rd_kafka_conf_set_consume_cb" ref="a65eaf45e9b26bcb085f4651634ce06a5" args="(rd_kafka_conf_t *conf, void(*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque))" -->
RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a65eaf45e9b26bcb085f4651634ce06a5">rd_kafka_conf_set_consume_cb</a> (rd_kafka_conf_t *conf, void(*consume_cb)(<a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, void *opaque))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Consumer:</b> Set consume callback for use with <a class="el" href="rdkafka_8h.html#a65cc6cb9bd72c4084f074af0361ceddf" title="Poll the consumer for messages or events.">rd_kafka_consumer_poll()</a> <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a10db731dc1a295bd9884e4f8cb199311">rd_kafka_conf_set_rebalance_cb</a> (rd_kafka_conf_t *conf, void(*rebalance_cb)(rd_kafka_t *rk, <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> err, <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *partitions, void *opaque))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Consumer:</b> Set rebalance callback for use with coordinated consumer group balancing.  <a href="#a10db731dc1a295bd9884e4f8cb199311"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a1ab8bb9e8d8cdd5906f9e060b506f2eb">rd_kafka_conf_set_offset_commit_cb</a> (rd_kafka_conf_t *conf, void(*offset_commit_cb)(rd_kafka_t *rk, <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> err, <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *offsets, void *opaque))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>Consumer:</b> Set offset commit callback for use with consumer groups.  <a href="#a1ab8bb9e8d8cdd5906f9e060b506f2eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ace721ef3b7c22d0c111ec747ef039a90">rd_kafka_conf_set_error_cb</a> (rd_kafka_conf_t *conf, void(*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set error callback in provided conf object.  <a href="#ace721ef3b7c22d0c111ec747ef039a90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a04160826ad039d42c10edec456163fa7">rd_kafka_conf_set_throttle_cb</a> (rd_kafka_conf_t *conf, void(*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set throttle callback.  <a href="#a04160826ad039d42c10edec456163fa7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a06ade2ca41f32eb82c6f7e3d4acbe19f">rd_kafka_conf_set_log_cb</a> (rd_kafka_conf_t *conf, void(*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set logger callback.  <a href="#a06ade2ca41f32eb82c6f7e3d4acbe19f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a597d00432e3ca22174d18e7e348fb766">rd_kafka_conf_set_stats_cb</a> (rd_kafka_conf_t *conf, int(*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set statistics callback in provided conf object.  <a href="#a597d00432e3ca22174d18e7e348fb766"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a0467a6c20d5af69a29a63b530962ecbf">rd_kafka_conf_set_socket_cb</a> (rd_kafka_conf_t *conf, int(*socket_cb)(int domain, int type, int protocol, void *opaque))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set socket callback.  <a href="#a0467a6c20d5af69a29a63b530962ecbf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a53dd1b77019324170d0168617fdaf040">rd_kafka_conf_set_connect_cb</a> (rd_kafka_conf_t *conf, int(*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set connect callback.  <a href="#a53dd1b77019324170d0168617fdaf040"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ab55c7ddc46a354e3f57b5b209e5ec3c7">rd_kafka_conf_set_closesocket_cb</a> (rd_kafka_conf_t *conf, int(*closesocket_cb)(int sockfd, void *opaque))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set close socket callback.  <a href="#ab55c7ddc46a354e3f57b5b209e5ec3c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a467bb7b1ac070fee536227d6ae9cc551">rd_kafka_conf_set_open_cb</a> (rd_kafka_conf_t *conf, int(*open_cb)(const char *pathname, int flags, mode_t mode, void *opaque))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set open callback.  <a href="#a467bb7b1ac070fee536227d6ae9cc551"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07cb7d91d9b7458a95ca6f1292763c24"></a><!-- doxytag: member="rdkafka.h::rd_kafka_conf_set_opaque" ref="a07cb7d91d9b7458a95ca6f1292763c24" args="(rd_kafka_conf_t *conf, void *opaque)" -->
RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a07cb7d91d9b7458a95ca6f1292763c24">rd_kafka_conf_set_opaque</a> (rd_kafka_conf_t *conf, void *opaque)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the application's opaque pointer that will be passed to callbacks. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af006d797a3db9c80d9bc08b2d4af93da"></a><!-- doxytag: member="rdkafka.h::rd_kafka_opaque" ref="af006d797a3db9c80d9bc08b2d4af93da" args="(const rd_kafka_t *rk)" -->
RD_EXPORT void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#af006d797a3db9c80d9bc08b2d4af93da">rd_kafka_opaque</a> (const rd_kafka_t *rk)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the opaque pointer previously set with <a class="el" href="rdkafka_8h.html#a07cb7d91d9b7458a95ca6f1292763c24" title="Sets the application&#39;s opaque pointer that will be passed to callbacks.">rd_kafka_conf_set_opaque()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a138aa4881c8703dd6b69f22ddc454f63">rd_kafka_conf_set_default_topic_conf</a> (rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#abe9f0f77e9145eb1a62c3258ac495b97">rd_kafka_conf_get</a> (const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve configuration value for property <code>name</code>.  <a href="#abe9f0f77e9145eb1a62c3258ac495b97"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a56939e7f77106b9e810d59289443e25d">rd_kafka_topic_conf_get</a> (const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve topic configuration value for property <code>name</code>.  <a href="#a56939e7f77106b9e810d59289443e25d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT const char **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a6eba851c2af748de6921d708b47dc94c">rd_kafka_conf_dump</a> (rd_kafka_conf_t *conf, size_t *cntp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dump the configuration properties and values of <code>conf</code> to an array with \"key\", \"value\" pairs.  <a href="#a6eba851c2af748de6921d708b47dc94c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT const char **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a40a7a88bd5ac81b21c45d1fdd4d9e696">rd_kafka_topic_conf_dump</a> (rd_kafka_topic_conf_t *conf, size_t *cntp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dump the topic configuration properties and values of <code>conf</code> to an array with \"key\", \"value\" pairs.  <a href="#a40a7a88bd5ac81b21c45d1fdd4d9e696"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fee1254096acd17cbd61cfe70d827e5"></a><!-- doxytag: member="rdkafka.h::rd_kafka_conf_dump_free" ref="a8fee1254096acd17cbd61cfe70d827e5" args="(const char **arr, size_t cnt)" -->
RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a8fee1254096acd17cbd61cfe70d827e5">rd_kafka_conf_dump_free</a> (const char **arr, size_t cnt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees a configuration dump returned from `rd_kafka_conf_dump()` or `rd_kafka_topic_conf_dump(). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa52f3a5a08207e14386739fe336e57be"></a><!-- doxytag: member="rdkafka.h::rd_kafka_conf_properties_show" ref="aa52f3a5a08207e14386739fe336e57be" args="(FILE *fp)" -->
RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aa52f3a5a08207e14386739fe336e57be">rd_kafka_conf_properties_show</a> (FILE *fp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints a table to <code>fp</code> of all supported configuration properties, their default values as well as a description. <br/></td></tr>
<tr><td colspan="2"><h2>Message headers</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpf086fe31d049507e8e9ccf2adb6b3963"></a>Message headers consist of a list of (string key, binary value) pairs. Duplicate keys are supported and the order in which keys were added are retained.</p>
<p>Header values are considered binary and may have three types of value:</p>
<ul>
<li>proper value with size &gt; 0 and a valid pointer</li>
<li>empty value with size = 0 and any non-NULL pointer</li>
<li>null value with size = 0 and a NULL pointer</li>
</ul>
<p>Headers require Apache Kafka broker version v0.11.0.0 or later.</p>
<p>Header operations are O(n). </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acaaff0aef7ee81e46ee7829412691ad7"></a><!-- doxytag: member="rdkafka.h::rd_kafka_headers_t" ref="acaaff0aef7ee81e46ee7829412691ad7" args="" -->
typedef struct rd_kafka_headers_s&nbsp;</td><td class="memItemRight" valign="bottom"><b>rd_kafka_headers_t</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT rd_kafka_headers_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a9fdd55ee90816f38324f5d0af1b4fc1f">rd_kafka_headers_new</a> (size_t initial_count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new headers list.  <a href="#a9fdd55ee90816f38324f5d0af1b4fc1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa31d7a8707a729839e54422ca976d8b1"></a><!-- doxytag: member="rdkafka.h::rd_kafka_headers_destroy" ref="aa31d7a8707a729839e54422ca976d8b1" args="(rd_kafka_headers_t *hdrs)" -->
RD_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aa31d7a8707a729839e54422ca976d8b1">rd_kafka_headers_destroy</a> (rd_kafka_headers_t *hdrs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy the headers list. The object and any returned value pointers are not usable after this call. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fcc78a52cc4c2279d8eaf42e63e353f"></a><!-- doxytag: member="rdkafka.h::rd_kafka_headers_copy" ref="a5fcc78a52cc4c2279d8eaf42e63e353f" args="(const rd_kafka_headers_t *src)" -->
RD_EXPORT rd_kafka_headers_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a5fcc78a52cc4c2279d8eaf42e63e353f">rd_kafka_headers_copy</a> (const rd_kafka_headers_t *src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a copy of headers list <code>src</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#ad86e25f9787e647588fc2067705de10e">rd_kafka_header_add</a> (rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add header with name <code>name</code> and value <code>val</code> (copied) of size <code>size</code> (not including null-terminator).  <a href="#ad86e25f9787e647588fc2067705de10e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a8a8d23d274cf233b6b4b0a345c0180c1">rd_kafka_header_remove</a> (rd_kafka_headers_t *hdrs, const char *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove all headers for the given key (if any).  <a href="#a8a8d23d274cf233b6b4b0a345c0180c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a6cb8628d390cd89a6d9daada8c70161a">rd_kafka_header_get_last</a> (const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find last header in list <code>hdrs</code> matching <code>name</code>.  <a href="#a6cb8628d390cd89a6d9daada8c70161a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a5cf2d5ce4869203aaa9e18ad2c763bbf">rd_kafka_header_get</a> (const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator for headers matching <code>name</code>.  <a href="#a5cf2d5ce4869203aaa9e18ad2c763bbf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a3a39136e1d13591f668158c0fa20961b">rd_kafka_header_get_all</a> (const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator for all headers.  <a href="#a3a39136e1d13591f668158c0fa20961b"></a><br/></td></tr>
<tr><td colspan="2"><h2>Interceptors</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp27990813574a6790e99690ca6c9443e6"></a>A callback interface that allows message interception for both producer and consumer data pipelines.</p>
<p>Except for the on_new(), on_conf_set(), on_conf_dup() and on_conf_destroy() interceptors, interceptors are added to the newly created rd_kafka_t client instance. These interceptors MUST only be added from on_new() and MUST NOT be added after <a class="el" href="rdkafka_8h.html#a63d5cd86ab1f77772b2be170e1c09c24" title="Creates a new Kafka handle and starts its operation according to the specified type...">rd_kafka_new()</a> returns.</p>
<p>The on_new(), on_conf_set(), on_conf_dup() and on_conf_destroy() interceptors are added to the configuration object which is later passed to <a class="el" href="rdkafka_8h.html#a63d5cd86ab1f77772b2be170e1c09c24" title="Creates a new Kafka handle and starts its operation according to the specified type...">rd_kafka_new()</a> where on_new() is called to allow addition of other interceptors.</p>
<p>Each interceptor reference consists of a display name (ic_name), a callback function, and an application-specified opaque value that is passed as-is to the callback. The ic_name must be unique for the interceptor implementation and is used to reject duplicate interceptor methods.</p>
<p>Any number of interceptors can be added and they are called in the order they were added, unless otherwise noted. The list of registered interceptor methods are referred to as interceptor chains.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Contrary to the Java client the librdkafka interceptor interface does not support message key and value modification. Message mutability is discouraged in the Java client and the combination of serializers and headers cover most use-cases.</dd>
<dd>
Interceptors are NOT copied to the new configuration on <a class="el" href="rdkafka_8h.html#a8cbfe15c6978ff09870e82cb524c673d" title="Creates a copy/duplicate of configuration object conf.">rd_kafka_conf_dup()</a> since it would be hard for interceptors to track usage of the interceptor's opaque value. An interceptor should rely on the plugin, which will be copied in rd_kafka_conf_conf_dup(), to set up the initial interceptors. An interceptor should implement the on_conf_dup() method to manually set up its internal configuration on the newly created configuration object that is being copied-to based on the interceptor-specific configuration properties. conf_dup() should thus be treated the same as conf_init().</dd>
<dd>
Interceptors are keyed by the interceptor type (on_..()), the interceptor name (ic_name) and the interceptor method function. Duplicates are not allowed and the .._add_on_..() method will return RD_KAFKA_RESP_ERR__CONFLICT if attempting to add a duplicate method. The only exception is on_conf_destroy() which may be added multiple times by the same interceptor to allow proper cleanup of interceptor configuration state. </dd></dl>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a>(&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#adb146aa9dbc3a5d4bb4a5b53c1b86b0d">rd_kafka_interceptor_f_on_conf_set_t</a> )(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">on_conf_set() is called from rd_kafka_*_conf_set() in the order the interceptors were added.  <a href="#adb146aa9dbc3a5d4bb4a5b53c1b86b0d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>(&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a4339f06d7d4d02d06fbc401d279daeb2">rd_kafka_interceptor_f_on_conf_dup_t</a> )(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">on_conf_dup() is called from <a class="el" href="rdkafka_8h.html#a8cbfe15c6978ff09870e82cb524c673d" title="Creates a copy/duplicate of configuration object conf.">rd_kafka_conf_dup()</a> in the order the interceptors were added and is used to let an interceptor re-register its conf interecptors with a new opaque value. The on_conf_dup() method is called prior to the configuration from <code>old_conf</code> being copied to <code>new_conf</code>.  <a href="#a4339f06d7d4d02d06fbc401d279daeb2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>(&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a39c5416d05a8262ae0a2937853c99257">rd_kafka_interceptor_f_on_conf_destroy_t</a> )(void *ic_opaque)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">on_conf_destroy() is called from rd_kafka_*_conf_destroy() in the order the interceptors were added.  <a href="#a39c5416d05a8262ae0a2937853c99257"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>(&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a045854635d67e89de3098a0d5f53cc39">rd_kafka_interceptor_f_on_new_t</a> )(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">on_new() is called from <a class="el" href="rdkafka_8h.html#a63d5cd86ab1f77772b2be170e1c09c24" title="Creates a new Kafka handle and starts its operation according to the specified type...">rd_kafka_new()</a> prior toreturning the newly created client instance to the application.  <a href="#a045854635d67e89de3098a0d5f53cc39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>(&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a3eae9c1d37ab4effd55bb8ed5177ac4d">rd_kafka_interceptor_f_on_destroy_t</a> )(rd_kafka_t *rk, void *ic_opaque)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">on_destroy() is called from <a class="el" href="rdkafka_8h.html#ac052e92621dcaa3a336dbf826e0d7794" title="Destroy Kafka handle.">rd_kafka_destroy()</a> or (<a class="el" href="rdkafka_8h.html#a63d5cd86ab1f77772b2be170e1c09c24" title="Creates a new Kafka handle and starts its operation according to the specified type...">rd_kafka_new()</a> if <a class="el" href="rdkafka_8h.html#a63d5cd86ab1f77772b2be170e1c09c24" title="Creates a new Kafka handle and starts its operation according to the specified type...">rd_kafka_new()</a> fails during initialization).  <a href="#a3eae9c1d37ab4effd55bb8ed5177ac4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>(&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a4b71a63f37c4d94cdb1d05e88f120988">rd_kafka_interceptor_f_on_send_t</a> )(rd_kafka_t *rk, <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, void *ic_opaque)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">on_send() is called from rd_kafka_produce*() (et.al) prior to the partitioner being called.  <a href="#a4b71a63f37c4d94cdb1d05e88f120988"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>(&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aca93ab41df25cab562b9a4cf6c0e7320">rd_kafka_interceptor_f_on_acknowledgement_t</a> )(rd_kafka_t *rk, <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, void *ic_opaque)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">on_acknowledgement() is called to inform interceptors that a message was succesfully delivered or permanently failed delivery. The interceptor chain is called from internal librdkafka background threads, or rd_kafka_produce*() if the partitioner failed.  <a href="#aca93ab41df25cab562b9a4cf6c0e7320"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>(&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#aeafe5c26d64281c1f9a2e2f77f774fa4">rd_kafka_interceptor_f_on_consume_t</a> )(rd_kafka_t *rk, <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, void *ic_opaque)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">on_consume() is called just prior to passing the message to the application in <a class="el" href="rdkafka_8h.html#a65cc6cb9bd72c4084f074af0361ceddf" title="Poll the consumer for messages or events.">rd_kafka_consumer_poll()</a>, rd_kafka_consume*(), the event interface, etc.  <a href="#aeafe5c26d64281c1f9a2e2f77f774fa4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>(&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a4ce7c3dfd327ce6512245302be4fe067">rd_kafka_interceptor_f_on_commit_t</a> )(rd_kafka_t *rk, const <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *offsets, <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> err, void *ic_opaque)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">on_commit() is called on completed or failed offset commit. It is called from internal librdkafka threads.  <a href="#a4ce7c3dfd327ce6512245302be4fe067"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>(&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#afae0abf1b1a5a85da0e3e22c78e3c5bf">rd_kafka_interceptor_f_on_request_sent_t</a> )(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">on_request_sent() is called when a request has been fully written to a broker TCP connections socket.  <a href="#afae0abf1b1a5a85da0e3e22c78e3c5bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a97bdeb12b99da10eff18767b3cadbfd2">rd_kafka_conf_interceptor_add_on_conf_set</a> (rd_kafka_conf_t *conf, const char *ic_name, <a class="el" href="rdkafka_8h.html#adb146aa9dbc3a5d4bb4a5b53c1b86b0d">rd_kafka_interceptor_f_on_conf_set_t</a> *on_conf_set, void *ic_opaque)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append an on_conf_set() interceptor.  <a href="#a97bdeb12b99da10eff18767b3cadbfd2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a375ce703f6247377305dc6a5dfc84429">rd_kafka_conf_interceptor_add_on_conf_dup</a> (rd_kafka_conf_t *conf, const char *ic_name, <a class="el" href="rdkafka_8h.html#a4339f06d7d4d02d06fbc401d279daeb2">rd_kafka_interceptor_f_on_conf_dup_t</a> *on_conf_dup, void *ic_opaque)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append an on_conf_dup() interceptor.  <a href="#a375ce703f6247377305dc6a5dfc84429"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a919ebd487a2717d6cbdf0d25102ea8ff">rd_kafka_conf_interceptor_add_on_conf_destroy</a> (rd_kafka_conf_t *conf, const char *ic_name, <a class="el" href="rdkafka_8h.html#a39c5416d05a8262ae0a2937853c99257">rd_kafka_interceptor_f_on_conf_destroy_t</a> *on_conf_destroy, void *ic_opaque)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append an on_conf_destroy() interceptor.  <a href="#a919ebd487a2717d6cbdf0d25102ea8ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a002ef1d350176725b6e9ba93548edf40">rd_kafka_conf_interceptor_add_on_new</a> (rd_kafka_conf_t *conf, const char *ic_name, <a class="el" href="rdkafka_8h.html#a045854635d67e89de3098a0d5f53cc39">rd_kafka_interceptor_f_on_new_t</a> *on_new, void *ic_opaque)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append an on_new() interceptor.  <a href="#a002ef1d350176725b6e9ba93548edf40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a11b835cb99dc1cfa03c52465b9837a47">rd_kafka_interceptor_add_on_destroy</a> (rd_kafka_t *rk, const char *ic_name, <a class="el" href="rdkafka_8h.html#a3eae9c1d37ab4effd55bb8ed5177ac4d">rd_kafka_interceptor_f_on_destroy_t</a> *on_destroy, void *ic_opaque)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append an on_destroy() interceptor.  <a href="#a11b835cb99dc1cfa03c52465b9837a47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#af6fb1b8884444c63b6930a7bd6122cb6">rd_kafka_interceptor_add_on_send</a> (rd_kafka_t *rk, const char *ic_name, <a class="el" href="rdkafka_8h.html#a4b71a63f37c4d94cdb1d05e88f120988">rd_kafka_interceptor_f_on_send_t</a> *on_send, void *ic_opaque)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append an on_send() interceptor.  <a href="#af6fb1b8884444c63b6930a7bd6122cb6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#abaf475ab47fff47ab796be1cecbbd370">rd_kafka_interceptor_add_on_acknowledgement</a> (rd_kafka_t *rk, const char *ic_name, <a class="el" href="rdkafka_8h.html#aca93ab41df25cab562b9a4cf6c0e7320">rd_kafka_interceptor_f_on_acknowledgement_t</a> *on_acknowledgement, void *ic_opaque)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append an on_acknowledgement() interceptor.  <a href="#abaf475ab47fff47ab796be1cecbbd370"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a0e722a9930897bba81b33de5fe95b6ed">rd_kafka_interceptor_add_on_consume</a> (rd_kafka_t *rk, const char *ic_name, <a class="el" href="rdkafka_8h.html#aeafe5c26d64281c1f9a2e2f77f774fa4">rd_kafka_interceptor_f_on_consume_t</a> *on_consume, void *ic_opaque)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append an on_consume() interceptor.  <a href="#a0e722a9930897bba81b33de5fe95b6ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a0d3e29337dbf11762b5a7e492b77b781">rd_kafka_interceptor_add_on_commit</a> (rd_kafka_t *rk, const char *ic_name, <a class="el" href="rdkafka_8h.html#a4ce7c3dfd327ce6512245302be4fe067">rd_kafka_interceptor_f_on_commit_t</a> *on_commit, void *ic_opaque)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append an on_commit() interceptor.  <a href="#a0d3e29337dbf11762b5a7e492b77b781"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rdkafka_8h.html#a444032455f98839bef2fb76d15f663c3">rd_kafka_interceptor_add_on_request_sent</a> (rd_kafka_t *rk, const char *ic_name, <a class="el" href="rdkafka_8h.html#afae0abf1b1a5a85da0e3e22c78e3c5bf">rd_kafka_interceptor_f_on_request_sent_t</a> *on_request_sent, void *ic_opaque)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append an on_request_sent() interceptor.  <a href="#a444032455f98839bef2fb76d15f663c3"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Apache Kafka C/C++ consumer and producer client library. </p>
<p><a class="el" href="rdkafka_8h.html" title="Apache Kafka C/C++ consumer and producer client library.">rdkafka.h</a> contains the public API for librdkafka. The API is documented in this file as comments prefixing the function, type, enum, define, etc.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>For the C++ interface see <a class="el" href="rdkafkacpp_8h.html" title="Apache Kafka C/C++ consumer and producer client library.">rdkafkacpp.h</a></dd></dl>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="aa2e242fb8620a32b650a40575bc7f98e"></a><!-- doxytag: member="rdkafka.h::RD_KAFKA_VERSION" ref="aa2e242fb8620a32b650a40575bc7f98e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_VERSION&nbsp;&nbsp;&nbsp;0x000b04c9</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>librdkafka version </p>
<p>Interpreted as hex <code>MM.mm.rr.xx</code>:</p>
<ul>
<li>MM = Major</li>
<li>mm = minor</li>
<li>rr = revision</li>
<li>xx = pre-release id (0xff is the final release)</li>
</ul>
<p>E.g.: <code>0x000801ff</code> = 0.8.1</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This value should only be used during compile time, for runtime checks of version use <a class="el" href="rdkafka_8h.html#a83e363606ef2da2e91b7429b229dbc8e" title="Returns the librdkafka version as integer.">rd_kafka_version()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aed25dba90c47adc8ae51d098dca2aed9"></a><!-- doxytag: member="rdkafka.h::RD_KAFKA_DEBUG_CONTEXTS" ref="aed25dba90c47adc8ae51d098dca2aed9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_DEBUG_CONTEXTS&nbsp;&nbsp;&nbsp;&quot;all,generic,broker,topic,metadata,feature,queue,msg,protocol,cgrp,security,fetch,interceptor,plugin,consumer&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Supported debug contexts. (compile time). </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>This compile time value may be outdated at runtime due to linking another version of the library. Use <a class="el" href="rdkafka_8h.html#adece97d3cbdd6ca936df5b0663118c45" title="Retrieve supported debug contexts for use with the \&quot;debug\&quot; configuration...">rd_kafka_get_debug_contexts()</a> instead. </dd></dl>

</div>
</div>
<a class="anchor" id="a03c74ceba678b4e7a624310160a02165"></a><!-- doxytag: member="rdkafka.h::RD_KAFKA_V_END" ref="a03c74ceba678b4e7a624310160a02165" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_V_END&nbsp;&nbsp;&nbsp;RD_KAFKA_VTYPE_END</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience macros for rd_kafka_vtype_t that takes the correct arguments for each vtype. </p>
<p>va-arg end sentinel used to terminate the variable argument list </p>

</div>
</div>
<a class="anchor" id="a6e7b87a5507f79819059f11ded369786"></a><!-- doxytag: member="rdkafka.h::RD_KAFKA_V_TOPIC" ref="a6e7b87a5507f79819059f11ded369786" args="(topic)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_V_TOPIC</td>
          <td>(</td>
          <td class="paramtype">topic&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">_LRK_TYPECHECK(<a class="code" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6ba2963e9a4838eb825ad954757a965fd45">RD_KAFKA_VTYPE_TOPIC</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *, topic),      \
        (<span class="keyword">const</span> <span class="keywordtype">char</span> *)topic
</pre></div><p>Topic name (const char *) </p>

</div>
</div>
<a class="anchor" id="a64fb46a5855c6a2bd0c642fa639bff37"></a><!-- doxytag: member="rdkafka.h::RD_KAFKA_V_RKT" ref="a64fb46a5855c6a2bd0c642fa639bff37" args="(rkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_V_RKT</td>
          <td>(</td>
          <td class="paramtype">rkt&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">_LRK_TYPECHECK(<a class="code" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6ba37f0b8d0b3add4ad93bdf7ef6863abd9">RD_KAFKA_VTYPE_RKT</a>, rd_kafka_topic_t *, rkt),    \
        (rd_kafka_topic_t *)rkt
</pre></div><p>Topic object (rd_kafka_topic_t *) </p>

</div>
</div>
<a class="anchor" id="ab8ee15fd5d9f441f5b0bba62815ea2f3"></a><!-- doxytag: member="rdkafka.h::RD_KAFKA_V_PARTITION" ref="ab8ee15fd5d9f441f5b0bba62815ea2f3" args="(partition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_V_PARTITION</td>
          <td>(</td>
          <td class="paramtype">partition&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">_LRK_TYPECHECK(<a class="code" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6ba2374c0d8cd0d293aebd40b687db16b12">RD_KAFKA_VTYPE_PARTITION</a>, int32_t, partition),   \
        (int32_t)partition
</pre></div><p>Partition (int32_t) </p>

</div>
</div>
<a class="anchor" id="ae8ec8f37eff67ab3b2321329870d4c08"></a><!-- doxytag: member="rdkafka.h::RD_KAFKA_V_VALUE" ref="ae8ec8f37eff67ab3b2321329870d4c08" args="(VALUE, LEN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_V_VALUE</td>
          <td>(</td>
          <td class="paramtype">VALUE, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LEN&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">_LRK_TYPECHECK2(<a class="code" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6baa5c06c93cea11334ee6fd41379dd849d">RD_KAFKA_VTYPE_VALUE</a>, <span class="keywordtype">void</span> *, VALUE, <span class="keywordtype">size_t</span>, LEN), \
        (<span class="keywordtype">void</span> *)VALUE, (<span class="keywordtype">size_t</span>)LEN
</pre></div><p>Message value/payload pointer and length (void *, size_t) </p>

</div>
</div>
<a class="anchor" id="aac7c275dc2b977f4aa761962a4008144"></a><!-- doxytag: member="rdkafka.h::RD_KAFKA_V_KEY" ref="aac7c275dc2b977f4aa761962a4008144" args="(KEY, LEN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_V_KEY</td>
          <td>(</td>
          <td class="paramtype">KEY, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LEN&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">_LRK_TYPECHECK2(<a class="code" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6ba83433ee19c9f47e5f561649ab7768cdf">RD_KAFKA_VTYPE_KEY</a>, <span class="keyword">const</span> <span class="keywordtype">void</span> *, KEY, <span class="keywordtype">size_t</span>, LEN), \
        (<span class="keywordtype">void</span> *)KEY, (<span class="keywordtype">size_t</span>)LEN
</pre></div><p>Message key pointer and length (const void *, size_t) </p>

</div>
</div>
<a class="anchor" id="a3b18233761cb0f59215b49108e41ee9b"></a><!-- doxytag: member="rdkafka.h::RD_KAFKA_V_OPAQUE" ref="a3b18233761cb0f59215b49108e41ee9b" args="(opaque)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_V_OPAQUE</td>
          <td>(</td>
          <td class="paramtype">opaque&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">_LRK_TYPECHECK(<a class="code" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6baa3db5c202df5e978f003cd1c0f1fec29">RD_KAFKA_VTYPE_OPAQUE</a>, <span class="keywordtype">void</span> *, opaque),    \
        (<span class="keywordtype">void</span> *)opaque
</pre></div><p>Message opaque pointer (void *) Same as <code>produce</code>(.., msg_opaque), and <code>rkmessage-&gt;_private</code> . </p>

</div>
</div>
<a class="anchor" id="a10d50abbc375a50ed9ec26972cf72bb0"></a><!-- doxytag: member="rdkafka.h::RD_KAFKA_V_MSGFLAGS" ref="a10d50abbc375a50ed9ec26972cf72bb0" args="(msgflags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_V_MSGFLAGS</td>
          <td>(</td>
          <td class="paramtype">msgflags&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">_LRK_TYPECHECK(<a class="code" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6ba2f55d9d2b0729843f99c758155e948da">RD_KAFKA_VTYPE_MSGFLAGS</a>, <span class="keywordtype">int</span>, msgflags),       \
        (int)msgflags
</pre></div><p>Message flags (int) </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rdkafka_8h.html#ad7468ab0ece73cc9cb6253a3dcfe702d">RD_KAFKA_MSG_F_COPY</a>, et.al. </dd></dl>

</div>
</div>
<a class="anchor" id="afc05e7e3d017c9a07da61c3edb69f61b"></a><!-- doxytag: member="rdkafka.h::RD_KAFKA_V_TIMESTAMP" ref="afc05e7e3d017c9a07da61c3edb69f61b" args="(timestamp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_V_TIMESTAMP</td>
          <td>(</td>
          <td class="paramtype">timestamp&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">_LRK_TYPECHECK(<a class="code" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6baf2f1861778d90a40cf0c498985fbc768">RD_KAFKA_VTYPE_TIMESTAMP</a>, int64_t, timestamp),   \
        (int64_t)timestamp
</pre></div><p>Timestamp (int64_t) </p>

</div>
</div>
<a class="anchor" id="a2a6b8f2572433964f73f23cf9c13a619"></a><!-- doxytag: member="rdkafka.h::RD_KAFKA_V_HEADER" ref="a2a6b8f2572433964f73f23cf9c13a619" args="(NAME, VALUE, LEN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_V_HEADER</td>
          <td>(</td>
          <td class="paramtype">NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VALUE, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LEN&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">_LRK_TYPECHECK3(<a class="code" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6ba5ee53e13817abfea4e94590892cb57f8">RD_KAFKA_VTYPE_HEADER</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *, NAME,      \
                        <span class="keyword">const</span> <span class="keywordtype">void</span> *, VALUE, ssize_t, LEN),             \
                (<span class="keyword">const</span> <span class="keywordtype">char</span> *)NAME, (<span class="keyword">const</span> <span class="keywordtype">void</span> *)VALUE, (ssize_t)LEN
</pre></div><p>Add Message Header (const char *NAME, const void *VALUE, ssize_t LEN). </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rdkafka_8h.html#ad86e25f9787e647588fc2067705de10e" title="Add header with name name and value val (copied) of size size (not including null-terminator)...">rd_kafka_header_add()</a> </dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><a class="el" href="rdkafka_8h.html#a2a6b8f2572433964f73f23cf9c13a619">RD_KAFKA_V_HEADER()</a> and <a class="el" href="rdkafka_8h.html#a6d4dd1a47c26763fb24e2c422672aa9d">RD_KAFKA_V_HEADERS()</a> MUST NOT be mixed in the same call to producev(). </dd></dl>

</div>
</div>
<a class="anchor" id="a6d4dd1a47c26763fb24e2c422672aa9d"></a><!-- doxytag: member="rdkafka.h::RD_KAFKA_V_HEADERS" ref="a6d4dd1a47c26763fb24e2c422672aa9d" args="(HDRS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_V_HEADERS</td>
          <td>(</td>
          <td class="paramtype">HDRS&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">_LRK_TYPECHECK(<a class="code" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6ba26701ae2fe9028f50386a2417ace24a9">RD_KAFKA_VTYPE_HEADERS</a>, rd_kafka_headers_t *, HDRS), \
                (rd_kafka_headers_t *)HDRS
</pre></div><p>Message Headers list (rd_kafka_headers_t *). The message object will assume ownership of the headers (unless producev() fails). Any existing headers will be replaced. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rdkafka_8h.html#a99e46233e57fc4f5783d8ae374584bbe" title="Replace the message&#39;s current headers with a new list.">rd_kafka_message_set_headers()</a> </dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><a class="el" href="rdkafka_8h.html#a2a6b8f2572433964f73f23cf9c13a619">RD_KAFKA_V_HEADER()</a> and <a class="el" href="rdkafka_8h.html#a6d4dd1a47c26763fb24e2c422672aa9d">RD_KAFKA_V_HEADERS()</a> MUST NOT be mixed in the same call to producev(). </dd></dl>

</div>
</div>
<a class="anchor" id="a3002d1858385de283ea004893e352863"></a><!-- doxytag: member="rdkafka.h::RD_KAFKA_PARTITION_UA" ref="a3002d1858385de283ea004893e352863" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_PARTITION_UA&nbsp;&nbsp;&nbsp;((int32_t)-1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unassigned partition. </p>
<p>The unassigned partition is used by the producer API for messages that should be partitioned using the configured or default partitioner. </p>

</div>
</div>
<a class="anchor" id="a32dc6dd93c16e3aac9b89804c4817fba"></a><!-- doxytag: member="rdkafka.h::RD_KAFKA_OFFSET_BEGINNING" ref="a32dc6dd93c16e3aac9b89804c4817fba" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_OFFSET_BEGINNING&nbsp;&nbsp;&nbsp;-2</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Start consuming from beginning of kafka partition queue: oldest msg </p>

</div>
</div>
<a class="anchor" id="aa7aaaf16e5bd7c0a8a8cb014275c3e06"></a><!-- doxytag: member="rdkafka.h::RD_KAFKA_OFFSET_END" ref="aa7aaaf16e5bd7c0a8a8cb014275c3e06" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_OFFSET_END&nbsp;&nbsp;&nbsp;-1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Start consuming from end of kafka partition queue: next msg </p>

</div>
</div>
<a class="anchor" id="a727dc7080140da43adbd5d0b170d49be"></a><!-- doxytag: member="rdkafka.h::RD_KAFKA_OFFSET_STORED" ref="a727dc7080140da43adbd5d0b170d49be" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_OFFSET_STORED&nbsp;&nbsp;&nbsp;-1000</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Start consuming from offset retrieved from offset store </p>

</div>
</div>
<a class="anchor" id="ac2e48c4fef9e959ab43cad60ade84af1"></a><!-- doxytag: member="rdkafka.h::RD_KAFKA_OFFSET_INVALID" ref="ac2e48c4fef9e959ab43cad60ade84af1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_OFFSET_INVALID&nbsp;&nbsp;&nbsp;-1001</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invalid offset </p>

</div>
</div>
<a class="anchor" id="ae26a2522ce2d8ef8ce6c0235e8cfd409"></a><!-- doxytag: member="rdkafka.h::RD_KAFKA_OFFSET_TAIL" ref="ae26a2522ce2d8ef8ce6c0235e8cfd409" args="(CNT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_OFFSET_TAIL</td>
          <td>(</td>
          <td class="paramtype">CNT&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(RD_KAFKA_OFFSET_TAIL_BASE - (CNT))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start consuming <code>CNT</code> messages from topic's current end offset. </p>
<p>That is, if current end offset is 12345 and <code>CNT</code> is 200, it will start consuming from offset <code>12345-200</code> = <code>12145</code>. </p>

</div>
</div>
<a class="anchor" id="a21be13f8a4cb1d5aff01419f333e5ea7"></a><!-- doxytag: member="rdkafka.h::RD_KAFKA_MSG_F_FREE" ref="a21be13f8a4cb1d5aff01419f333e5ea7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_MSG_F_FREE&nbsp;&nbsp;&nbsp;0x1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Producer message flags. </p>
<p>Delegate freeing of payload to rdkafka. </p>

</div>
</div>
<a class="anchor" id="ad7468ab0ece73cc9cb6253a3dcfe702d"></a><!-- doxytag: member="rdkafka.h::RD_KAFKA_MSG_F_COPY" ref="ad7468ab0ece73cc9cb6253a3dcfe702d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_MSG_F_COPY&nbsp;&nbsp;&nbsp;0x2</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>rdkafka will make a copy of the payload. </p>

</div>
</div>
<a class="anchor" id="aca3cdf1c55668f4aa1c2391ddd39c9c2"></a><!-- doxytag: member="rdkafka.h::RD_KAFKA_MSG_F_BLOCK" ref="aca3cdf1c55668f4aa1c2391ddd39c9c2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_MSG_F_BLOCK&nbsp;&nbsp;&nbsp;0x4</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Block produce*() on message queue full. WARNING: If a delivery report callback is used the application MUST call <a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4" title="Polls the provided kafka handle for events.">rd_kafka_poll()</a> (or equiv.) to make sure delivered messages are drained from the internal delivery report queue. Failure to do so will result in indefinately blocking on the produce() call when the message queue is full. </p>

</div>
</div>
<a class="anchor" id="a991bd9378d2fc5b2102ce3a29805b345"></a><!-- doxytag: member="rdkafka.h::RD_KAFKA_MSG_F_PARTITION" ref="a991bd9378d2fc5b2102ce3a29805b345" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_MSG_F_PARTITION&nbsp;&nbsp;&nbsp;0x8</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>produce_batch() will honor per-message partition. </p>

</div>
</div>
<a class="anchor" id="abfe880d05ff52138b26dbe8b8e0d2132"></a><!-- doxytag: member="rdkafka.h::RD_KAFKA_EVENT_DR" ref="abfe880d05ff52138b26dbe8b8e0d2132" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_EVENT_DR&nbsp;&nbsp;&nbsp;0x1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Producer Delivery report batch </p>

</div>
</div>
<a class="anchor" id="acfddfd9f3d49591dcd9e7f323dbcd865"></a><!-- doxytag: member="rdkafka.h::RD_KAFKA_EVENT_FETCH" ref="acfddfd9f3d49591dcd9e7f323dbcd865" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_EVENT_FETCH&nbsp;&nbsp;&nbsp;0x2</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetched message (consumer) </p>

</div>
</div>
<a class="anchor" id="a6265a9eeee57e83eb9f3bbd33d92700f"></a><!-- doxytag: member="rdkafka.h::RD_KAFKA_EVENT_LOG" ref="a6265a9eeee57e83eb9f3bbd33d92700f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_EVENT_LOG&nbsp;&nbsp;&nbsp;0x4</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Log message </p>

</div>
</div>
<a class="anchor" id="a080a7ad60de643f47424031ee95da103"></a><!-- doxytag: member="rdkafka.h::RD_KAFKA_EVENT_ERROR" ref="a080a7ad60de643f47424031ee95da103" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_EVENT_ERROR&nbsp;&nbsp;&nbsp;0x8</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Error </p>

</div>
</div>
<a class="anchor" id="a271e6a5984932015585dd5248535aa2b"></a><!-- doxytag: member="rdkafka.h::RD_KAFKA_EVENT_REBALANCE" ref="a271e6a5984932015585dd5248535aa2b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_EVENT_REBALANCE&nbsp;&nbsp;&nbsp;0x10</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Group rebalance (consumer) </p>

</div>
</div>
<a class="anchor" id="a73a29f22b22433a93253a5f77c866437"></a><!-- doxytag: member="rdkafka.h::RD_KAFKA_EVENT_OFFSET_COMMIT" ref="a73a29f22b22433a93253a5f77c866437" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_EVENT_OFFSET_COMMIT&nbsp;&nbsp;&nbsp;0x20</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Offset commit result </p>

</div>
</div>
<a class="anchor" id="a67070a77150f54039273097c57da5965"></a><!-- doxytag: member="rdkafka.h::RD_KAFKA_EVENT_STATS" ref="a67070a77150f54039273097c57da5965" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RD_KAFKA_EVENT_STATS&nbsp;&nbsp;&nbsp;0x40</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stats </p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a15f8730945790c3c5fb366f2970f73b8"></a><!-- doxytag: member="rdkafka.h::rd_kafka_plugin_f_conf_init_t" ref="a15f8730945790c3c5fb366f2970f73b8" args=")(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>( <a class="el" href="rdkafka_8h.html#a15f8730945790c3c5fb366f2970f73b8">rd_kafka_plugin_f_conf_init_t</a>)(rd_kafka_conf_t *conf, void **plug_opaquep, char *errstr, size_t errstr_size)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Plugin's configuration initializer method called each time the library is referenced from configuration (even if previously loaded by another client instance). </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This method MUST be implemented by plugins and have the symbol name <code>conf_init</code> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>conf</em>&nbsp;</td><td>Configuration set up to this point. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>plug_opaquep</em>&nbsp;</td><td>Plugin can set this pointer to a per-configuration opaque pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>errstr</em>&nbsp;</td><td>String buffer of size <code>errstr_size</code> where plugin must write a human readable error string in the case the initializer fails (returns non-zero).</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>A plugin may add an on_conf_destroy() interceptor to clean up plugin-specific resources created in the plugin's conf_init() method.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on error. </dd></dl>

</div>
</div>
<a class="anchor" id="adb146aa9dbc3a5d4bb4a5b53c1b86b0d"></a><!-- doxytag: member="rdkafka.h::rd_kafka_interceptor_f_on_conf_set_t" ref="adb146aa9dbc3a5d4bb4a5b53c1b86b0d" args=")(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a>( <a class="el" href="rdkafka_8h.html#adb146aa9dbc3a5d4bb4a5b53c1b86b0d">rd_kafka_interceptor_f_on_conf_set_t</a>)(rd_kafka_conf_t *conf, const char *name, const char *val, char *errstr, size_t errstr_size, void *ic_opaque)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>on_conf_set() is called from rd_kafka_*_conf_set() in the order the interceptors were added. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ic_opaque</em>&nbsp;</td><td>The interceptor's opaque pointer specified in ..add..(). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The configuration property to set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>The configuration value to set, or NULL for reverting to default in which case the previous value should be freed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>errstr</em>&nbsp;</td><td>A human readable error string in case the interceptor fails. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>errstr_size</em>&nbsp;</td><td>Maximum space (including ) in <code>errstr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RD_KAFKA_CONF_RES_OK if the property was known and successfully handled by the interceptor, RD_KAFKA_CONF_RES_INVALID if the property was handled by the interceptor but the value was invalid, or RD_KAFKA_CONF_RES_UNKNOWN if the interceptor did not handle this property, in which case the property is passed on on the interceptor in the chain, finally ending up at the built-in configuration handler. </dd></dl>

</div>
</div>
<a class="anchor" id="a4339f06d7d4d02d06fbc401d279daeb2"></a><!-- doxytag: member="rdkafka.h::rd_kafka_interceptor_f_on_conf_dup_t" ref="a4339f06d7d4d02d06fbc401d279daeb2" args=")(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>( <a class="el" href="rdkafka_8h.html#a4339f06d7d4d02d06fbc401d279daeb2">rd_kafka_interceptor_f_on_conf_dup_t</a>)(rd_kafka_conf_t *new_conf, const rd_kafka_conf_t *old_conf, size_t filter_cnt, const char **filter, void *ic_opaque)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>on_conf_dup() is called from <a class="el" href="rdkafka_8h.html#a8cbfe15c6978ff09870e82cb524c673d" title="Creates a copy/duplicate of configuration object conf.">rd_kafka_conf_dup()</a> in the order the interceptors were added and is used to let an interceptor re-register its conf interecptors with a new opaque value. The on_conf_dup() method is called prior to the configuration from <code>old_conf</code> being copied to <code>new_conf</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ic_opaque</em>&nbsp;</td><td>The interceptor's opaque pointer specified in ..add..().</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on failure (which is logged but otherwise ignored).</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>No on_conf_* interceptors are copied to the new configuration object on <a class="el" href="rdkafka_8h.html#a8cbfe15c6978ff09870e82cb524c673d" title="Creates a copy/duplicate of configuration object conf.">rd_kafka_conf_dup()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a39c5416d05a8262ae0a2937853c99257"></a><!-- doxytag: member="rdkafka.h::rd_kafka_interceptor_f_on_conf_destroy_t" ref="a39c5416d05a8262ae0a2937853c99257" args=")(void *ic_opaque)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>( <a class="el" href="rdkafka_8h.html#a39c5416d05a8262ae0a2937853c99257">rd_kafka_interceptor_f_on_conf_destroy_t</a>)(void *ic_opaque)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>on_conf_destroy() is called from rd_kafka_*_conf_destroy() in the order the interceptors were added. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ic_opaque</em>&nbsp;</td><td>The interceptor's opaque pointer specified in ..add..(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a045854635d67e89de3098a0d5f53cc39"></a><!-- doxytag: member="rdkafka.h::rd_kafka_interceptor_f_on_new_t" ref="a045854635d67e89de3098a0d5f53cc39" args=")(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>( <a class="el" href="rdkafka_8h.html#a045854635d67e89de3098a0d5f53cc39">rd_kafka_interceptor_f_on_new_t</a>)(rd_kafka_t *rk, const rd_kafka_conf_t *conf, void *ic_opaque, char *errstr, size_t errstr_size)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>on_new() is called from <a class="el" href="rdkafka_8h.html#a63d5cd86ab1f77772b2be170e1c09c24" title="Creates a new Kafka handle and starts its operation according to the specified type...">rd_kafka_new()</a> prior toreturning the newly created client instance to the application. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rk</em>&nbsp;</td><td>The client instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>conf</em>&nbsp;</td><td>The client instance's final configuration. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ic_opaque</em>&nbsp;</td><td>The interceptor's opaque pointer specified in ..add..(). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>errstr</em>&nbsp;</td><td>A human readable error string in case the interceptor fails. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>errstr_size</em>&nbsp;</td><td>Maximum space (including ) in <code>errstr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an error code on failure, the error is logged but otherwise ignored.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The <code>rk</code> client instance will not be fully set up when this interceptor is called and the interceptor MUST NOT call any other rk-specific APIs than rd_kafka_interceptor_add..(). </dd></dl>

</div>
</div>
<a class="anchor" id="a3eae9c1d37ab4effd55bb8ed5177ac4d"></a><!-- doxytag: member="rdkafka.h::rd_kafka_interceptor_f_on_destroy_t" ref="a3eae9c1d37ab4effd55bb8ed5177ac4d" args=")(rd_kafka_t *rk, void *ic_opaque)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>( <a class="el" href="rdkafka_8h.html#a3eae9c1d37ab4effd55bb8ed5177ac4d">rd_kafka_interceptor_f_on_destroy_t</a>)(rd_kafka_t *rk, void *ic_opaque)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>on_destroy() is called from <a class="el" href="rdkafka_8h.html#ac052e92621dcaa3a336dbf826e0d7794" title="Destroy Kafka handle.">rd_kafka_destroy()</a> or (<a class="el" href="rdkafka_8h.html#a63d5cd86ab1f77772b2be170e1c09c24" title="Creates a new Kafka handle and starts its operation according to the specified type...">rd_kafka_new()</a> if <a class="el" href="rdkafka_8h.html#a63d5cd86ab1f77772b2be170e1c09c24" title="Creates a new Kafka handle and starts its operation according to the specified type...">rd_kafka_new()</a> fails during initialization). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rk</em>&nbsp;</td><td>The client instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ic_opaque</em>&nbsp;</td><td>The interceptor's opaque pointer specified in ..add..(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b71a63f37c4d94cdb1d05e88f120988"></a><!-- doxytag: member="rdkafka.h::rd_kafka_interceptor_f_on_send_t" ref="a4b71a63f37c4d94cdb1d05e88f120988" args=")(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>( <a class="el" href="rdkafka_8h.html#a4b71a63f37c4d94cdb1d05e88f120988">rd_kafka_interceptor_f_on_send_t</a>)(rd_kafka_t *rk, <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, void *ic_opaque)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>on_send() is called from rd_kafka_produce*() (et.al) prior to the partitioner being called. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rk</em>&nbsp;</td><td>The client instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rkmessage</em>&nbsp;</td><td>The message being produced. Immutable. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ic_opaque</em>&nbsp;</td><td>The interceptor's opaque pointer specified in ..add..().</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This interceptor is only used by producer instances.</dd>
<dd>
The <code>rkmessage</code> object is NOT mutable and MUST NOT be modified by the interceptor.</dd>
<dd>
If the partitioner fails or an unknown partition was specified, the on_acknowledgement() interceptor chain will be called from within the rd_kafka_produce*() call to maintain send-acknowledgement symmetry.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an error code on failure, the error is logged but otherwise ignored. </dd></dl>

</div>
</div>
<a class="anchor" id="aca93ab41df25cab562b9a4cf6c0e7320"></a><!-- doxytag: member="rdkafka.h::rd_kafka_interceptor_f_on_acknowledgement_t" ref="aca93ab41df25cab562b9a4cf6c0e7320" args=")(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>( <a class="el" href="rdkafka_8h.html#aca93ab41df25cab562b9a4cf6c0e7320">rd_kafka_interceptor_f_on_acknowledgement_t</a>)(rd_kafka_t *rk, <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, void *ic_opaque)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>on_acknowledgement() is called to inform interceptors that a message was succesfully delivered or permanently failed delivery. The interceptor chain is called from internal librdkafka background threads, or rd_kafka_produce*() if the partitioner failed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rk</em>&nbsp;</td><td>The client instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rkmessage</em>&nbsp;</td><td>The message being produced. Immutable. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ic_opaque</em>&nbsp;</td><td>The interceptor's opaque pointer specified in ..add..().</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This interceptor is only used by producer instances.</dd>
<dd>
The <code>rkmessage</code> object is NOT mutable and MUST NOT be modified by the interceptor.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The on_acknowledgement() method may be called from internal librdkafka threads. An on_acknowledgement() interceptor MUST NOT call any librdkafka API's associated with the <code>rk</code>, or perform any blocking or prolonged work.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an error code on failure, the error is logged but otherwise ignored. </dd></dl>

</div>
</div>
<a class="anchor" id="aeafe5c26d64281c1f9a2e2f77f774fa4"></a><!-- doxytag: member="rdkafka.h::rd_kafka_interceptor_f_on_consume_t" ref="aeafe5c26d64281c1f9a2e2f77f774fa4" args=")(rd_kafka_t *rk, rd_kafka_message_t *rkmessage, void *ic_opaque)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>( <a class="el" href="rdkafka_8h.html#aeafe5c26d64281c1f9a2e2f77f774fa4">rd_kafka_interceptor_f_on_consume_t</a>)(rd_kafka_t *rk, <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, void *ic_opaque)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>on_consume() is called just prior to passing the message to the application in <a class="el" href="rdkafka_8h.html#a65cc6cb9bd72c4084f074af0361ceddf" title="Poll the consumer for messages or events.">rd_kafka_consumer_poll()</a>, rd_kafka_consume*(), the event interface, etc. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rk</em>&nbsp;</td><td>The client instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rkmessage</em>&nbsp;</td><td>The message being consumed. Immutable. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ic_opaque</em>&nbsp;</td><td>The interceptor's opaque pointer specified in ..add..().</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This interceptor is only used by consumer instances.</dd>
<dd>
The <code>rkmessage</code> object is NOT mutable and MUST NOT be modified by the interceptor.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an error code on failure, the error is logged but otherwise ignored. </dd></dl>

</div>
</div>
<a class="anchor" id="a4ce7c3dfd327ce6512245302be4fe067"></a><!-- doxytag: member="rdkafka.h::rd_kafka_interceptor_f_on_commit_t" ref="a4ce7c3dfd327ce6512245302be4fe067" args=")(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_resp_err_t err, void *ic_opaque)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>( <a class="el" href="rdkafka_8h.html#a4ce7c3dfd327ce6512245302be4fe067">rd_kafka_interceptor_f_on_commit_t</a>)(rd_kafka_t *rk, const <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *offsets, <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> err, void *ic_opaque)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>on_commit() is called on completed or failed offset commit. It is called from internal librdkafka threads. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rk</em>&nbsp;</td><td>The client instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offsets</em>&nbsp;</td><td>List of topic+partition+offset+error that were committed. The error message of each partition should be checked for error. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ic_opaque</em>&nbsp;</td><td>The interceptor's opaque pointer specified in ..add..().</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This interceptor is only used by consumer instances.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The on_commit() interceptor is called from internal librdkafka threads. An on_commit() interceptor MUST NOT call any librdkafka API's associated with the <code>rk</code>, or perform any blocking or prolonged work.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an error code on failure, the error is logged but otherwise ignored. </dd></dl>

</div>
</div>
<a class="anchor" id="afae0abf1b1a5a85da0e3e22c78e3c5bf"></a><!-- doxytag: member="rdkafka.h::rd_kafka_interceptor_f_on_request_sent_t" ref="afae0abf1b1a5a85da0e3e22c78e3c5bf" args=")(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>( <a class="el" href="rdkafka_8h.html#afae0abf1b1a5a85da0e3e22c78e3c5bf">rd_kafka_interceptor_f_on_request_sent_t</a>)(rd_kafka_t *rk, int sockfd, const char *brokername, int32_t brokerid, int16_t ApiKey, int16_t ApiVersion, int32_t CorrId, size_t size, void *ic_opaque)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>on_request_sent() is called when a request has been fully written to a broker TCP connections socket. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rk</em>&nbsp;</td><td>The client instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sockfd</em>&nbsp;</td><td>Socket file descriptor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>brokername</em>&nbsp;</td><td>Broker request is being sent to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>brokerid</em>&nbsp;</td><td>Broker request is being sent to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ApiKey</em>&nbsp;</td><td>Kafka protocol request type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ApiVersion</em>&nbsp;</td><td>Kafka protocol request type version. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Corrid</em>&nbsp;</td><td>Kafka protocol request correlation id. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of request. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ic_opaque</em>&nbsp;</td><td>The interceptor's opaque pointer specified in ..add..().</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The on_request_sent() interceptor is called from internal librdkafka broker threads. An on_request_sent() interceptor MUST NOT call any librdkafka API's associated with the <code>rk</code>, or perform any blocking or prolonged work.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an error code on failure, the error is logged but otherwise ignored. </dd></dl>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ac6f9c3cb01cbaf3013689c4f2731b831"></a><!-- doxytag: member="rdkafka.h::rd_kafka_type_t" ref="ac6f9c3cb01cbaf3013689c4f2731b831" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831">rd_kafka_type_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>rd_kafka_t handle type. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rdkafka_8h.html#a63d5cd86ab1f77772b2be170e1c09c24" title="Creates a new Kafka handle and starts its operation according to the specified type...">rd_kafka_new()</a> </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ac6f9c3cb01cbaf3013689c4f2731b831ae6134e8d67bee67bfe5e90783f3b9dc8"></a><!-- doxytag: member="RD_KAFKA_PRODUCER" ref="ac6f9c3cb01cbaf3013689c4f2731b831ae6134e8d67bee67bfe5e90783f3b9dc8" args="" -->RD_KAFKA_PRODUCER</em>&nbsp;</td><td>
<p>Producer client </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac6f9c3cb01cbaf3013689c4f2731b831abdc1bc1d648fb12ee3f7d42de732e049"></a><!-- doxytag: member="RD_KAFKA_CONSUMER" ref="ac6f9c3cb01cbaf3013689c4f2731b831abdc1bc1d648fb12ee3f7d42de732e049" args="" -->RD_KAFKA_CONSUMER</em>&nbsp;</td><td>
<p>Consumer client </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="af7cb459a230a61489234823da2beb3f3"></a><!-- doxytag: member="rdkafka.h::rd_kafka_timestamp_type_t" ref="af7cb459a230a61489234823da2beb3f3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rdkafka_8h.html#af7cb459a230a61489234823da2beb3f3">rd_kafka_timestamp_type_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="af7cb459a230a61489234823da2beb3f3a9787f345653eaccb6b0020d8eb36d647"></a><!-- doxytag: member="RD_KAFKA_TIMESTAMP_NOT_AVAILABLE" ref="af7cb459a230a61489234823da2beb3f3a9787f345653eaccb6b0020d8eb36d647" args="" -->RD_KAFKA_TIMESTAMP_NOT_AVAILABLE</em>&nbsp;</td><td>
<p>Timestamp not available </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af7cb459a230a61489234823da2beb3f3af59e58fbfe91ffafad1c1b107e32022e"></a><!-- doxytag: member="RD_KAFKA_TIMESTAMP_CREATE_TIME" ref="af7cb459a230a61489234823da2beb3f3af59e58fbfe91ffafad1c1b107e32022e" args="" -->RD_KAFKA_TIMESTAMP_CREATE_TIME</em>&nbsp;</td><td>
<p>Message creation time </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af7cb459a230a61489234823da2beb3f3afb39205b4fd7d71547c05f94bf8d70a8"></a><!-- doxytag: member="RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME" ref="af7cb459a230a61489234823da2beb3f3afb39205b4fd7d71547c05f94bf8d70a8" args="" -->RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME</em>&nbsp;</td><td>
<p>Log append time </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cb"></a><!-- doxytag: member="rdkafka.h::rd_kafka_resp_err_t" ref="a03509bab51072c72a8dcf52337e6d5cb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Error codes. </p>
<p>The negative error codes delimited by two underscores (<code>RD_KAFKA_RESP_ERR__</code>..) denotes errors internal to librdkafka and are displayed as <code>\"Local: \&lt;error string..\&gt;\"</code>, while the error codes delimited by a single underscore (<code>RD_KAFKA_RESP_ERR_</code>..) denote broker errors and are displayed as <code>\"Broker: \&lt;error string..\&gt;\"</code>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>Use <a class="el" href="rdkafka_8h.html#ab7bfc925e8d63851511b88a1cee94d6d" title="Returns a human readable representation of a kafka error.">rd_kafka_err2str()</a> to translate an error code a human readable string </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba2142df2480425e88d9d96b1b08cc7c67"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__BEGIN" ref="a03509bab51072c72a8dcf52337e6d5cba2142df2480425e88d9d96b1b08cc7c67" args="" -->RD_KAFKA_RESP_ERR__BEGIN</em>&nbsp;</td><td>
<p>Begin internal error codes </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba807f99673a16c6dfc2d6711a142fdf63"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__BAD_MSG" ref="a03509bab51072c72a8dcf52337e6d5cba807f99673a16c6dfc2d6711a142fdf63" args="" -->RD_KAFKA_RESP_ERR__BAD_MSG</em>&nbsp;</td><td>
<p>Received message is incorrect </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba83f21df6d9e4919fa6f63f4978d92e31"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__BAD_COMPRESSION" ref="a03509bab51072c72a8dcf52337e6d5cba83f21df6d9e4919fa6f63f4978d92e31" args="" -->RD_KAFKA_RESP_ERR__BAD_COMPRESSION</em>&nbsp;</td><td>
<p>Bad/unknown compression </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba9701b1e8dbfd8514773837924607985d"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__DESTROY" ref="a03509bab51072c72a8dcf52337e6d5cba9701b1e8dbfd8514773837924607985d" args="" -->RD_KAFKA_RESP_ERR__DESTROY</em>&nbsp;</td><td>
<p>Broker is going away </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba499a09426c7317e0c8030be5bfadd6a2"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__FAIL" ref="a03509bab51072c72a8dcf52337e6d5cba499a09426c7317e0c8030be5bfadd6a2" args="" -->RD_KAFKA_RESP_ERR__FAIL</em>&nbsp;</td><td>
<p>Generic failure </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaa2e905024b42d56f177547ef2c6921f2"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__TRANSPORT" ref="a03509bab51072c72a8dcf52337e6d5cbaa2e905024b42d56f177547ef2c6921f2" args="" -->RD_KAFKA_RESP_ERR__TRANSPORT</em>&nbsp;</td><td>
<p>Broker transport failure </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbad854e2c94bb5b92e83cdbe5d1b1a98ab"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE" ref="a03509bab51072c72a8dcf52337e6d5cbad854e2c94bb5b92e83cdbe5d1b1a98ab" args="" -->RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE</em>&nbsp;</td><td>
<p>Critical system resource </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba86ca698f5d4d99a0d61b0ec62c6ab093"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__RESOLVE" ref="a03509bab51072c72a8dcf52337e6d5cba86ca698f5d4d99a0d61b0ec62c6ab093" args="" -->RD_KAFKA_RESP_ERR__RESOLVE</em>&nbsp;</td><td>
<p>Failed to resolve broker </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbacb94a826892b8fef52de2c326f765172"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__MSG_TIMED_OUT" ref="a03509bab51072c72a8dcf52337e6d5cbacb94a826892b8fef52de2c326f765172" args="" -->RD_KAFKA_RESP_ERR__MSG_TIMED_OUT</em>&nbsp;</td><td>
<p>Produced message timed out </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaffd61f12a5298f508039a9e2521752a5"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__PARTITION_EOF" ref="a03509bab51072c72a8dcf52337e6d5cbaffd61f12a5298f508039a9e2521752a5" args="" -->RD_KAFKA_RESP_ERR__PARTITION_EOF</em>&nbsp;</td><td>
<p>Reached the end of the topic+partition queue on the broker. Not really an error. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba1703a6690b6278c4ce60a7745d81c435"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION" ref="a03509bab51072c72a8dcf52337e6d5cba1703a6690b6278c4ce60a7745d81c435" args="" -->RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION</em>&nbsp;</td><td>
<p>Permanent: Partition does not exist in cluster. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba184f6fcda3fe1f6549c45f621dc456bf"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__FS" ref="a03509bab51072c72a8dcf52337e6d5cba184f6fcda3fe1f6549c45f621dc456bf" args="" -->RD_KAFKA_RESP_ERR__FS</em>&nbsp;</td><td>
<p>File or filesystem error </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbacc9b54e879dba9f6ed3c6e4492a4ae9e"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC" ref="a03509bab51072c72a8dcf52337e6d5cbacc9b54e879dba9f6ed3c6e4492a4ae9e" args="" -->RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC</em>&nbsp;</td><td>
<p>Permanent: Topic does not exist in cluster. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbadf1a1cc2d9244d10b5d9b2176da1a7b1"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN" ref="a03509bab51072c72a8dcf52337e6d5cbadf1a1cc2d9244d10b5d9b2176da1a7b1" args="" -->RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN</em>&nbsp;</td><td>
<p>All broker connections are down. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba44458ff21ab957663118decae3fe0a31"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__INVALID_ARG" ref="a03509bab51072c72a8dcf52337e6d5cba44458ff21ab957663118decae3fe0a31" args="" -->RD_KAFKA_RESP_ERR__INVALID_ARG</em>&nbsp;</td><td>
<p>Invalid argument, or invalid configuration </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba191a3d68aab046a25af5e861a5ce394e"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__TIMED_OUT" ref="a03509bab51072c72a8dcf52337e6d5cba191a3d68aab046a25af5e861a5ce394e" args="" -->RD_KAFKA_RESP_ERR__TIMED_OUT</em>&nbsp;</td><td>
<p>Operation timed out </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba8614bce6b6367c95e05003ed953abefa"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__QUEUE_FULL" ref="a03509bab51072c72a8dcf52337e6d5cba8614bce6b6367c95e05003ed953abefa" args="" -->RD_KAFKA_RESP_ERR__QUEUE_FULL</em>&nbsp;</td><td>
<p>Queue is full </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba35e614340fa0417a954a94d9ed252be3"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__ISR_INSUFF" ref="a03509bab51072c72a8dcf52337e6d5cba35e614340fa0417a954a94d9ed252be3" args="" -->RD_KAFKA_RESP_ERR__ISR_INSUFF</em>&nbsp;</td><td>
<p>ISR count &lt; required.acks </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbad6b23970e00b4575556e8bf6669b1907"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__NODE_UPDATE" ref="a03509bab51072c72a8dcf52337e6d5cbad6b23970e00b4575556e8bf6669b1907" args="" -->RD_KAFKA_RESP_ERR__NODE_UPDATE</em>&nbsp;</td><td>
<p>Broker node update </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbafa666e504c1c4db6132bb8cc62789bd7"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__SSL" ref="a03509bab51072c72a8dcf52337e6d5cbafa666e504c1c4db6132bb8cc62789bd7" args="" -->RD_KAFKA_RESP_ERR__SSL</em>&nbsp;</td><td>
<p>SSL error </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaff33cdcf5c414f862d30bfc971d9b883"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__WAIT_COORD" ref="a03509bab51072c72a8dcf52337e6d5cbaff33cdcf5c414f862d30bfc971d9b883" args="" -->RD_KAFKA_RESP_ERR__WAIT_COORD</em>&nbsp;</td><td>
<p>Waiting for coordinator to become available. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba34f3842df468d18d83eaf06fcb1ec133"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__UNKNOWN_GROUP" ref="a03509bab51072c72a8dcf52337e6d5cba34f3842df468d18d83eaf06fcb1ec133" args="" -->RD_KAFKA_RESP_ERR__UNKNOWN_GROUP</em>&nbsp;</td><td>
<p>Unknown client group </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba3aa91f47659cd8db6e526d61bd801bb0"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__IN_PROGRESS" ref="a03509bab51072c72a8dcf52337e6d5cba3aa91f47659cd8db6e526d61bd801bb0" args="" -->RD_KAFKA_RESP_ERR__IN_PROGRESS</em>&nbsp;</td><td>
<p>Operation in progress </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba7e8c91550c7f80e3bde03d2e2a26a13f"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS" ref="a03509bab51072c72a8dcf52337e6d5cba7e8c91550c7f80e3bde03d2e2a26a13f" args="" -->RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS</em>&nbsp;</td><td>
<p>Previous operation in progress, wait for it to finish. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba564de373d65dea2640f879b8f38032ba"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION" ref="a03509bab51072c72a8dcf52337e6d5cba564de373d65dea2640f879b8f38032ba" args="" -->RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION</em>&nbsp;</td><td>
<p>This operation would interfere with an existing subscription </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba4eab145a6f57f455bdde22cb94b61e90"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS" ref="a03509bab51072c72a8dcf52337e6d5cba4eab145a6f57f455bdde22cb94b61e90" args="" -->RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS</em>&nbsp;</td><td>
<p>Assigned partitions (rebalance_cb) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba52a7ba59b755f419beec0433cb1633bb"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS" ref="a03509bab51072c72a8dcf52337e6d5cba52a7ba59b755f419beec0433cb1633bb" args="" -->RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS</em>&nbsp;</td><td>
<p>Revoked partitions (rebalance_cb) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbab7a5dd3646ae093462cd3bb7add5c591"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__CONFLICT" ref="a03509bab51072c72a8dcf52337e6d5cbab7a5dd3646ae093462cd3bb7add5c591" args="" -->RD_KAFKA_RESP_ERR__CONFLICT</em>&nbsp;</td><td>
<p>Conflicting use </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba6953cd96832fca9dab355a87dd83ac0d"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__STATE" ref="a03509bab51072c72a8dcf52337e6d5cba6953cd96832fca9dab355a87dd83ac0d" args="" -->RD_KAFKA_RESP_ERR__STATE</em>&nbsp;</td><td>
<p>Wrong state </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba8c92444502a2e12e78e34c293bcdd341"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL" ref="a03509bab51072c72a8dcf52337e6d5cba8c92444502a2e12e78e34c293bcdd341" args="" -->RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL</em>&nbsp;</td><td>
<p>Unknown protocol </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba8a4196c480d8dde72c14c390fe94b113"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED" ref="a03509bab51072c72a8dcf52337e6d5cba8a4196c480d8dde72c14c390fe94b113" args="" -->RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED</em>&nbsp;</td><td>
<p>Not implemented </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba87e67feaf9a884055ca195ece3ccf1c4"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__AUTHENTICATION" ref="a03509bab51072c72a8dcf52337e6d5cba87e67feaf9a884055ca195ece3ccf1c4" args="" -->RD_KAFKA_RESP_ERR__AUTHENTICATION</em>&nbsp;</td><td>
<p>Authentication failure </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbada22593237070471d4ce1de595d1a0ae"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__NO_OFFSET" ref="a03509bab51072c72a8dcf52337e6d5cbada22593237070471d4ce1de595d1a0ae" args="" -->RD_KAFKA_RESP_ERR__NO_OFFSET</em>&nbsp;</td><td>
<p>No stored offset </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba48d28854717a35c7607ce851a75bcdc7"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__OUTDATED" ref="a03509bab51072c72a8dcf52337e6d5cba48d28854717a35c7607ce851a75bcdc7" args="" -->RD_KAFKA_RESP_ERR__OUTDATED</em>&nbsp;</td><td>
<p>Outdated </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbac0bdc2e1ad2796d55446e038af7b24aa"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE" ref="a03509bab51072c72a8dcf52337e6d5cbac0bdc2e1ad2796d55446e038af7b24aa" args="" -->RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE</em>&nbsp;</td><td>
<p>Timed out in queue </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbae7d5f35c2cf0641d7952d6cdf8b065ee"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE" ref="a03509bab51072c72a8dcf52337e6d5cbae7d5f35c2cf0641d7952d6cdf8b065ee" args="" -->RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE</em>&nbsp;</td><td>
<p>Feature not supported by broker </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba86c020648a3e8257a018955196efea23"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__WAIT_CACHE" ref="a03509bab51072c72a8dcf52337e6d5cba86c020648a3e8257a018955196efea23" args="" -->RD_KAFKA_RESP_ERR__WAIT_CACHE</em>&nbsp;</td><td>
<p>Awaiting cache update </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaef87b84297d178bfe7938e21916f7283"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__INTR" ref="a03509bab51072c72a8dcf52337e6d5cbaef87b84297d178bfe7938e21916f7283" args="" -->RD_KAFKA_RESP_ERR__INTR</em>&nbsp;</td><td>
<p>Operation interrupted (e.g., due to yield)) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba97ca26a246e51745da9d3859f5640839"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__KEY_SERIALIZATION" ref="a03509bab51072c72a8dcf52337e6d5cba97ca26a246e51745da9d3859f5640839" args="" -->RD_KAFKA_RESP_ERR__KEY_SERIALIZATION</em>&nbsp;</td><td>
<p>Key serialization error </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba50ccfe49dddd07786207cb0a126ea300"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION" ref="a03509bab51072c72a8dcf52337e6d5cba50ccfe49dddd07786207cb0a126ea300" args="" -->RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION</em>&nbsp;</td><td>
<p>Value serialization error </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaf806877fb6d670e586bffc367f4dec55"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION" ref="a03509bab51072c72a8dcf52337e6d5cbaf806877fb6d670e586bffc367f4dec55" args="" -->RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION</em>&nbsp;</td><td>
<p>Key deserialization error </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbad9d20886a20fbace5a8768f5c817cc96"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION" ref="a03509bab51072c72a8dcf52337e6d5cbad9d20886a20fbace5a8768f5c817cc96" args="" -->RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION</em>&nbsp;</td><td>
<p>Value deserialization error </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba8cc1816a0044ca635671d88389e39729"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__PARTIAL" ref="a03509bab51072c72a8dcf52337e6d5cba8cc1816a0044ca635671d88389e39729" args="" -->RD_KAFKA_RESP_ERR__PARTIAL</em>&nbsp;</td><td>
<p>Partial response </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba3b8c36bb901214ee29c1f912cbb1b669"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__READ_ONLY" ref="a03509bab51072c72a8dcf52337e6d5cba3b8c36bb901214ee29c1f912cbb1b669" args="" -->RD_KAFKA_RESP_ERR__READ_ONLY</em>&nbsp;</td><td>
<p>Modification attempted on read-only object </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba22abafa69d4f05fdbaf08ed0b56fec47"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__NOENT" ref="a03509bab51072c72a8dcf52337e6d5cba22abafa69d4f05fdbaf08ed0b56fec47" args="" -->RD_KAFKA_RESP_ERR__NOENT</em>&nbsp;</td><td>
<p>No such entry / item not found </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba204a75c2a865248e4a2d4aaa167ab6bc"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__UNDERFLOW" ref="a03509bab51072c72a8dcf52337e6d5cba204a75c2a865248e4a2d4aaa167ab6bc" args="" -->RD_KAFKA_RESP_ERR__UNDERFLOW</em>&nbsp;</td><td>
<p>Read underflow </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaebda7d93e71b33ea682f2cdb2d025c0c"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR__END" ref="a03509bab51072c72a8dcf52337e6d5cbaebda7d93e71b33ea682f2cdb2d025c0c" args="" -->RD_KAFKA_RESP_ERR__END</em>&nbsp;</td><td>
<p>End internal error codes </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbafd4f4e867c50ec320e86871b98b7b15e"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_UNKNOWN" ref="a03509bab51072c72a8dcf52337e6d5cbafd4f4e867c50ec320e86871b98b7b15e" args="" -->RD_KAFKA_RESP_ERR_UNKNOWN</em>&nbsp;</td><td>
<p>Unknown broker error </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaeb15f812641343033e3939df4adfff0a"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_NO_ERROR" ref="a03509bab51072c72a8dcf52337e6d5cbaeb15f812641343033e3939df4adfff0a" args="" -->RD_KAFKA_RESP_ERR_NO_ERROR</em>&nbsp;</td><td>
<p>Success </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaab466ebc9f9efcdbedfef4e57449adf4"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE" ref="a03509bab51072c72a8dcf52337e6d5cbaab466ebc9f9efcdbedfef4e57449adf4" args="" -->RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE</em>&nbsp;</td><td>
<p>Offset out of range </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbadaaa397721f1566aa1befbb42635c6c9"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_INVALID_MSG" ref="a03509bab51072c72a8dcf52337e6d5cbadaaa397721f1566aa1befbb42635c6c9" args="" -->RD_KAFKA_RESP_ERR_INVALID_MSG</em>&nbsp;</td><td>
<p>Invalid message </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba22f2b9f295640b43bbd20b064931eaa4"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART" ref="a03509bab51072c72a8dcf52337e6d5cba22f2b9f295640b43bbd20b064931eaa4" args="" -->RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART</em>&nbsp;</td><td>
<p>Unknown topic or partition </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba4a78c95be9dce44441151db0f064939e"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE" ref="a03509bab51072c72a8dcf52337e6d5cba4a78c95be9dce44441151db0f064939e" args="" -->RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE</em>&nbsp;</td><td>
<p>Invalid message size </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba1b8fa864f8174e650a362d6c85c4acac"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE" ref="a03509bab51072c72a8dcf52337e6d5cba1b8fa864f8174e650a362d6c85c4acac" args="" -->RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE</em>&nbsp;</td><td>
<p>Leader not available </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba48f7ea11514f0d02c090a0bf52deabb8"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION" ref="a03509bab51072c72a8dcf52337e6d5cba48f7ea11514f0d02c090a0bf52deabb8" args="" -->RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION</em>&nbsp;</td><td>
<p>Not leader for partition </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba1944ffe5311ce97d4f71133efd5f745f"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT" ref="a03509bab51072c72a8dcf52337e6d5cba1944ffe5311ce97d4f71133efd5f745f" args="" -->RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT</em>&nbsp;</td><td>
<p>Request timed out </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba7021ad7d7486a4a33e19df226908f6f4"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE" ref="a03509bab51072c72a8dcf52337e6d5cba7021ad7d7486a4a33e19df226908f6f4" args="" -->RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE</em>&nbsp;</td><td>
<p>Broker not available </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba550f9d64d5e2d05c61b5f18942832854"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE" ref="a03509bab51072c72a8dcf52337e6d5cba550f9d64d5e2d05c61b5f18942832854" args="" -->RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE</em>&nbsp;</td><td>
<p>Replica not available </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba2c5f25f8d58662c06485884c62ccd728"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE" ref="a03509bab51072c72a8dcf52337e6d5cba2c5f25f8d58662c06485884c62ccd728" args="" -->RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE</em>&nbsp;</td><td>
<p>Message size too large </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba901383ac11a5068e5cfa64fe0899ef42"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH" ref="a03509bab51072c72a8dcf52337e6d5cba901383ac11a5068e5cfa64fe0899ef42" args="" -->RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH</em>&nbsp;</td><td>
<p>StaleControllerEpochCode </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbad1ace41b4944aa8510d001cc0750af3d"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE" ref="a03509bab51072c72a8dcf52337e6d5cbad1ace41b4944aa8510d001cc0750af3d" args="" -->RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE</em>&nbsp;</td><td>
<p>Offset metadata string too large </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba24a154a4fd4b62b7a7fa77b816561c49"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION" ref="a03509bab51072c72a8dcf52337e6d5cba24a154a4fd4b62b7a7fa77b816561c49" args="" -->RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION</em>&nbsp;</td><td>
<p>Broker disconnected before response received </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba837e05b8dc24415d0cdd24fa90c94c2b"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS" ref="a03509bab51072c72a8dcf52337e6d5cba837e05b8dc24415d0cdd24fa90c94c2b" args="" -->RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS</em>&nbsp;</td><td>
<p>Group coordinator load in progress </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba4b2032a44b39cfcf79af6d38cfee53d6"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE" ref="a03509bab51072c72a8dcf52337e6d5cba4b2032a44b39cfcf79af6d38cfee53d6" args="" -->RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE</em>&nbsp;</td><td>
<p>Group coordinator not available </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbae3cca426eb84d8c987fcd22d93e3b042"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP" ref="a03509bab51072c72a8dcf52337e6d5cbae3cca426eb84d8c987fcd22d93e3b042" args="" -->RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP</em>&nbsp;</td><td>
<p>Not coordinator for group </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaffe696a1bb54ec33b8d258a71d138630"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION" ref="a03509bab51072c72a8dcf52337e6d5cbaffe696a1bb54ec33b8d258a71d138630" args="" -->RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION</em>&nbsp;</td><td>
<p>Invalid topic </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba2427070db08c0dbf603d7a439ecafa4e"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE" ref="a03509bab51072c72a8dcf52337e6d5cba2427070db08c0dbf603d7a439ecafa4e" args="" -->RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE</em>&nbsp;</td><td>
<p>Message batch larger than configured server segment size </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba963396ec3f0141e7cd64eb9103ba025a"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS" ref="a03509bab51072c72a8dcf52337e6d5cba963396ec3f0141e7cd64eb9103ba025a" args="" -->RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS</em>&nbsp;</td><td>
<p>Not enough in-sync replicas </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba3c6bd5bd0a338857481157ad58701285"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND" ref="a03509bab51072c72a8dcf52337e6d5cba3c6bd5bd0a338857481157ad58701285" args="" -->RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND</em>&nbsp;</td><td>
<p>Message(s) written to insufficient number of in-sync replicas </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba1bcf9b14d3109e0906710f3fedf6bfa0"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS" ref="a03509bab51072c72a8dcf52337e6d5cba1bcf9b14d3109e0906710f3fedf6bfa0" args="" -->RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS</em>&nbsp;</td><td>
<p>Invalid required acks value </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba7ef65ef4b7e4883d37f07edb2b9299cf"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION" ref="a03509bab51072c72a8dcf52337e6d5cba7ef65ef4b7e4883d37f07edb2b9299cf" args="" -->RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION</em>&nbsp;</td><td>
<p>Specified group generation id is not valid </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba3d611434978ee6c5d1e2c031eae22851"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL" ref="a03509bab51072c72a8dcf52337e6d5cba3d611434978ee6c5d1e2c031eae22851" args="" -->RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL</em>&nbsp;</td><td>
<p>Inconsistent group protocol </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba617af6d0a3be8be217a6d4097fe08d93"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_INVALID_GROUP_ID" ref="a03509bab51072c72a8dcf52337e6d5cba617af6d0a3be8be217a6d4097fe08d93" args="" -->RD_KAFKA_RESP_ERR_INVALID_GROUP_ID</em>&nbsp;</td><td>
<p>Invalid group.id </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba98ba2fb36473df8aa20eece119b5c371"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID" ref="a03509bab51072c72a8dcf52337e6d5cba98ba2fb36473df8aa20eece119b5c371" args="" -->RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID</em>&nbsp;</td><td>
<p>Unknown member </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbacbf57dcb89cbe4e8109009235c3a38a3"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT" ref="a03509bab51072c72a8dcf52337e6d5cbacbf57dcb89cbe4e8109009235c3a38a3" args="" -->RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT</em>&nbsp;</td><td>
<p>Invalid session timeout </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbafacbf6cd012723e9deeffdbedb086c34"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS" ref="a03509bab51072c72a8dcf52337e6d5cbafacbf6cd012723e9deeffdbedb086c34" args="" -->RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS</em>&nbsp;</td><td>
<p>Group rebalance in progress </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbabce6dddfb9449a93d89f5175259b01f5"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE" ref="a03509bab51072c72a8dcf52337e6d5cbabce6dddfb9449a93d89f5175259b01f5" args="" -->RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE</em>&nbsp;</td><td>
<p>Commit offset data size is not valid </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbac3ca8f351f7f49bc644360d70def9d15"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED" ref="a03509bab51072c72a8dcf52337e6d5cbac3ca8f351f7f49bc644360d70def9d15" args="" -->RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED</em>&nbsp;</td><td>
<p>Topic authorization failed </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaf6a3717285b4de6d098778d5abff62d3"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED" ref="a03509bab51072c72a8dcf52337e6d5cbaf6a3717285b4de6d098778d5abff62d3" args="" -->RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED</em>&nbsp;</td><td>
<p>Group authorization failed </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba91be303afca8631793ae36cd7fa5eb9b"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED" ref="a03509bab51072c72a8dcf52337e6d5cba91be303afca8631793ae36cd7fa5eb9b" args="" -->RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED</em>&nbsp;</td><td>
<p>Cluster authorization failed </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaa36b8c17d6e57243b85992c8a4c4fbf8"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP" ref="a03509bab51072c72a8dcf52337e6d5cbaa36b8c17d6e57243b85992c8a4c4fbf8" args="" -->RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP</em>&nbsp;</td><td>
<p>Invalid timestamp </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbab6e2e19fa13d5a65dcd0a09cc00e94fa"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM" ref="a03509bab51072c72a8dcf52337e6d5cbab6e2e19fa13d5a65dcd0a09cc00e94fa" args="" -->RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM</em>&nbsp;</td><td>
<p>Unsupported SASL mechanism </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaf2c0ee45c60d46a1dfb209afcbc97e3f"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE" ref="a03509bab51072c72a8dcf52337e6d5cbaf2c0ee45c60d46a1dfb209afcbc97e3f" args="" -->RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE</em>&nbsp;</td><td>
<p>Illegal SASL state </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba46f16f7c02e3798695feff061acd3f72"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION" ref="a03509bab51072c72a8dcf52337e6d5cba46f16f7c02e3798695feff061acd3f72" args="" -->RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION</em>&nbsp;</td><td>
<p>Unuspported version </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba2bbe3972fadcb5659de8ba452ba9930d"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS" ref="a03509bab51072c72a8dcf52337e6d5cba2bbe3972fadcb5659de8ba452ba9930d" args="" -->RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS</em>&nbsp;</td><td>
<p>Topic already exists </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbae389ad18fd247f5194ecd8b06bab8af0"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_INVALID_PARTITIONS" ref="a03509bab51072c72a8dcf52337e6d5cbae389ad18fd247f5194ecd8b06bab8af0" args="" -->RD_KAFKA_RESP_ERR_INVALID_PARTITIONS</em>&nbsp;</td><td>
<p>Invalid number of partitions </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba79bf494e4989ba2d6ef2d5dfe35e07d4"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR" ref="a03509bab51072c72a8dcf52337e6d5cba79bf494e4989ba2d6ef2d5dfe35e07d4" args="" -->RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR</em>&nbsp;</td><td>
<p>Invalid replication factor </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbae2bc328101f522588761a21bd1e92d33"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT" ref="a03509bab51072c72a8dcf52337e6d5cbae2bc328101f522588761a21bd1e92d33" args="" -->RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT</em>&nbsp;</td><td>
<p>Invalid replica assignment </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba31a534f09b2d2be5e31186ee019be02d"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_INVALID_CONFIG" ref="a03509bab51072c72a8dcf52337e6d5cba31a534f09b2d2be5e31186ee019be02d" args="" -->RD_KAFKA_RESP_ERR_INVALID_CONFIG</em>&nbsp;</td><td>
<p>Invalid config </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba57763f968ed247ada93b95f5871c6421"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_NOT_CONTROLLER" ref="a03509bab51072c72a8dcf52337e6d5cba57763f968ed247ada93b95f5871c6421" args="" -->RD_KAFKA_RESP_ERR_NOT_CONTROLLER</em>&nbsp;</td><td>
<p>Not controller for cluster </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaa9136aa227a79576e599b693280e47f4"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_INVALID_REQUEST" ref="a03509bab51072c72a8dcf52337e6d5cbaa9136aa227a79576e599b693280e47f4" args="" -->RD_KAFKA_RESP_ERR_INVALID_REQUEST</em>&nbsp;</td><td>
<p>Invalid request </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba09cc6445761305511ec565a1fb578e63"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT" ref="a03509bab51072c72a8dcf52337e6d5cba09cc6445761305511ec565a1fb578e63" args="" -->RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT</em>&nbsp;</td><td>
<p>Message format on broker does not support request </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba008f9c1a7d4dbbb7b8629329cb94f4d4"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_POLICY_VIOLATION" ref="a03509bab51072c72a8dcf52337e6d5cba008f9c1a7d4dbbb7b8629329cb94f4d4" args="" -->RD_KAFKA_RESP_ERR_POLICY_VIOLATION</em>&nbsp;</td><td>
<p>Isolation policy volation </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbaf78bc9392ecbb491f44f00304db31c5d"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER" ref="a03509bab51072c72a8dcf52337e6d5cbaf78bc9392ecbb491f44f00304db31c5d" args="" -->RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER</em>&nbsp;</td><td>
<p>Broker received an out of order sequence number </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbac29fba93ef898d51228e3b5254f89e93"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER" ref="a03509bab51072c72a8dcf52337e6d5cbac29fba93ef898d51228e3b5254f89e93" args="" -->RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER</em>&nbsp;</td><td>
<p>Broker received a duplicate sequence number </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba246438ea75f6160876ac25460e1e2a76"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH" ref="a03509bab51072c72a8dcf52337e6d5cba246438ea75f6160876ac25460e1e2a76" args="" -->RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH</em>&nbsp;</td><td>
<p>Producer attempted an operation with an old epoch </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba967df10eecf66034efc36e76eb5d4da8"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_INVALID_TXN_STATE" ref="a03509bab51072c72a8dcf52337e6d5cba967df10eecf66034efc36e76eb5d4da8" args="" -->RD_KAFKA_RESP_ERR_INVALID_TXN_STATE</em>&nbsp;</td><td>
<p>Producer attempted a transactional operation in an invalid state </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba386fa6212eb07e2e81ed0b30d03f975b"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING" ref="a03509bab51072c72a8dcf52337e6d5cba386fa6212eb07e2e81ed0b30d03f975b" args="" -->RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING</em>&nbsp;</td><td>
<p>Producer attempted to use a producer id which is not currently assigned to its transactional id </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba0e1a90d8d8a6b03e51d2bdcd61c84977"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT" ref="a03509bab51072c72a8dcf52337e6d5cba0e1a90d8d8a6b03e51d2bdcd61c84977" args="" -->RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT</em>&nbsp;</td><td>
<p>Transaction timeout is larger than the maximum value allowed by the broker's max.transaction.timeout.ms </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba9cc06f97e19cb867471f4fc3039cb92e"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS" ref="a03509bab51072c72a8dcf52337e6d5cba9cc06f97e19cb867471f4fc3039cb92e" args="" -->RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS</em>&nbsp;</td><td>
<p>Producer attempted to update a transaction while another concurrent operation on the same transaction was ongoing </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba01826892e952e952e5cd0a3a025e3ff3"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED" ref="a03509bab51072c72a8dcf52337e6d5cba01826892e952e952e5cd0a3a025e3ff3" args="" -->RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED</em>&nbsp;</td><td>
<p>Indicates that the transaction coordinator sending a WriteTxnMarker is no longer the current coordinator for a given producer </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cbac8538f30651540470a5d9691cdfeb6ac"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED" ref="a03509bab51072c72a8dcf52337e6d5cbac8538f30651540470a5d9691cdfeb6ac" args="" -->RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED</em>&nbsp;</td><td>
<p>Transactional Id authorization failed </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba3fcd641c7927aee35edd5766bd694ec9"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_SECURITY_DISABLED" ref="a03509bab51072c72a8dcf52337e6d5cba3fcd641c7927aee35edd5766bd694ec9" args="" -->RD_KAFKA_RESP_ERR_SECURITY_DISABLED</em>&nbsp;</td><td>
<p>Security features are disabled </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a03509bab51072c72a8dcf52337e6d5cba0c64f1f4d8901d3266ea8bf89f994119"></a><!-- doxytag: member="RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED" ref="a03509bab51072c72a8dcf52337e6d5cba0c64f1f4d8901d3266ea8bf89f994119" args="" -->RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED</em>&nbsp;</td><td>
<p>Operation not attempted </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a9aac65afa4c30e6d75550e39f6c1ea6b"></a><!-- doxytag: member="rdkafka.h::rd_kafka_vtype_t" ref="a9aac65afa4c30e6d75550e39f6c1ea6b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rdkafka_8h.html#a9aac65afa4c30e6d75550e39f6c1ea6b">rd_kafka_vtype_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Var-arg tag types. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rdkafka_8h.html#ac3a111ec3e6729609d498fec7b619efc" title="Produce and send a single message to broker.">rd_kafka_producev()</a> </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a9aac65afa4c30e6d75550e39f6c1ea6ba8392cf8f43a2127fc4fbb1ae50af6f8f"></a><!-- doxytag: member="RD_KAFKA_VTYPE_END" ref="a9aac65afa4c30e6d75550e39f6c1ea6ba8392cf8f43a2127fc4fbb1ae50af6f8f" args="" -->RD_KAFKA_VTYPE_END</em>&nbsp;</td><td>
<p>va-arg sentinel </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9aac65afa4c30e6d75550e39f6c1ea6ba2963e9a4838eb825ad954757a965fd45"></a><!-- doxytag: member="RD_KAFKA_VTYPE_TOPIC" ref="a9aac65afa4c30e6d75550e39f6c1ea6ba2963e9a4838eb825ad954757a965fd45" args="" -->RD_KAFKA_VTYPE_TOPIC</em>&nbsp;</td><td>
<p>(const char *) Topic name </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9aac65afa4c30e6d75550e39f6c1ea6ba37f0b8d0b3add4ad93bdf7ef6863abd9"></a><!-- doxytag: member="RD_KAFKA_VTYPE_RKT" ref="a9aac65afa4c30e6d75550e39f6c1ea6ba37f0b8d0b3add4ad93bdf7ef6863abd9" args="" -->RD_KAFKA_VTYPE_RKT</em>&nbsp;</td><td>
<p>(rd_kafka_topic_t *) Topic handle </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9aac65afa4c30e6d75550e39f6c1ea6ba2374c0d8cd0d293aebd40b687db16b12"></a><!-- doxytag: member="RD_KAFKA_VTYPE_PARTITION" ref="a9aac65afa4c30e6d75550e39f6c1ea6ba2374c0d8cd0d293aebd40b687db16b12" args="" -->RD_KAFKA_VTYPE_PARTITION</em>&nbsp;</td><td>
<p>(int32_t) Partition </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9aac65afa4c30e6d75550e39f6c1ea6baa5c06c93cea11334ee6fd41379dd849d"></a><!-- doxytag: member="RD_KAFKA_VTYPE_VALUE" ref="a9aac65afa4c30e6d75550e39f6c1ea6baa5c06c93cea11334ee6fd41379dd849d" args="" -->RD_KAFKA_VTYPE_VALUE</em>&nbsp;</td><td>
<p>(void *, size_t) Message value (payload) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9aac65afa4c30e6d75550e39f6c1ea6ba83433ee19c9f47e5f561649ab7768cdf"></a><!-- doxytag: member="RD_KAFKA_VTYPE_KEY" ref="a9aac65afa4c30e6d75550e39f6c1ea6ba83433ee19c9f47e5f561649ab7768cdf" args="" -->RD_KAFKA_VTYPE_KEY</em>&nbsp;</td><td>
<p>(void *, size_t) Message key </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9aac65afa4c30e6d75550e39f6c1ea6baa3db5c202df5e978f003cd1c0f1fec29"></a><!-- doxytag: member="RD_KAFKA_VTYPE_OPAQUE" ref="a9aac65afa4c30e6d75550e39f6c1ea6baa3db5c202df5e978f003cd1c0f1fec29" args="" -->RD_KAFKA_VTYPE_OPAQUE</em>&nbsp;</td><td>
<p>(void *) Application opaque </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9aac65afa4c30e6d75550e39f6c1ea6ba2f55d9d2b0729843f99c758155e948da"></a><!-- doxytag: member="RD_KAFKA_VTYPE_MSGFLAGS" ref="a9aac65afa4c30e6d75550e39f6c1ea6ba2f55d9d2b0729843f99c758155e948da" args="" -->RD_KAFKA_VTYPE_MSGFLAGS</em>&nbsp;</td><td>
<p>(int) RD_KAFKA_MSG_F_.. flags </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9aac65afa4c30e6d75550e39f6c1ea6baf2f1861778d90a40cf0c498985fbc768"></a><!-- doxytag: member="RD_KAFKA_VTYPE_TIMESTAMP" ref="a9aac65afa4c30e6d75550e39f6c1ea6baf2f1861778d90a40cf0c498985fbc768" args="" -->RD_KAFKA_VTYPE_TIMESTAMP</em>&nbsp;</td><td>
<p>(int64_t) Milliseconds since epoch UTC </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9aac65afa4c30e6d75550e39f6c1ea6ba5ee53e13817abfea4e94590892cb57f8"></a><!-- doxytag: member="RD_KAFKA_VTYPE_HEADER" ref="a9aac65afa4c30e6d75550e39f6c1ea6ba5ee53e13817abfea4e94590892cb57f8" args="" -->RD_KAFKA_VTYPE_HEADER</em>&nbsp;</td><td>
<p>(const char *, const void *, ssize_t) Message Header </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9aac65afa4c30e6d75550e39f6c1ea6ba26701ae2fe9028f50386a2417ace24a9"></a><!-- doxytag: member="RD_KAFKA_VTYPE_HEADERS" ref="a9aac65afa4c30e6d75550e39f6c1ea6ba26701ae2fe9028f50386a2417ace24a9" args="" -->RD_KAFKA_VTYPE_HEADERS</em>&nbsp;</td><td>
<p>(rd_kafka_headers_t *) Headers list </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ad8306a08e59e8e2cbc6abdb84f9689f4"></a><!-- doxytag: member="rdkafka.h::rd_kafka_conf_res_t" ref="ad8306a08e59e8e2cbc6abdb84f9689f4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Configuration result type. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ad8306a08e59e8e2cbc6abdb84f9689f4aa1a1dc8e18c730866165853ad819054e"></a><!-- doxytag: member="RD_KAFKA_CONF_UNKNOWN" ref="ad8306a08e59e8e2cbc6abdb84f9689f4aa1a1dc8e18c730866165853ad819054e" args="" -->RD_KAFKA_CONF_UNKNOWN</em>&nbsp;</td><td>
<p>Unknown configuration name. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad8306a08e59e8e2cbc6abdb84f9689f4a4461e999ca6c9837a9265dad6f2a0d1e"></a><!-- doxytag: member="RD_KAFKA_CONF_INVALID" ref="ad8306a08e59e8e2cbc6abdb84f9689f4a4461e999ca6c9837a9265dad6f2a0d1e" args="" -->RD_KAFKA_CONF_INVALID</em>&nbsp;</td><td>
<p>Invalid configuration value. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad8306a08e59e8e2cbc6abdb84f9689f4a12343fa082ab52164a17130d6b0d0f5b"></a><!-- doxytag: member="RD_KAFKA_CONF_OK" ref="ad8306a08e59e8e2cbc6abdb84f9689f4a12343fa082ab52164a17130d6b0d0f5b" args="" -->RD_KAFKA_CONF_OK</em>&nbsp;</td><td>
<p>Configuration okay </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a83e363606ef2da2e91b7429b229dbc8e"></a><!-- doxytag: member="rdkafka.h::rd_kafka_version" ref="a83e363606ef2da2e91b7429b229dbc8e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_version </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the librdkafka version as integer. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Version integer.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>See <a class="el" href="rdkafkacpp_8h.html#aa2e242fb8620a32b650a40575bc7f98e" title="librdkafka version">RD_KAFKA_VERSION</a> for how to parse the integer format. </dd>
<dd>
Use <a class="el" href="rdkafka_8h.html#a0cc60434083686fd8e379a905652d34a" title="Returns the librdkafka version as string.">rd_kafka_version_str()</a> to retreive the version as a string. </dd></dl>

</div>
</div>
<a class="anchor" id="a0cc60434083686fd8e379a905652d34a"></a><!-- doxytag: member="rdkafka.h::rd_kafka_version_str" ref="a0cc60434083686fd8e379a905652d34a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT const char* rd_kafka_version_str </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the librdkafka version as string. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Version string </dd></dl>

</div>
</div>
<a class="anchor" id="adece97d3cbdd6ca936df5b0663118c45"></a><!-- doxytag: member="rdkafka.h::rd_kafka_get_debug_contexts" ref="adece97d3cbdd6ca936df5b0663118c45" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT const char* rd_kafka_get_debug_contexts </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve supported debug contexts for use with the <code>\"debug\"</code> configuration property. (runtime). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Comma-separated list of available debugging contexts. </dd></dl>

</div>
</div>
<a class="anchor" id="ab7bfc925e8d63851511b88a1cee94d6d"></a><!-- doxytag: member="rdkafka.h::rd_kafka_err2str" ref="ab7bfc925e8d63851511b88a1cee94d6d" args="(rd_kafka_resp_err_t err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT const char* rd_kafka_err2str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td>
          <td class="paramname"> <em>err</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a human readable representation of a kafka error. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>Error code to translate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8d5f6f2775ec67b124abeb5dfada2d77"></a><!-- doxytag: member="rdkafka.h::rd_kafka_err2name" ref="a8d5f6f2775ec67b124abeb5dfada2d77" args="(rd_kafka_resp_err_t err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT const char* rd_kafka_err2name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a>&nbsp;</td>
          <td class="paramname"> <em>err</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the error code name (enum name). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>Error code to translate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7b90c323d460e0276d79f6ab69e93b7"></a><!-- doxytag: member="rdkafka.h::rd_kafka_last_error" ref="ae7b90c323d460e0276d79f6ab69e93b7" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_last_error </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the last error code generated by a legacy API call in the current thread. </p>
<p>The legacy APIs are the ones using errno to propagate error value, namely:</p>
<ul>
<li><a class="el" href="rdkafka_8h.html#ab1dcba74a35e8f3bfe3270ff600581d8" title="Creates a new topic handle for topic named topic.">rd_kafka_topic_new()</a></li>
<li><a class="el" href="rdkafka_8h.html#ae21dcd2d8c6195baf7f9f4952d7e12d4" title="Start consuming messages for topic rkt and partition at offset offset which may either...">rd_kafka_consume_start()</a></li>
<li><a class="el" href="rdkafka_8h.html#acf07475e5e85e63fc5321a1087288cd4" title="Stop consuming messages for topic rkt and partition, purging all messages currently...">rd_kafka_consume_stop()</a></li>
<li><a class="el" href="rdkafka_8h.html#aa49d14e8b742365f9f25d35318ff0b7e" title="Consume a single message from topic rkt and partition.">rd_kafka_consume()</a></li>
<li><a class="el" href="rdkafka_8h.html#a53511739a2cf498b8d88287fef6873ce" title="Consume up to rkmessages_size from topic rkt and partition putting a pointer to each...">rd_kafka_consume_batch()</a></li>
<li><a class="el" href="rdkafka_8h.html#a303fa0f0da7f3c28bed35570adc983c6" title="Consumes messages from topic rkt and partition, calling the provided callback for...">rd_kafka_consume_callback()</a></li>
<li><a class="el" href="rdkafka_8h.html#a8ff0b80fccb3a5bd31b1baaf20e4ca16" title="Consume from queue.">rd_kafka_consume_queue()</a></li>
<li><a class="el" href="rdkafka_8h.html#ae24d8ebf1ea15ed8ea0ea40f74662736" title="Produce and send a single message to broker.">rd_kafka_produce()</a></li>
</ul>
<p>The main use for this function is to avoid converting system <code>errno</code> values to rd_kafka_resp_err_t codes for legacy APIs.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The last error is stored per-thread, if multiple rd_kafka_t handles are used in the same application thread the developer needs to make sure <a class="el" href="rdkafka_8h.html#ae7b90c323d460e0276d79f6ab69e93b7" title="Returns the last error code generated by a legacy API call in the current thread...">rd_kafka_last_error()</a> is called immediately after a failed API call.</dd>
<dd>
errno propagation from librdkafka is not safe on Windows and should not be used, use <a class="el" href="rdkafka_8h.html#ae7b90c323d460e0276d79f6ab69e93b7" title="Returns the last error code generated by a legacy API call in the current thread...">rd_kafka_last_error()</a> instead. </dd></dl>

</div>
</div>
<a class="anchor" id="abeabf8589c657d7a3ec5a1411a7de91d"></a><!-- doxytag: member="rdkafka.h::rd_kafka_errno2err" ref="abeabf8589c657d7a3ec5a1411a7de91d" args="(int errnox)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT RD_DEPRECATED <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_errno2err </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>errnox</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts the system errno value <code>errnox</code> to a rd_kafka_resp_err_t error code upon failure from the following functions:</p>
<ul>
<li><a class="el" href="rdkafka_8h.html#ab1dcba74a35e8f3bfe3270ff600581d8" title="Creates a new topic handle for topic named topic.">rd_kafka_topic_new()</a></li>
<li><a class="el" href="rdkafka_8h.html#ae21dcd2d8c6195baf7f9f4952d7e12d4" title="Start consuming messages for topic rkt and partition at offset offset which may either...">rd_kafka_consume_start()</a></li>
<li><a class="el" href="rdkafka_8h.html#acf07475e5e85e63fc5321a1087288cd4" title="Stop consuming messages for topic rkt and partition, purging all messages currently...">rd_kafka_consume_stop()</a></li>
<li><a class="el" href="rdkafka_8h.html#aa49d14e8b742365f9f25d35318ff0b7e" title="Consume a single message from topic rkt and partition.">rd_kafka_consume()</a></li>
<li><a class="el" href="rdkafka_8h.html#a53511739a2cf498b8d88287fef6873ce" title="Consume up to rkmessages_size from topic rkt and partition putting a pointer to each...">rd_kafka_consume_batch()</a></li>
<li><a class="el" href="rdkafka_8h.html#a303fa0f0da7f3c28bed35570adc983c6" title="Consumes messages from topic rkt and partition, calling the provided callback for...">rd_kafka_consume_callback()</a></li>
<li><a class="el" href="rdkafka_8h.html#a8ff0b80fccb3a5bd31b1baaf20e4ca16" title="Consume from queue.">rd_kafka_consume_queue()</a></li>
<li><a class="el" href="rdkafka_8h.html#ae24d8ebf1ea15ed8ea0ea40f74662736" title="Produce and send a single message to broker.">rd_kafka_produce()</a>. </li>
</ul>
</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>errnox</em>&nbsp;</td><td>System errno value to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Appropriate error code for <code>errnox</code> </dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>A better alternative is to call <a class="el" href="rdkafka_8h.html#ae7b90c323d460e0276d79f6ab69e93b7" title="Returns the last error code generated by a legacy API call in the current thread...">rd_kafka_last_error()</a> immediately after any of the above functions return -1 or NULL.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Use <a class="el" href="rdkafka_8h.html#ae7b90c323d460e0276d79f6ab69e93b7" title="Returns the last error code generated by a legacy API call in the current thread...">rd_kafka_last_error()</a> to retrieve the last error code set by the legacy librdkafka APIs.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rdkafka_8h.html#ae7b90c323d460e0276d79f6ab69e93b7" title="Returns the last error code generated by a legacy API call in the current thread...">rd_kafka_last_error()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8aa1b1a41d2fc0c487f519663609df4f"></a><!-- doxytag: member="rdkafka.h::rd_kafka_errno" ref="a8aa1b1a41d2fc0c487f519663609df4f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT RD_DEPRECATED int rd_kafka_errno </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the thread-local system errno. </p>
<p>On most platforms this is the same as <code>errno</code> but in case of different runtimes between library and application (e.g., Windows static DLLs) this provides a means for exposing the errno librdkafka uses.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The value is local to the current calling thread.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Use <a class="el" href="rdkafka_8h.html#ae7b90c323d460e0276d79f6ab69e93b7" title="Returns the last error code generated by a legacy API call in the current thread...">rd_kafka_last_error()</a> to retrieve the last error code set by the legacy librdkafka APIs. </dd></dl>

</div>
</div>
<a class="anchor" id="ac5a7b02e3af816cfacbcfa6468c40c9a"></a><!-- doxytag: member="rdkafka.h::rd_kafka_topic_partition_destroy" ref="ac5a7b02e3af816cfacbcfa6468c40c9a" args="(rd_kafka_topic_partition_t *rktpar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_topic_partition_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrd__kafka__topic__partition__t.html">rd_kafka_topic_partition_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rktpar</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy a <a class="el" href="structrd__kafka__topic__partition__t.html" title="Topic+Partition place holder.">rd_kafka_topic_partition_t</a>. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This must not be called for elements in a topic partition list. </dd></dl>

</div>
</div>
<a class="anchor" id="afb87d24333b6ad5a7415b06882f06b2a"></a><!-- doxytag: member="rdkafka.h::rd_kafka_topic_partition_list_new" ref="afb87d24333b6ad5a7415b06882f06b2a" args="(int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a>* rd_kafka_topic_partition_list_new </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new list/vector Topic+Partition container. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Initial allocated size used when the expected number of elements is known or can be estimated. Avoids reallocation and possibly relocation of the elems array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A newly allocated Topic+Partition list.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Use <a class="el" href="rdkafka_8h.html#a0c0ab2640e5e96113ce108ab78f475d0" title="Free all resources used by the list and the list itself.">rd_kafka_topic_partition_list_destroy()</a> to free all resources in use by a list and the list itself. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rdkafka_8h.html#a123ce30e08b31d4ff0fcf6ebe876173d" title="Add topic+partition to list.">rd_kafka_topic_partition_list_add()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a123ce30e08b31d4ff0fcf6ebe876173d"></a><!-- doxytag: member="rdkafka.h::rd_kafka_topic_partition_list_add" ref="a123ce30e08b31d4ff0fcf6ebe876173d" args="(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="structrd__kafka__topic__partition__t.html">rd_kafka_topic_partition_t</a>* rd_kafka_topic_partition_list_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rktparlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>partition</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add topic+partition to list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rktparlist</em>&nbsp;</td><td>List to extend </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>topic</em>&nbsp;</td><td>Topic name (copied) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>partition</em>&nbsp;</td><td>Partition id</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The object which can be used to fill in additionals fields. </dd></dl>

</div>
</div>
<a class="anchor" id="a6365695de425e7866ddd0c59d704111b"></a><!-- doxytag: member="rdkafka.h::rd_kafka_topic_partition_list_add_range" ref="a6365695de425e7866ddd0c59d704111b" args="(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t start, int32_t stop)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_topic_partition_list_add_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rktparlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>stop</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add range of partitions from <code>start</code> to <code>stop</code> inclusive. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rktparlist</em>&nbsp;</td><td>List to extend </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>topic</em>&nbsp;</td><td>Topic name (copied) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>Start partition of range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stop</em>&nbsp;</td><td>Last partition of range (inclusive) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a94a8195aa5f0195d020494bced858a97"></a><!-- doxytag: member="rdkafka.h::rd_kafka_topic_partition_list_del" ref="a94a8195aa5f0195d020494bced858a97" args="(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_topic_partition_list_del </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rktparlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>partition</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete partition from list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rktparlist</em>&nbsp;</td><td>List to modify </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>topic</em>&nbsp;</td><td>Topic name to match </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>partition</em>&nbsp;</td><td>Partition to match</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if partition was found (and removed), else 0.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Any held indices to elems[] are unusable after this call returns 1. </dd></dl>

</div>
</div>
<a class="anchor" id="a8476ebf3c2f54ddee53e0863feb85463"></a><!-- doxytag: member="rdkafka.h::rd_kafka_topic_partition_list_del_by_idx" ref="a8476ebf3c2f54ddee53e0863feb85463" args="(rd_kafka_topic_partition_list_t *rktparlist, int idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_topic_partition_list_del_by_idx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rktparlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete partition from list by elems[] index. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if partition was found (and removed), else 0.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rdkafka_8h.html#a94a8195aa5f0195d020494bced858a97" title="Delete partition from list.">rd_kafka_topic_partition_list_del()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a66fd3f8c00ffbd0ea740a638dd0a95f7"></a><!-- doxytag: member="rdkafka.h::rd_kafka_topic_partition_list_copy" ref="a66fd3f8c00ffbd0ea740a638dd0a95f7" args="(const rd_kafka_topic_partition_list_t *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a>* rd_kafka_topic_partition_list_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a copy of an existing list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The existing list to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new list fully populated to be identical to <code>src</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a102b340b901babb247d2c0a8580a094d"></a><!-- doxytag: member="rdkafka.h::rd_kafka_topic_partition_list_set_offset" ref="a102b340b901babb247d2c0a8580a094d" args="(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition, int64_t offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_topic_partition_list_set_offset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rktparlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set offset to <code>offset</code> for <code>topic</code> and <code>partition</code>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION if <code>partition</code> was not found in the list. </dd></dl>

</div>
</div>
<a class="anchor" id="ab25d8e4e58c891bdc533471c210697fa"></a><!-- doxytag: member="rdkafka.h::rd_kafka_topic_partition_list_find" ref="ab25d8e4e58c891bdc533471c210697fa" args="(rd_kafka_topic_partition_list_t *rktparlist, const char *topic, int32_t partition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="structrd__kafka__topic__partition__t.html">rd_kafka_topic_partition_t</a>* rd_kafka_topic_partition_list_find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rktparlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>partition</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find element by <code>topic</code> and <code>partition</code>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the first matching element, or NULL if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="ab72ed92794eabf2e7ba1b7be9c94de1f"></a><!-- doxytag: member="rdkafka.h::rd_kafka_topic_partition_list_sort" ref="ab72ed92794eabf2e7ba1b7be9c94de1f" args="(rd_kafka_topic_partition_list_t *rktparlist, int(*cmp)(const void *a, const void *b, void *opaque), void *opaque)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_topic_partition_list_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rktparlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *a, const void *b, void *opaque)&nbsp;</td>
          <td class="paramname"> <em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>opaque</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sort list using comparator <code>cmp</code>. </p>
<p>If <code>cmp</code> is NULL the default comparator will be used that sorts by ascending topic name and partition. </p>

</div>
</div>
<a class="anchor" id="a9fdd55ee90816f38324f5d0af1b4fc1f"></a><!-- doxytag: member="rdkafka.h::rd_kafka_headers_new" ref="a9fdd55ee90816f38324f5d0af1b4fc1f" args="(size_t initial_count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT rd_kafka_headers_t* rd_kafka_headers_new </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>initial_count</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new headers list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>initial_count</em>&nbsp;</td><td>Preallocate space for this number of headers. Any number of headers may be added, updated and removed regardless of the initial count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad86e25f9787e647588fc2067705de10e"></a><!-- doxytag: member="rdkafka.h::rd_kafka_header_add" ref="ad86e25f9787e647588fc2067705de10e" args="(rd_kafka_headers_t *hdrs, const char *name, ssize_t name_size, const void *value, ssize_t value_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_header_add </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_headers_t *&nbsp;</td>
          <td class="paramname"> <em>hdrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&nbsp;</td>
          <td class="paramname"> <em>name_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&nbsp;</td>
          <td class="paramname"> <em>value_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add header with name <code>name</code> and value <code>val</code> (copied) of size <code>size</code> (not including null-terminator). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Header name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name_size</em>&nbsp;</td><td>Header name size (not including the null-terminator). If -1 the <code>name</code> length is automatically acquired using strlen(). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Pointer to header value, or NULL (set size to 0 or -1). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value_size</em>&nbsp;</td><td>Size of header value. If -1 the <code>value</code> is assumed to be a null-terminated string and the length is automatically acquired using strlen().</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RD_KAFKA_RESP_ERR__READ_ONLY if the headers are read-only, else RD_KAFKA_RESP_ERR_NO_ERROR. </dd></dl>

</div>
</div>
<a class="anchor" id="a8a8d23d274cf233b6b4b0a345c0180c1"></a><!-- doxytag: member="rdkafka.h::rd_kafka_header_remove" ref="a8a8d23d274cf233b6b4b0a345c0180c1" args="(rd_kafka_headers_t *hdrs, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_header_remove </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_headers_t *&nbsp;</td>
          <td class="paramname"> <em>hdrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove all headers for the given key (if any). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>RD_KAFKA_RESP_ERR__READ_ONLY if the headers are read-only, RD_KAFKA_RESP_ERR__NOENT if no matching headers were found, else RD_KAFKA_RESP_ERR_NO_ERROR if headers were removed. </dd></dl>

</div>
</div>
<a class="anchor" id="a6cb8628d390cd89a6d9daada8c70161a"></a><!-- doxytag: member="rdkafka.h::rd_kafka_header_get_last" ref="a6cb8628d390cd89a6d9daada8c70161a" args="(const rd_kafka_headers_t *hdrs, const char *name, const void **valuep, size_t *sizep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_header_get_last </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_headers_t *&nbsp;</td>
          <td class="paramname"> <em>hdrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **&nbsp;</td>
          <td class="paramname"> <em>valuep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>sizep</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find last header in list <code>hdrs</code> matching <code>name</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Header to find (last match). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>valuep</em>&nbsp;</td><td>(out) Set to a (null-terminated) const pointer to the value (may be NULL). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sizep</em>&nbsp;</td><td>(out) Set to the value's size (not including null-terminator).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR if an entry was found, else RD_KAFKA_RESP_ERR__NOENT.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The returned pointer in <code>valuep</code> includes a trailing null-terminator that is not accounted for in <code>sizep</code>. </dd>
<dd>
The returned pointer is only valid as long as the headers list and the header item is valid. </dd></dl>

</div>
</div>
<a class="anchor" id="a5cf2d5ce4869203aaa9e18ad2c763bbf"></a><!-- doxytag: member="rdkafka.h::rd_kafka_header_get" ref="a5cf2d5ce4869203aaa9e18ad2c763bbf" args="(const rd_kafka_headers_t *hdrs, size_t idx, const char *name, const void **valuep, size_t *sizep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_header_get </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_headers_t *&nbsp;</td>
          <td class="paramname"> <em>hdrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **&nbsp;</td>
          <td class="paramname"> <em>valuep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>sizep</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterator for headers matching <code>name</code>. </p>
<p>Same semantics as <a class="el" href="rdkafka_8h.html#a6cb8628d390cd89a6d9daada8c70161a" title="Find last header in list hdrs matching name.">rd_kafka_header_get_last()</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hdrs</em>&nbsp;</td><td>Headers to iterate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>idx</em>&nbsp;</td><td>Iterator index, start at 0 and increment by one for each call as long as RD_KAFKA_RESP_ERR_NO_ERROR is returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Header name to match. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>valuep</em>&nbsp;</td><td>(out) Set to a (null-terminated) const pointer to the value (may be NULL). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sizep</em>&nbsp;</td><td>(out) Set to the value's size (not including null-terminator). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a39136e1d13591f668158c0fa20961b"></a><!-- doxytag: member="rdkafka.h::rd_kafka_header_get_all" ref="a3a39136e1d13591f668158c0fa20961b" args="(const rd_kafka_headers_t *hdrs, size_t idx, const char **namep, const void **valuep, size_t *sizep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_header_get_all </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_headers_t *&nbsp;</td>
          <td class="paramname"> <em>hdrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>namep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **&nbsp;</td>
          <td class="paramname"> <em>valuep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>sizep</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterator for all headers. </p>
<p>Same semantics as <a class="el" href="rdkafka_8h.html#a5cf2d5ce4869203aaa9e18ad2c763bbf" title="Iterator for headers matching name.">rd_kafka_header_get()</a></p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rdkafka_8h.html#a5cf2d5ce4869203aaa9e18ad2c763bbf" title="Iterator for headers matching name.">rd_kafka_header_get()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a929ad59ee41ceb4e2f36c8212a5a54ec"></a><!-- doxytag: member="rdkafka.h::rd_kafka_message_errstr" ref="a929ad59ee41ceb4e2f36c8212a5a54ec" args="(const rd_kafka_message_t *rkmessage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static RD_INLINE const char* RD_UNUSED rd_kafka_message_errstr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rkmessage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the error string for an errored <a class="el" href="structrd__kafka__message__t.html" title="A Kafka message as returned by the rd_kafka_consume*() family of functions as well...">rd_kafka_message_t</a> or NULL if there was no error. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This function MUST NOT be used with the producer. </dd></dl>

</div>
</div>
<a class="anchor" id="a4371deba4afe6941cc5f9e80df5ca3e7"></a><!-- doxytag: member="rdkafka.h::rd_kafka_message_timestamp" ref="a4371deba4afe6941cc5f9e80df5ca3e7" args="(const rd_kafka_message_t *rkmessage, rd_kafka_timestamp_type_t *tstype)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int64_t rd_kafka_message_timestamp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rkmessage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rdkafka_8h.html#af7cb459a230a61489234823da2beb3f3">rd_kafka_timestamp_type_t</a> *&nbsp;</td>
          <td class="paramname"> <em>tstype</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the message timestamp for a consumed message. </p>
<p>The timestamp is the number of milliseconds since the epoch (UTC).</p>
<p><code>tstype</code> (if not NULL) is updated to indicate the type of timestamp.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>message timestamp, or -1 if not available.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Message timestamps require broker version 0.10.0 or later. </dd></dl>

</div>
</div>
<a class="anchor" id="aba20435b42efef7a3c38dee3fb58c27b"></a><!-- doxytag: member="rdkafka.h::rd_kafka_message_latency" ref="aba20435b42efef7a3c38dee3fb58c27b" args="(const rd_kafka_message_t *rkmessage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int64_t rd_kafka_message_latency </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rkmessage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the latency for a produced message measured from the produce() call. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the latency in microseconds, or -1 if not available. </dd></dl>

</div>
</div>
<a class="anchor" id="aaccd9ee7e1c73b89d86ed41db3b86e68"></a><!-- doxytag: member="rdkafka.h::rd_kafka_message_headers" ref="aaccd9ee7e1c73b89d86ed41db3b86e68" args="(const rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_message_headers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rkmessage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rd_kafka_headers_t **&nbsp;</td>
          <td class="paramname"> <em>hdrsp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the message header list. </p>
<p>The returned pointer in <code>*hdrsp</code> is associated with the <code>rkmessage</code> and must not be used after destruction of the message object or the header list is replaced with <a class="el" href="rdkafka_8h.html#a99e46233e57fc4f5783d8ae374584bbe" title="Replace the message&#39;s current headers with a new list.">rd_kafka_message_set_headers()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR if headers were returned, RD_KAFKA_RESP_ERR__NOENT if the message has no headers, or another error code if the headers could not be parsed.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Headers require broker version 0.11.0.0 or later.</dd>
<dd>
As an optimization the raw protocol headers are parsed on the first call to this function. </dd></dl>

</div>
</div>
<a class="anchor" id="af89ef912d3c1ff66ea612fda27c0a643"></a><!-- doxytag: member="rdkafka.h::rd_kafka_message_detach_headers" ref="af89ef912d3c1ff66ea612fda27c0a643" args="(rd_kafka_message_t *rkmessage, rd_kafka_headers_t **hdrsp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_message_detach_headers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rkmessage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rd_kafka_headers_t **&nbsp;</td>
          <td class="paramname"> <em>hdrsp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the message header list and detach the list from the message making the application the owner of the headers. The application must eventually destroy the headers using <a class="el" href="rdkafka_8h.html#aa31d7a8707a729839e54422ca976d8b1" title="Destroy the headers list. The object and any returned value pointers are not usable...">rd_kafka_headers_destroy()</a>. The message's headers will be set to NULL. </p>
<p>Otherwise same semantics as <a class="el" href="rdkafka_8h.html#aaccd9ee7e1c73b89d86ed41db3b86e68" title="Get the message header list.">rd_kafka_message_headers()</a></p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rdkafka_8h.html#aaccd9ee7e1c73b89d86ed41db3b86e68" title="Get the message header list.">rd_kafka_message_headers</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a99e46233e57fc4f5783d8ae374584bbe"></a><!-- doxytag: member="rdkafka.h::rd_kafka_message_set_headers" ref="a99e46233e57fc4f5783d8ae374584bbe" args="(rd_kafka_message_t *rkmessage, rd_kafka_headers_t *hdrs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_message_set_headers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rkmessage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rd_kafka_headers_t *&nbsp;</td>
          <td class="paramname"> <em>hdrs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replace the message's current headers with a new list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hdrs</em>&nbsp;</td><td>New header list. The message object assumes ownership of the list, the list will be destroyed automatically with the message object. The new headers list may be updated until the message object is passed or returned to librdkafka.</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The existing headers object, if any, will be destroyed. </dd></dl>

</div>
</div>
<a class="anchor" id="af8ce5228eef3ea0a9209965902b6fcdd"></a><!-- doxytag: member="rdkafka.h::rd_kafka_header_cnt" ref="af8ce5228eef3ea0a9209965902b6fcdd" args="(const rd_kafka_headers_t *hdrs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT size_t rd_kafka_header_cnt </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_headers_t *&nbsp;</td>
          <td class="paramname"> <em>hdrs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of header key/value pairs. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hdrs</em>&nbsp;</td><td>Headers to count </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa7459bd22e8cfa81aa8c2480a4a0304c"></a><!-- doxytag: member="rdkafka.h::rd_kafka_conf_new" ref="aa7459bd22e8cfa81aa8c2480a4a0304c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT rd_kafka_conf_t* rd_kafka_conf_new </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create configuration object. </p>
<p>When providing your own configuration to the <code>rd_kafka_*_new_*</code>() calls the rd_kafka_conf_t objects needs to be created with this function which will set up the defaults. I.e.: </p>
<div class="fragment"><pre class="fragment">   rd_kafka_conf_t *myconf;
   <a class="code" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4" title="Configuration result type.">rd_kafka_conf_res_t</a> res;

   myconf = <a class="code" href="rdkafka_8h.html#aa7459bd22e8cfa81aa8c2480a4a0304c" title="Create configuration object.">rd_kafka_conf_new</a>();
   res = <a class="code" href="rdkafka_8h.html#abb1b319278333e8cdee9442da7f135e8" title="Sets a configuration property.">rd_kafka_conf_set</a>(myconf, <span class="stringliteral">&quot;socket.timeout.ms&quot;</span>, <span class="stringliteral">&quot;600&quot;</span>,
                           errstr, <span class="keyword">sizeof</span>(errstr));
   <span class="keywordflow">if</span> (res != <a class="code" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4a12343fa082ab52164a17130d6b0d0f5b">RD_KAFKA_CONF_OK</a>)
      die(<span class="stringliteral">&quot;%s\n&quot;</span>, errstr);
   
   rk = <a class="code" href="rdkafka_8h.html#a63d5cd86ab1f77772b2be170e1c09c24" title="Creates a new Kafka handle and starts its operation according to the specified type...">rd_kafka_new</a>(..., myconf);
</pre></div><p>Please see CONFIGURATION.md for the default settings or use <a class="el" href="rdkafka_8h.html#aa52f3a5a08207e14386739fe336e57be" title="Prints a table to fp of all supported configuration properties, their default values...">rd_kafka_conf_properties_show()</a> to provide the information at runtime.</p>
<p>The properties are identical to the Apache Kafka configuration properties whenever possible.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new rd_kafka_conf_t object with defaults set.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rdkafka_8h.html#abb1b319278333e8cdee9442da7f135e8" title="Sets a configuration property.">rd_kafka_conf_set()</a>, <a class="el" href="rdkafka_8h.html#af3669dacf78c5c0eb536d65cb45d0491" title="Destroys a conf object.">rd_kafka_conf_destroy()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8cbfe15c6978ff09870e82cb524c673d"></a><!-- doxytag: member="rdkafka.h::rd_kafka_conf_dup" ref="a8cbfe15c6978ff09870e82cb524c673d" args="(const rd_kafka_conf_t *conf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT rd_kafka_conf_t* rd_kafka_conf_dup </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_conf_t *&nbsp;</td>
          <td class="paramname"> <em>conf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a copy/duplicate of configuration object <code>conf</code>. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Interceptors are NOT copied to the new configuration object. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>rd_kafka_interceptor_f_on_conf_dup </dd></dl>

</div>
</div>
<a class="anchor" id="abb1b319278333e8cdee9442da7f135e8"></a><!-- doxytag: member="rdkafka.h::rd_kafka_conf_set" ref="abb1b319278333e8cdee9442da7f135e8" args="(rd_kafka_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a> rd_kafka_conf_set </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>errstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>errstr_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a configuration property. </p>
<p><code>conf</code> must have been previously created with <a class="el" href="rdkafka_8h.html#aa7459bd22e8cfa81aa8c2480a4a0304c" title="Create configuration object.">rd_kafka_conf_new()</a>.</p>
<p>Fallthrough: Topic-level configuration properties may be set using this interface in which case they are applied on the <code>default_topic_conf</code>. If no <code>default_topic_conf</code> has been set one will be created. Any sub-sequent <a class="el" href="rdkafka_8h.html#a138aa4881c8703dd6b69f22ddc454f63">rd_kafka_conf_set_default_topic_conf()</a> calls will replace the current default topic configuration.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>rd_kafka_conf_res_t</code> to indicate success or failure. In case of failure <code>errstr</code> is updated to contain a human readable error string. </dd></dl>

</div>
</div>
<a class="anchor" id="a075b15c4141784fdc271de217005a41f"></a><!-- doxytag: member="rdkafka.h::rd_kafka_conf_set_dr_cb" ref="a075b15c4141784fdc271de217005a41f" args="(rd_kafka_conf_t *conf, void(*dr_cb)(rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_dr_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(rd_kafka_t *rk, void *payload, size_t len, <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> err, void *opaque, void *msg_opaque)&nbsp;</td>
          <td class="paramname"> <em>dr_cb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>See <a class="el" href="rdkafka_8h.html#ac1c9946aee26e10de2661fcf2242ea8a" title="Producer: Set delivery report callback in provided conf object.">rd_kafka_conf_set_dr_msg_cb()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac1c9946aee26e10de2661fcf2242ea8a"></a><!-- doxytag: member="rdkafka.h::rd_kafka_conf_set_dr_msg_cb" ref="ac1c9946aee26e10de2661fcf2242ea8a" args="(rd_kafka_conf_t *conf, void(*dr_msg_cb)(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, void *opaque))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_dr_msg_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(rd_kafka_t *rk, const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, void *opaque)&nbsp;</td>
          <td class="paramname"> <em>dr_msg_cb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Producer:</b> Set delivery report callback in provided <code>conf</code> object. </p>
<p>The delivery report callback will be called once for each message accepted by <a class="el" href="rdkafka_8h.html#ae24d8ebf1ea15ed8ea0ea40f74662736" title="Produce and send a single message to broker.">rd_kafka_produce()</a> (et.al) with <code>err</code> set to indicate the result of the produce request.</p>
<p>The callback is called when a message is succesfully produced or if librdkafka encountered a permanent failure, or the retry counter for temporary errors has been exhausted.</p>
<p>An application must call <a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4" title="Polls the provided kafka handle for events.">rd_kafka_poll()</a> at regular intervals to serve queued delivery report callbacks. </p>

</div>
</div>
<a class="anchor" id="a10db731dc1a295bd9884e4f8cb199311"></a><!-- doxytag: member="rdkafka.h::rd_kafka_conf_set_rebalance_cb" ref="a10db731dc1a295bd9884e4f8cb199311" args="(rd_kafka_conf_t *conf, void(*rebalance_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_rebalance_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(rd_kafka_t *rk, <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> err, <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *partitions, void *opaque)&nbsp;</td>
          <td class="paramname"> <em>rebalance_cb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Consumer:</b> Set rebalance callback for use with coordinated consumer group balancing. </p>
<p>The <code>err</code> field is set to either RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS or RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS and 'partitions' contains the full partition set that was either assigned or revoked.</p>
<p>Registering a <code>rebalance_cb</code> turns off librdkafka's automatic partition assignment/revocation and instead delegates that responsibility to the application's <code>rebalance_cb</code>.</p>
<p>The rebalance callback is responsible for updating librdkafka's assignment set based on the two events: RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS and RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS but should also be able to handle arbitrary rebalancing failures where <code>err</code> is neither of those. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>In this latter case (arbitrary error), the application must call rd_kafka_assign(rk, NULL) to synchronize state.</dd></dl>
<p>Without a rebalance callback this is done automatically by librdkafka but registering a rebalance callback gives the application flexibility in performing other operations along with the assinging/revocation, such as fetching offsets from an alternate location (on assign) or manually committing offsets (on revoke).</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The <code>partitions</code> list is destroyed by librdkafka on return return from the rebalance_cb and must not be freed or saved by the application.</dd></dl>
<p>The following example shows the application's responsibilities: </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">static</span> <span class="keywordtype">void</span> rebalance_cb (rd_kafka_t *rk, <a class="code" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb" title="Error codes.">rd_kafka_resp_err_t</a> <a class="code" href="structrd__kafka__group__info.html#ad8ad977cc6c3d8bd053afdc88876fd31">err</a>,
                              <a class="code" href="structrd__kafka__topic__partition__list__t.html" title="A growable list of Topic+Partitions.">rd_kafka_topic_partition_list_t</a> *partitions,
                              <span class="keywordtype">void</span> *opaque) {

        <span class="keywordflow">switch</span> (err)
        {
          <span class="keywordflow">case</span> <a class="code" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba4eab145a6f57f455bdde22cb94b61e90">RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS</a>:
             <span class="comment">// application may load offets from arbitrary external</span>
             <span class="comment">// storage here and update \p partitions</span>

             <a class="code" href="rdkafka_8h.html#a0566419eff2001f8371e3b50aa7d26e9" title="Atomic assignment of partitions to consume.">rd_kafka_assign</a>(rk, partitions);
             <span class="keywordflow">break</span>;

          <span class="keywordflow">case</span> <a class="code" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cba52a7ba59b755f419beec0433cb1633bb">RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS</a>:
             <span class="keywordflow">if</span> (manual_commits) <span class="comment">// Optional explicit manual commit</span>
                 <a class="code" href="rdkafka_8h.html#ab96539928328f14c3c9177ea0c896c87" title="Commit offsets on broker for the provided list of partitions.">rd_kafka_commit</a>(rk, partitions, 0); <span class="comment">// sync commit</span>

             <a class="code" href="rdkafka_8h.html#a0566419eff2001f8371e3b50aa7d26e9" title="Atomic assignment of partitions to consume.">rd_kafka_assign</a>(rk, NULL);
             <span class="keywordflow">break</span>;

          <span class="keywordflow">default</span>:
             handle_unlikely_error(err);
             <a class="code" href="rdkafka_8h.html#a0566419eff2001f8371e3b50aa7d26e9" title="Atomic assignment of partitions to consume.">rd_kafka_assign</a>(rk, NULL); <span class="comment">// sync state</span>
             <span class="keywordflow">break</span>;
         }
    }
</pre></div> 
</div>
</div>
<a class="anchor" id="a1ab8bb9e8d8cdd5906f9e060b506f2eb"></a><!-- doxytag: member="rdkafka.h::rd_kafka_conf_set_offset_commit_cb" ref="a1ab8bb9e8d8cdd5906f9e060b506f2eb" args="(rd_kafka_conf_t *conf, void(*offset_commit_cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_offset_commit_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(rd_kafka_t *rk, <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> err, <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *offsets, void *opaque)&nbsp;</td>
          <td class="paramname"> <em>offset_commit_cb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Consumer:</b> Set offset commit callback for use with consumer groups. </p>
<p>The results of automatic or manual offset commits will be scheduled for this callback and is served by <a class="el" href="rdkafka_8h.html#a65cc6cb9bd72c4084f074af0361ceddf" title="Poll the consumer for messages or events.">rd_kafka_consumer_poll()</a>.</p>
<p>If no partitions had valid offsets to commit this callback will be called with <code>err</code> == RD_KAFKA_RESP_ERR__NO_OFFSET which is not to be considered an error.</p>
<p>The <code>offsets</code> list contains per-partition information:</p>
<ul>
<li><code>offset:</code> committed offset (attempted)</li>
<li><code>err:</code> commit error </li>
</ul>

</div>
</div>
<a class="anchor" id="ace721ef3b7c22d0c111ec747ef039a90"></a><!-- doxytag: member="rdkafka.h::rd_kafka_conf_set_error_cb" ref="ace721ef3b7c22d0c111ec747ef039a90" args="(rd_kafka_conf_t *conf, void(*error_cb)(rd_kafka_t *rk, int err, const char *reason, void *opaque))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_error_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(rd_kafka_t *rk, int err, const char *reason, void *opaque)&nbsp;</td>
          <td class="paramname"> <em>error_cb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set error callback in provided conf object. </p>
<p>The error callback is used by librdkafka to signal critical errors back to the application.</p>
<p>If no <code>error_cb</code> is registered then the errors will be logged instead. </p>

</div>
</div>
<a class="anchor" id="a04160826ad039d42c10edec456163fa7"></a><!-- doxytag: member="rdkafka.h::rd_kafka_conf_set_throttle_cb" ref="a04160826ad039d42c10edec456163fa7" args="(rd_kafka_conf_t *conf, void(*throttle_cb)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_throttle_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(rd_kafka_t *rk, const char *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque)&nbsp;</td>
          <td class="paramname"> <em>throttle_cb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set throttle callback. </p>
<p>The throttle callback is used to forward broker throttle times to the application for Produce and Fetch (consume) requests.</p>
<p>Callbacks are triggered whenever a non-zero throttle time is returned by the broker, or when the throttle time drops back to zero.</p>
<p>An application must call <a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4" title="Polls the provided kafka handle for events.">rd_kafka_poll()</a> or <a class="el" href="rdkafka_8h.html#a65cc6cb9bd72c4084f074af0361ceddf" title="Poll the consumer for messages or events.">rd_kafka_consumer_poll()</a> at regular intervals to serve queued callbacks.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Requires broker version 0.9.0 or later. </dd></dl>

</div>
</div>
<a class="anchor" id="a06ade2ca41f32eb82c6f7e3d4acbe19f"></a><!-- doxytag: member="rdkafka.h::rd_kafka_conf_set_log_cb" ref="a06ade2ca41f32eb82c6f7e3d4acbe19f" args="(rd_kafka_conf_t *conf, void(*log_cb)(const rd_kafka_t *rk, int level, const char *fac, const char *buf))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_log_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)&nbsp;</td>
          <td class="paramname"> <em>log_cb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set logger callback. </p>
<p>The default is to print to stderr, but a syslog logger is also available, see rd_kafka_log_print and rd_kafka_log_syslog for the builtin alternatives. Alternatively the application may provide its own logger callback. Or pass <code>func</code> as NULL to disable logging.</p>
<p>This is the configuration alternative to the deprecated <a class="el" href="rdkafka_8h.html#a9e4af9adee414af74c7817403f7c4a53" title="Set logger function.">rd_kafka_set_logger()</a></p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The log_cb will be called spontaneously from librdkafka's internal threads unless logs have been forwarded to a poll queue through <code><a class="el" href="rdkafka_8h.html#a5c8a3be2f797560b2a39bf56dbd7622d" title="Forward librdkafka logs (and debug) to the specified queue for serving with one of...">rd_kafka_set_log_queue()</a></code>. An application MUST NOT call any librdkafka APIs or do any prolonged work in a non-forwarded <code>log_cb</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a597d00432e3ca22174d18e7e348fb766"></a><!-- doxytag: member="rdkafka.h::rd_kafka_conf_set_stats_cb" ref="a597d00432e3ca22174d18e7e348fb766" args="(rd_kafka_conf_t *conf, int(*stats_cb)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_stats_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(rd_kafka_t *rk, char *json, size_t json_len, void *opaque)&nbsp;</td>
          <td class="paramname"> <em>stats_cb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set statistics callback in provided conf object. </p>
<p>The statistics callback is triggered from <a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4" title="Polls the provided kafka handle for events.">rd_kafka_poll()</a> every <code>statistics.interval.ms</code> (needs to be configured separately). Function arguments:</p>
<ul>
<li><code>rk</code> - Kafka handle</li>
<li><code>json</code> - String containing the statistics data in JSON format</li>
<li><code>json_len</code> - Length of <code>json</code> string.</li>
<li><code>opaque</code> - Application-provided opaque.</li>
</ul>
<p>If the application wishes to hold on to the <code>json</code> pointer and free it at a later time it must return 1 from the <code>stats_cb</code>. If the application returns 0 from the <code>stats_cb</code> then librdkafka will immediately free the <code>json</code> pointer. </p>

</div>
</div>
<a class="anchor" id="a0467a6c20d5af69a29a63b530962ecbf"></a><!-- doxytag: member="rdkafka.h::rd_kafka_conf_set_socket_cb" ref="a0467a6c20d5af69a29a63b530962ecbf" args="(rd_kafka_conf_t *conf, int(*socket_cb)(int domain, int type, int protocol, void *opaque))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_socket_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(int domain, int type, int protocol, void *opaque)&nbsp;</td>
          <td class="paramname"> <em>socket_cb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set socket callback. </p>
<p>The socket callback is responsible for opening a socket according to the supplied <code>domain</code>, <code>type</code> and <code>protocol</code>. The socket shall be created with <code>CLOEXEC</code> set in a racefree fashion, if possible.</p>
<p>Default:</p>
<ul>
<li>on linux: racefree CLOEXEC</li>
<li>others : non-racefree CLOEXEC</li>
</ul>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The callback will be called from an internal librdkafka thread. </dd></dl>

</div>
</div>
<a class="anchor" id="a53dd1b77019324170d0168617fdaf040"></a><!-- doxytag: member="rdkafka.h::rd_kafka_conf_set_connect_cb" ref="a53dd1b77019324170d0168617fdaf040" args="(rd_kafka_conf_t *conf, int(*connect_cb)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_connect_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(int sockfd, const struct sockaddr *addr, int addrlen, const char *id, void *opaque)&nbsp;</td>
          <td class="paramname"> <em>connect_cb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set connect callback. </p>
<p>The connect callback is responsible for connecting socket <code>sockfd</code> to peer address <code>addr</code>. The <code>id</code> field contains the broker identifier.</p>
<p><code>connect_cb</code> shall return 0 on success (socket connected) or an error number (errno) on error.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The callback will be called from an internal librdkafka thread. </dd></dl>

</div>
</div>
<a class="anchor" id="ab55c7ddc46a354e3f57b5b209e5ec3c7"></a><!-- doxytag: member="rdkafka.h::rd_kafka_conf_set_closesocket_cb" ref="ab55c7ddc46a354e3f57b5b209e5ec3c7" args="(rd_kafka_conf_t *conf, int(*closesocket_cb)(int sockfd, void *opaque))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_closesocket_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(int sockfd, void *opaque)&nbsp;</td>
          <td class="paramname"> <em>closesocket_cb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set close socket callback. </p>
<p>Close a socket (optionally opened with socket_cb()).</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The callback will be called from an internal librdkafka thread. </dd></dl>

</div>
</div>
<a class="anchor" id="a467bb7b1ac070fee536227d6ae9cc551"></a><!-- doxytag: member="rdkafka.h::rd_kafka_conf_set_open_cb" ref="a467bb7b1ac070fee536227d6ae9cc551" args="(rd_kafka_conf_t *conf, int(*open_cb)(const char *pathname, int flags, mode_t mode, void *opaque))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_open_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const char *pathname, int flags, mode_t mode, void *opaque)&nbsp;</td>
          <td class="paramname"> <em>open_cb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set open callback. </p>
<p>The open callback is responsible for opening the file specified by pathname, flags and mode. The file shall be opened with <code>CLOEXEC</code> set in a racefree fashion, if possible.</p>
<p>Default:</p>
<ul>
<li>on linux: racefree CLOEXEC</li>
<li>others : non-racefree CLOEXEC</li>
</ul>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The callback will be called from an internal librdkafka thread. </dd></dl>

</div>
</div>
<a class="anchor" id="a138aa4881c8703dd6b69f22ddc454f63"></a><!-- doxytag: member="rdkafka.h::rd_kafka_conf_set_default_topic_conf" ref="a138aa4881c8703dd6b69f22ddc454f63" args="(rd_kafka_conf_t *conf, rd_kafka_topic_conf_t *tconf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_conf_set_default_topic_conf </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rd_kafka_topic_conf_t *&nbsp;</td>
          <td class="paramname"> <em>tconf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the default topic configuration to use for automatically subscribed topics (e.g., through pattern-matched topics). The topic config object is not usable after this call. </p>

</div>
</div>
<a class="anchor" id="abe9f0f77e9145eb1a62c3258ac495b97"></a><!-- doxytag: member="rdkafka.h::rd_kafka_conf_get" ref="abe9f0f77e9145eb1a62c3258ac495b97" args="(const rd_kafka_conf_t *conf, const char *name, char *dest, size_t *dest_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a> rd_kafka_conf_get </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_conf_t *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>dest_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve configuration value for property <code>name</code>. </p>
<p>If <code>dest</code> is non-NULL the value will be written to <code>dest</code> with at most <code>dest_size</code>.</p>
<p><code>*dest_size</code> is updated to the full length of the value, thus if <code>*dest_size</code> initially is smaller than the full length the application may reallocate <code>dest</code> to fit the returned <code>*dest_size</code> and try again.</p>
<p>If <code>dest</code> is NULL only the full length of the value is returned.</p>
<p>Fallthrough: Topic-level configuration properties from the <code>default_topic_conf</code> may be retrieved using this interface.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>RD_KAFKA_CONF_OK</code> if the property name matched, else <code>RD_KAFKA_CONF_UNKNOWN</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a56939e7f77106b9e810d59289443e25d"></a><!-- doxytag: member="rdkafka.h::rd_kafka_topic_conf_get" ref="a56939e7f77106b9e810d59289443e25d" args="(const rd_kafka_topic_conf_t *conf, const char *name, char *dest, size_t *dest_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a> rd_kafka_topic_conf_get </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_topic_conf_t *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>dest_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve topic configuration value for property <code>name</code>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rdkafka_8h.html#abe9f0f77e9145eb1a62c3258ac495b97" title="Retrieve configuration value for property name.">rd_kafka_conf_get()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6eba851c2af748de6921d708b47dc94c"></a><!-- doxytag: member="rdkafka.h::rd_kafka_conf_dump" ref="a6eba851c2af748de6921d708b47dc94c" args="(rd_kafka_conf_t *conf, size_t *cntp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT const char** rd_kafka_conf_dump </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>cntp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dump the configuration properties and values of <code>conf</code> to an array with \"key\", \"value\" pairs. </p>
<p>The number of entries in the array is returned in <code>*cntp</code>.</p>
<p>The dump must be freed with `rd_kafka_conf_dump_free()`. </p>

</div>
</div>
<a class="anchor" id="a40a7a88bd5ac81b21c45d1fdd4d9e696"></a><!-- doxytag: member="rdkafka.h::rd_kafka_topic_conf_dump" ref="a40a7a88bd5ac81b21c45d1fdd4d9e696" args="(rd_kafka_topic_conf_t *conf, size_t *cntp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT const char** rd_kafka_topic_conf_dump </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_conf_t *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>cntp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dump the topic configuration properties and values of <code>conf</code> to an array with \"key\", \"value\" pairs. </p>
<p>The number of entries in the array is returned in <code>*cntp</code>.</p>
<p>The dump must be freed with `rd_kafka_conf_dump_free()`. </p>

</div>
</div>
<a class="anchor" id="a1a7032f87e7d868b80e38d0fd0ad119e"></a><!-- doxytag: member="rdkafka.h::rd_kafka_topic_conf_new" ref="a1a7032f87e7d868b80e38d0fd0ad119e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT rd_kafka_topic_conf_t* rd_kafka_topic_conf_new </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create topic configuration object. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>Same semantics as for <a class="el" href="rdkafka_8h.html#aa7459bd22e8cfa81aa8c2480a4a0304c" title="Create configuration object.">rd_kafka_conf_new()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ac91b47f7733b324bf4159427e90ccd01"></a><!-- doxytag: member="rdkafka.h::rd_kafka_topic_conf_set" ref="ac91b47f7733b324bf4159427e90ccd01" args="(rd_kafka_topic_conf_t *conf, const char *name, const char *value, char *errstr, size_t errstr_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#ad8306a08e59e8e2cbc6abdb84f9689f4">rd_kafka_conf_res_t</a> rd_kafka_topic_conf_set </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_conf_t *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>errstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>errstr_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a single rd_kafka_topic_conf_t value by property name. </p>
<p><code>topic_conf</code> should have been previously set up with `rd_kafka_topic_conf_new()`.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>rd_kafka_conf_res_t to indicate success or failure. </dd></dl>

</div>
</div>
<a class="anchor" id="abfc790b5e36c56ea6d79fdc32c57becf"></a><!-- doxytag: member="rdkafka.h::rd_kafka_topic_conf_set_partitioner_cb" ref="abfc790b5e36c56ea6d79fdc32c57becf" args="(rd_kafka_topic_conf_t *topic_conf, int32_t(*partitioner)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_topic_conf_set_partitioner_cb </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_conf_t *&nbsp;</td>
          <td class="paramname"> <em>topic_conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t(*)(const rd_kafka_topic_t *rkt, const void *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)&nbsp;</td>
          <td class="paramname"> <em>partitioner</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Producer:</b> Set partitioner callback in provided topic conf object. </p>
<p>The partitioner may be called in any thread at any time, it may be called multiple times for the same message/key.</p>
<p>Partitioner function constraints:</p>
<ul>
<li>MUST NOT call any rd_kafka_*() functions except: <a class="el" href="rdkafka_8h.html#ad24c6cc7f37271e292f8105c64d77758" title="Check if partition is available (has a leader broker).">rd_kafka_topic_partition_available()</a></li>
<li>MUST NOT block or execute for prolonged periods of time.</li>
<li>MUST return a value between 0 and partition_cnt-1, or the special <code>RD_KAFKA_PARTITION_UA</code> value if partitioning could not be performed. </li>
</ul>

</div>
</div>
<a class="anchor" id="a760cee234c441d32f9421874a74e06d4"></a><!-- doxytag: member="rdkafka.h::rd_kafka_topic_conf_set_msg_order_cmp" ref="a760cee234c441d32f9421874a74e06d4" args="(rd_kafka_topic_conf_t *topic_conf, int(*msg_order_cmp)(const rd_kafka_message_t *a, const rd_kafka_message_t *b))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_topic_conf_set_msg_order_cmp </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_conf_t *&nbsp;</td>
          <td class="paramname"> <em>topic_conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *a, const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *b)&nbsp;</td>
          <td class="paramname"> <em>msg_order_cmp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><b>Producer:</b> Set message queueing order comparator callback. </p>
<p>The callback may be called in any thread at any time, it may be called multiple times for the same message.</p>
<p>Ordering comparator function constraints:</p>
<ul>
<li>MUST be stable sort (same input gives same output).</li>
<li>MUST NOT call any rd_kafka_*() functions.</li>
<li>MUST NOT block or execute for prolonged periods of time.</li>
</ul>
<p>The comparator shall compare the two messages and return:</p>
<ul>
<li>&lt; 0 if message <code>a</code> should be inserted before message <code>b</code>.</li>
<li>&gt;=0 if message <code>a</code> should be inserted after message <code>b</code>.</li>
</ul>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Insert sorting will be used to enqueue the message in the correct queue position, this comes at a cost of O(n).</dd>
<dd>
If `queuing.strategy=fifo` new messages are enqueued to the tail of the queue regardless of msg_order_cmp, but retried messages are still affected by msg_order_cmp.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>THIS IS AN EXPERIMENTAL API, SUBJECT TO CHANGE OR REMOVAL, DO NOT USE IN PRODUCTION. </dd></dl>

</div>
</div>
<a class="anchor" id="ad24c6cc7f37271e292f8105c64d77758"></a><!-- doxytag: member="rdkafka.h::rd_kafka_topic_partition_available" ref="ad24c6cc7f37271e292f8105c64d77758" args="(const rd_kafka_topic_t *rkt, int32_t partition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_topic_partition_available </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_topic_t *&nbsp;</td>
          <td class="paramname"> <em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>partition</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if partition is available (has a leader broker). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the partition is available, else 0.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This function must only be called from inside a partitioner function </dd></dl>

</div>
</div>
<a class="anchor" id="ae8690da243d6d22f52cf8a6f0e90d7e8"></a><!-- doxytag: member="rdkafka.h::rd_kafka_msg_partitioner_random" ref="ae8690da243d6d22f52cf8a6f0e90d7e8" args="(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int32_t rd_kafka_msg_partitioner_random </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_topic_t *&nbsp;</td>
          <td class="paramname"> <em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>keylen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>partition_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>opaque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>msg_opaque</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Random partitioner. </p>
<p>Will try not to return unavailable partitions.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a random partition between 0 and <code>partition_cnt</code> - 1. </dd></dl>

</div>
</div>
<a class="anchor" id="a09edd9204e8fb28dae7a8b000d4492ef"></a><!-- doxytag: member="rdkafka.h::rd_kafka_msg_partitioner_consistent" ref="a09edd9204e8fb28dae7a8b000d4492ef" args="(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int32_t rd_kafka_msg_partitioner_consistent </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_topic_t *&nbsp;</td>
          <td class="paramname"> <em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>keylen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>partition_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>opaque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>msg_opaque</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Consistent partitioner. </p>
<p>Uses consistent hashing to map identical keys onto identical partitions.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a \"random\" partition between 0 and <code>partition_cnt</code> - 1 based on the CRC value of the key </dd></dl>

</div>
</div>
<a class="anchor" id="a2b79580e110b06ea5434fb71abc0b4eb"></a><!-- doxytag: member="rdkafka.h::rd_kafka_msg_partitioner_consistent_random" ref="a2b79580e110b06ea5434fb71abc0b4eb" args="(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *opaque, void *msg_opaque)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int32_t rd_kafka_msg_partitioner_consistent_random </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_topic_t *&nbsp;</td>
          <td class="paramname"> <em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>keylen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>partition_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>opaque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>msg_opaque</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Consistent-Random partitioner. </p>
<p>This is the default partitioner. Uses consistent hashing to map identical keys onto identical partitions, and messages without keys will be assigned via the random partitioner.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a \"random\" partition between 0 and <code>partition_cnt</code> - 1 based on the CRC value of the key (if provided) </dd></dl>

</div>
</div>
<a class="anchor" id="a009f294dc88a214850760216d3fe2d5f"></a><!-- doxytag: member="rdkafka.h::rd_kafka_msg_partitioner_murmur2" ref="a009f294dc88a214850760216d3fe2d5f" args="(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int32_t rd_kafka_msg_partitioner_murmur2 </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_topic_t *&nbsp;</td>
          <td class="paramname"> <em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>keylen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>partition_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>rkt_opaque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>msg_opaque</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Murmur2 partitioner (Java compatible). </p>
<p>Uses consistent hashing to map identical keys onto identical partitions using Java-compatible Murmur2 hashing.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a partition between 0 and <code>partition_cnt</code> - 1. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5dab15f3d0a293db43338f17544e26a"></a><!-- doxytag: member="rdkafka.h::rd_kafka_msg_partitioner_murmur2_random" ref="ab5dab15f3d0a293db43338f17544e26a" args="(const rd_kafka_topic_t *rkt, const void *key, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int32_t rd_kafka_msg_partitioner_murmur2_random </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_topic_t *&nbsp;</td>
          <td class="paramname"> <em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>keylen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>partition_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>rkt_opaque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>msg_opaque</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Consistent-Random Murmur2 partitioner (Java compatible). </p>
<p>Uses consistent hashing to map identical keys onto identical partitions using Java-compatible Murmur2 hashing. Messages without keys will be assigned via the random partitioner.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a partition between 0 and <code>partition_cnt</code> - 1. </dd></dl>

</div>
</div>
<a class="anchor" id="a63d5cd86ab1f77772b2be170e1c09c24"></a><!-- doxytag: member="rdkafka.h::rd_kafka_new" ref="a63d5cd86ab1f77772b2be170e1c09c24" args="(rd_kafka_type_t type, rd_kafka_conf_t *conf, char *errstr, size_t errstr_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT rd_kafka_t* rd_kafka_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rdkafka_8h.html#ac6f9c3cb01cbaf3013689c4f2731b831">rd_kafka_type_t</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rd_kafka_conf_t *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>errstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>errstr_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new Kafka handle and starts its operation according to the specified <code>type</code> (<code>RD_KAFKA_CONSUMER</code> or <code>RD_KAFKA_PRODUCER</code>). </p>
<p><code>conf</code> is an optional struct created with `rd_kafka_conf_new()` that will be used instead of the default configuration. The <code>conf</code> object is freed by this function on success and must not be used or destroyed by the application sub-sequently. See `rd_kafka_conf_set()` et.al for more information.</p>
<p><code>errstr</code> must be a pointer to memory of at least size <code>errstr_size</code> where `rd_kafka_new()` may write a human readable error message in case the creation of a new handle fails. In which case the function returns NULL.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><b>RD_KAFKA_CONSUMER:</b> When a new <code>RD_KAFKA_CONSUMER</code> rd_kafka_t handle is created it may either operate in the legacy simple consumer mode using the <a class="el" href="rdkafka_8h.html#ae21dcd2d8c6195baf7f9f4952d7e12d4" title="Start consuming messages for topic rkt and partition at offset offset which may either...">rd_kafka_consume_start()</a> interface, or the High-level KafkaConsumer API. </dd>
<dd>
An application must only use one of these groups of APIs on a given rd_kafka_t RD_KAFKA_CONSUMER handle.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The Kafka handle on success or NULL on error (see <code>errstr</code>)</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>To destroy the Kafka handle, use <a class="el" href="rdkafka_8h.html#ac052e92621dcaa3a336dbf826e0d7794" title="Destroy Kafka handle.">rd_kafka_destroy()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ac052e92621dcaa3a336dbf826e0d7794"></a><!-- doxytag: member="rdkafka.h::rd_kafka_destroy" ref="ac052e92621dcaa3a336dbf826e0d7794" args="(rd_kafka_t *rk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_destroy </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy Kafka handle. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is a blocking operation. </dd></dl>

</div>
</div>
<a class="anchor" id="a856d7ecba1aa64e5c89ac92b445cdda6"></a><!-- doxytag: member="rdkafka.h::rd_kafka_memberid" ref="a856d7ecba1aa64e5c89ac92b445cdda6" args="(const rd_kafka_t *rk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT char* rd_kafka_memberid </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns this client's broker-assigned group member id. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This currently requires the high-level KafkaConsumer</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An allocated string containing the current broker-assigned group member id, or NULL if not available. The application must free the string with <code>free()</code> or <a class="el" href="rdkafka_8h.html#a50178b3d3266c9eeb0b5981377833572" title="Free pointer returned by librdkafka.">rd_kafka_mem_free()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a261ba8c649756fbc7fbcd442ae481a18"></a><!-- doxytag: member="rdkafka.h::rd_kafka_clusterid" ref="a261ba8c649756fbc7fbcd442ae481a18" args="(rd_kafka_t *rk, int timeout_ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT char* rd_kafka_clusterid </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout_ms</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the ClusterId as reported in broker metadata. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timeout_ms</em>&nbsp;</td><td>If there is no cached value from metadata retrieval then this specifies the maximum amount of time (in milliseconds) the call will block waiting for metadata to be retrieved. Use 0 for non-blocking calls.</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Requires broker version &gt;=0.10.0 and api.version.request=true.</dd>
<dd>
The application must free the returned pointer using <a class="el" href="rdkafka_8h.html#a50178b3d3266c9eeb0b5981377833572" title="Free pointer returned by librdkafka.">rd_kafka_mem_free()</a>.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a newly allocated string containing the ClusterId, or NULL if no ClusterId could be retrieved in the allotted timespan. </dd></dl>

</div>
</div>
<a class="anchor" id="ab1dcba74a35e8f3bfe3270ff600581d8"></a><!-- doxytag: member="rdkafka.h::rd_kafka_topic_new" ref="ab1dcba74a35e8f3bfe3270ff600581d8" args="(rd_kafka_t *rk, const char *topic, rd_kafka_topic_conf_t *conf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT rd_kafka_topic_t* rd_kafka_topic_new </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rd_kafka_topic_conf_t *&nbsp;</td>
          <td class="paramname"> <em>conf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new topic handle for topic named <code>topic</code>. </p>
<p><code>conf</code> is an optional configuration for the topic created with `rd_kafka_topic_conf_new()` that will be used instead of the default topic configuration. The <code>conf</code> object is freed by this function and must not be used or destroyed by the application sub-sequently. See `rd_kafka_topic_conf_set()` et.al for more information.</p>
<p>Topic handles are refcounted internally and calling <a class="el" href="rdkafka_8h.html#ab1dcba74a35e8f3bfe3270ff600581d8" title="Creates a new topic handle for topic named topic.">rd_kafka_topic_new()</a> again with the same topic name will return the previous topic handle without updating the original handle's configuration. Applications must eventually call <a class="el" href="rdkafka_8h.html#a91f46cd29d4f9abacd3ee3633c01d8ff" title="Loose application&#39;s topic handle refcount as previously created with `rd_kafka_topic_new()`...">rd_kafka_topic_destroy()</a> for each succesfull call to <a class="el" href="rdkafka_8h.html#ab1dcba74a35e8f3bfe3270ff600581d8" title="Creates a new topic handle for topic named topic.">rd_kafka_topic_new()</a> to clear up resources.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the new topic handle or NULL on error (use <a class="el" href="rdkafka_8h.html#abeabf8589c657d7a3ec5a1411a7de91d" title="Converts the system errno value errnox to a rd_kafka_resp_err_t error code upon failure...">rd_kafka_errno2err()</a> to convert system <code>errno</code> to an rd_kafka_resp_err_t error code.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rdkafka_8h.html#a91f46cd29d4f9abacd3ee3633c01d8ff" title="Loose application&#39;s topic handle refcount as previously created with `rd_kafka_topic_new()`...">rd_kafka_topic_destroy()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a91f46cd29d4f9abacd3ee3633c01d8ff"></a><!-- doxytag: member="rdkafka.h::rd_kafka_topic_destroy" ref="a91f46cd29d4f9abacd3ee3633c01d8ff" args="(rd_kafka_topic_t *rkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_topic_destroy </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_t *&nbsp;</td>
          <td class="paramname"> <em>rkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Loose application's topic handle refcount as previously created with `rd_kafka_topic_new()`. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Since topic objects are refcounted (both internally and for the app) the topic object might not actually be destroyed by this call, but the application must consider the object destroyed. </dd></dl>

</div>
</div>
<a class="anchor" id="ad50c431e3a29d14da534db49bd0682a4"></a><!-- doxytag: member="rdkafka.h::rd_kafka_poll" ref="ad50c431e3a29d14da534db49bd0682a4" args="(rd_kafka_t *rk, int timeout_ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_poll </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout_ms</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Polls the provided kafka handle for events. </p>
<p>Events will cause application provided callbacks to be called.</p>
<p>The <code>timeout_ms</code> argument specifies the maximum amount of time (in milliseconds) that the call will block waiting for events. For non-blocking calls, provide 0 as <code>timeout_ms</code>. To wait indefinately for an event, provide -1.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>An application should make sure to call poll() at regular intervals to serve any queued callbacks waiting to be called.</dd></dl>
<p>Events:</p>
<ul>
<li>delivery report callbacks (if dr_cb/dr_msg_cb is configured) [producer]</li>
<li>error callbacks (<a class="el" href="rdkafka_8h.html#ace721ef3b7c22d0c111ec747ef039a90" title="Set error callback in provided conf object.">rd_kafka_conf_set_error_cb()</a>) [all]</li>
<li>stats callbacks (<a class="el" href="rdkafka_8h.html#a597d00432e3ca22174d18e7e348fb766" title="Set statistics callback in provided conf object.">rd_kafka_conf_set_stats_cb()</a>) [all]</li>
<li>throttle callbacks (<a class="el" href="rdkafka_8h.html#a04160826ad039d42c10edec456163fa7" title="Set throttle callback.">rd_kafka_conf_set_throttle_cb()</a>) [all]</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of events served. </dd></dl>

</div>
</div>
<a class="anchor" id="a111628df6c84716c4b550f8509ac6a6d"></a><!-- doxytag: member="rdkafka.h::rd_kafka_yield" ref="a111628df6c84716c4b550f8509ac6a6d" args="(rd_kafka_t *rk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_yield </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cancels the current callback dispatcher (<a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4" title="Polls the provided kafka handle for events.">rd_kafka_poll()</a>, <a class="el" href="rdkafka_8h.html#a303fa0f0da7f3c28bed35570adc983c6" title="Consumes messages from topic rkt and partition, calling the provided callback for...">rd_kafka_consume_callback()</a>, etc). </p>
<p>A callback may use this to force an immediate return to the calling code (caller of e.g. <a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4" title="Polls the provided kafka handle for events.">rd_kafka_poll()</a>) without processing any further events.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This function MUST ONLY be called from within a librdkafka callback. </dd></dl>

</div>
</div>
<a class="anchor" id="a293cb2aac290c157702d3b82f5c14fce"></a><!-- doxytag: member="rdkafka.h::rd_kafka_pause_partitions" ref="a293cb2aac290c157702d3b82f5c14fce" args="(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_pause_partitions </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&nbsp;</td>
          <td class="paramname"> <em>partitions</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pause producing or consumption for the provided list of partitions. </p>
<p>Success or error is returned per-partition <code>err</code> in the <code>partitions</code> list.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR </dd></dl>

</div>
</div>
<a class="anchor" id="ad05819f26887a916ad2047d96a7b4bf2"></a><!-- doxytag: member="rdkafka.h::rd_kafka_resume_partitions" ref="ad05819f26887a916ad2047d96a7b4bf2" args="(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_resume_partitions </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&nbsp;</td>
          <td class="paramname"> <em>partitions</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resume producing consumption for the provided list of partitions. </p>
<p>Success or error is returned per-partition <code>err</code> in the <code>partitions</code> list.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR </dd></dl>

</div>
</div>
<a class="anchor" id="a4550ff7d014f08406666124573f70495"></a><!-- doxytag: member="rdkafka.h::rd_kafka_query_watermark_offsets" ref="a4550ff7d014f08406666124573f70495" args="(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high, int timeout_ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_query_watermark_offsets </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&nbsp;</td>
          <td class="paramname"> <em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&nbsp;</td>
          <td class="paramname"> <em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout_ms</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Query broker for low (oldest/beginning) and high (newest/end) offsets for partition. </p>
<p>Offsets are returned in <code>*low</code> and <code>*high</code> respectively.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ad1d338cebde98a76050e61301f631d82"></a><!-- doxytag: member="rdkafka.h::rd_kafka_get_watermark_offsets" ref="ad1d338cebde98a76050e61301f631d82" args="(rd_kafka_t *rk, const char *topic, int32_t partition, int64_t *low, int64_t *high)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_get_watermark_offsets </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&nbsp;</td>
          <td class="paramname"> <em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&nbsp;</td>
          <td class="paramname"> <em>high</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get last known low (oldest/beginning) and high (newest/end) offsets for partition. </p>
<p>The low offset is updated periodically (if statistics.interval.ms is set) while the high offset is updated on each fetched message set from the broker.</p>
<p>If there is no cached offset (either low or high, or both) then RD_KAFKA_OFFSET_INVALID will be returned for the respective offset.</p>
<p>Offsets are returned in <code>*low</code> and <code>*high</code> respectively.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on failure.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Shall only be used with an active consumer instance. </dd></dl>

</div>
</div>
<a class="anchor" id="ae308aaf534807cfd4c71e423fc214929"></a><!-- doxytag: member="rdkafka.h::rd_kafka_offsets_for_times" ref="ae308aaf534807cfd4c71e423fc214929" args="(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets, int timeout_ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_offsets_for_times </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&nbsp;</td>
          <td class="paramname"> <em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout_ms</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Look up the offsets for the given partitions by timestamp. </p>
<p>The returned offset for each partition is the earliest offset whose timestamp is greater than or equal to the given timestamp in the corresponding partition.</p>
<p>The timestamps to query are represented as <code>offset</code> in <code>offsets</code> on input, and <code>offset</code> will contain the offset on output.</p>
<p>The function will block for at most <code>timeout_ms</code> milliseconds.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Duplicate Topic+Partitions are not supported. </dd>
<dd>
Per-partition errors may be returned in <code><a class="el" href="structrd__kafka__topic__partition__t.html#ab9370931853903657d7cabc9643d336e">rd_kafka_topic_partition_t.err</a></code> </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR if offsets were be queried (do note that per-partition errors might be set), RD_KAFKA_RESP_ERR__TIMED_OUT if not all offsets could be fetched within <code>timeout_ms</code>, RD_KAFKA_RESP_ERR__INVALID_ARG if the <code>offsets</code> list is empty, RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION if all partitions are unknown, RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE if unable to query leaders for the given partitions. </dd></dl>

</div>
</div>
<a class="anchor" id="a50178b3d3266c9eeb0b5981377833572"></a><!-- doxytag: member="rdkafka.h::rd_kafka_mem_free" ref="a50178b3d3266c9eeb0b5981377833572" args="(rd_kafka_t *rk, void *ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_mem_free </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free pointer returned by librdkafka. </p>
<p>This is typically an abstraction for the free(3) call and makes sure the application can use the same memory allocator as librdkafka for freeing pointers returned by librdkafka.</p>
<p>In standard setups it is usually not necessary to use this interface rather than the free(3) functione.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><a class="el" href="rdkafka_8h.html#a50178b3d3266c9eeb0b5981377833572" title="Free pointer returned by librdkafka.">rd_kafka_mem_free()</a> must only be used for pointers returned by APIs that explicitly mention using this function for freeing. </dd></dl>

</div>
</div>
<a class="anchor" id="a2b59178eb7e88d40510a89f3f2d98b44"></a><!-- doxytag: member="rdkafka.h::rd_kafka_queue_new" ref="a2b59178eb7e88d40510a89f3f2d98b44" args="(rd_kafka_t *rk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT rd_kafka_queue_t* rd_kafka_queue_new </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new message queue. </p>
<p>See <a class="el" href="rdkafka_8h.html#a8e952d7961169471f69c7ddc87041258" title="Same as rd_kafka_consume_start() but re-routes incoming messages to the provided...">rd_kafka_consume_start_queue()</a>, <a class="el" href="rdkafka_8h.html#a8ff0b80fccb3a5bd31b1baaf20e4ca16" title="Consume from queue.">rd_kafka_consume_queue()</a>, et.al. </p>

</div>
</div>
<a class="anchor" id="a9421b3d450f1489cf46f68d49c5ea61e"></a><!-- doxytag: member="rdkafka.h::rd_kafka_queue_destroy" ref="a9421b3d450f1489cf46f68d49c5ea61e" args="(rd_kafka_queue_t *rkqu)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_queue_destroy </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_queue_t *&nbsp;</td>
          <td class="paramname"> <em>rkqu</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy a queue, purging all of its enqueued messages. </p>

</div>
</div>
<a class="anchor" id="a7f3d675ee029a52bf85fb28f83c38863"></a><!-- doxytag: member="rdkafka.h::rd_kafka_queue_get_main" ref="a7f3d675ee029a52bf85fb28f83c38863" args="(rd_kafka_t *rk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT rd_kafka_queue_t* rd_kafka_queue_get_main </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to the main librdkafka event queue. This is the queue served by <a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4" title="Polls the provided kafka handle for events.">rd_kafka_poll()</a>.</dd></dl>
<p>Use <a class="el" href="rdkafka_8h.html#a9421b3d450f1489cf46f68d49c5ea61e">rd_kafka_queue_destroy()</a> to loose the reference. </p>

</div>
</div>
<a class="anchor" id="acacdb55ae7cb6abfbde89621e512b078"></a><!-- doxytag: member="rdkafka.h::rd_kafka_queue_get_consumer" ref="acacdb55ae7cb6abfbde89621e512b078" args="(rd_kafka_t *rk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT rd_kafka_queue_t* rd_kafka_queue_get_consumer </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to the librdkafka consumer queue. This is the queue served by <a class="el" href="rdkafka_8h.html#a65cc6cb9bd72c4084f074af0361ceddf" title="Poll the consumer for messages or events.">rd_kafka_consumer_poll()</a>.</dd></dl>
<p>Use <a class="el" href="rdkafka_8h.html#a9421b3d450f1489cf46f68d49c5ea61e">rd_kafka_queue_destroy()</a> to loose the reference.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><a class="el" href="rdkafka_8h.html#a9421b3d450f1489cf46f68d49c5ea61e">rd_kafka_queue_destroy()</a> MUST be called on this queue prior to calling <a class="el" href="rdkafka_8h.html#a37b54d329e12d745889defe96e7d043d" title="Close down the KafkaConsumer.">rd_kafka_consumer_close()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad5319a26efb9f843c6029f7dd54b742d"></a><!-- doxytag: member="rdkafka.h::rd_kafka_queue_get_partition" ref="ad5319a26efb9f843c6029f7dd54b742d" args="(rd_kafka_t *rk, const char *topic, int32_t partition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT rd_kafka_queue_t* rd_kafka_queue_get_partition </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>partition</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to the partition's queue, or NULL if partition is invalid.</dd></dl>
<p>Use <a class="el" href="rdkafka_8h.html#a9421b3d450f1489cf46f68d49c5ea61e">rd_kafka_queue_destroy()</a> to loose the reference.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><a class="el" href="rdkafka_8h.html#a9421b3d450f1489cf46f68d49c5ea61e">rd_kafka_queue_destroy()</a> MUST be called on this queue</dd>
<dd>
This function only works on consumers. </dd></dl>

</div>
</div>
<a class="anchor" id="a5e2e5571d14636d289f963a270b8e338"></a><!-- doxytag: member="rdkafka.h::rd_kafka_queue_forward" ref="a5e2e5571d14636d289f963a270b8e338" args="(rd_kafka_queue_t *src, rd_kafka_queue_t *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_queue_forward </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_queue_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rd_kafka_queue_t *&nbsp;</td>
          <td class="paramname"> <em>dst</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Forward/re-route queue <code>src</code> to <code>dst</code>. If <code>dst</code> is <code>NULL</code> the forwarding is removed. </p>
<p>The internal refcounts for both queues are increased.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Regardless of whether <code>dst</code> is NULL or not, after calling this function, <code>src</code> will not forward it's fetch queue to the consumer queue. </dd></dl>

</div>
</div>
<a class="anchor" id="a5c8a3be2f797560b2a39bf56dbd7622d"></a><!-- doxytag: member="rdkafka.h::rd_kafka_set_log_queue" ref="a5c8a3be2f797560b2a39bf56dbd7622d" args="(rd_kafka_t *rk, rd_kafka_queue_t *rkqu)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_set_log_queue </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rd_kafka_queue_t *&nbsp;</td>
          <td class="paramname"> <em>rkqu</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Forward librdkafka logs (and debug) to the specified queue for serving with one of the ..poll() calls. </p>
<p>This allows an application to serve log callbacks (<code>log_cb</code>) in its thread of choice.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rkqu</em>&nbsp;</td><td>Queue to forward logs to. If the value is NULL the logs are forwarded to the main queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The configuration property <code>log.queue</code> MUST also be set to true.</dd>
<dd>
librdkafka maintains its own reference to the provided queue.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a8f24368f4ff0e042907773f532f62e57"></a><!-- doxytag: member="rdkafka.h::rd_kafka_queue_length" ref="a8f24368f4ff0e042907773f532f62e57" args="(rd_kafka_queue_t *rkqu)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT size_t rd_kafka_queue_length </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_queue_t *&nbsp;</td>
          <td class="paramname"> <em>rkqu</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the current number of elements in queue. </dd></dl>

</div>
</div>
<a class="anchor" id="acbdd13ab480f6320b2842981eebce784"></a><!-- doxytag: member="rdkafka.h::rd_kafka_queue_io_event_enable" ref="acbdd13ab480f6320b2842981eebce784" args="(rd_kafka_queue_t *rkqu, int fd, const void *payload, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_queue_io_event_enable </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_queue_t *&nbsp;</td>
          <td class="paramname"> <em>rkqu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable IO event triggering for queue. </p>
<p>To ease integration with IO based polling loops this API allows an application to create a separate file-descriptor that librdkafka will write <code>payload</code> (of size <code>size</code>) to whenever a new element is enqueued on a previously empty queue.</p>
<p>To remove event triggering call with <code>fd</code> = -1.</p>
<p>librdkafka will maintain a copy of the <code>payload</code>.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>When using forwarded queues the IO event must only be enabled on the final forwarded-to (destination) queue. </dd></dl>

</div>
</div>
<a class="anchor" id="ae21dcd2d8c6195baf7f9f4952d7e12d4"></a><!-- doxytag: member="rdkafka.h::rd_kafka_consume_start" ref="ae21dcd2d8c6195baf7f9f4952d7e12d4" args="(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_consume_start </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_t *&nbsp;</td>
          <td class="paramname"> <em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start consuming messages for topic <code>rkt</code> and <code>partition</code> at offset <code>offset</code> which may either be an absolute <code></code>(0..N) or one of the logical offsets:</p>
<ul>
<li>RD_KAFKA_OFFSET_BEGINNING</li>
<li>RD_KAFKA_OFFSET_END</li>
<li>RD_KAFKA_OFFSET_STORED</li>
<li>RD_KAFKA_OFFSET_TAIL. </li>
</ul>
</p>
<p>rdkafka will attempt to keep <code>queued.min.messages</code> (config property) messages in the local queue by repeatedly fetching batches of messages from the broker until the threshold is reached.</p>
<p>The application shall use one of the `rd_kafka_consume*()` functions to consume messages from the local queue, each kafka message being represented as a `rd_kafka_message_t *` object.</p>
<p>`rd_kafka_consume_start()` must not be called multiple times for the same topic and partition without stopping consumption first with `rd_kafka_consume_stop()`.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success or -1 on error in which case errno is set accordingly:<ul>
<li>EBUSY - Conflicts with an existing or previous subscription (RD_KAFKA_RESP_ERR__CONFLICT)</li>
<li>EINVAL - Invalid offset, or incomplete configuration (lacking group.id) (RD_KAFKA_RESP_ERR__INVALID_ARG)</li>
<li>ESRCH - requested <code>partition</code> is invalid. (RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION)</li>
<li>ENOENT - topic is unknown in the Kafka cluster. (RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC)</li>
</ul>
</dd></dl>
<p>Use `rd_kafka_errno2err()` to convert sytem <code>errno</code> to `rd_kafka_resp_err_t` </p>

</div>
</div>
<a class="anchor" id="a8e952d7961169471f69c7ddc87041258"></a><!-- doxytag: member="rdkafka.h::rd_kafka_consume_start_queue" ref="a8e952d7961169471f69c7ddc87041258" args="(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, rd_kafka_queue_t *rkqu)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_consume_start_queue </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_t *&nbsp;</td>
          <td class="paramname"> <em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rd_kafka_queue_t *&nbsp;</td>
          <td class="paramname"> <em>rkqu</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Same as <a class="el" href="rdkafka_8h.html#ae21dcd2d8c6195baf7f9f4952d7e12d4" title="Start consuming messages for topic rkt and partition at offset offset which may either...">rd_kafka_consume_start()</a> but re-routes incoming messages to the provided queue <code>rkqu</code> (which must have been previously allocated with `rd_kafka_queue_new()`. </p>
<p>The application must use one of the `rd_kafka_consume_*_queue()` functions to receive fetched messages.</p>
<p>`rd_kafka_consume_start_queue()` must not be called multiple times for the same topic and partition without stopping consumption first with `rd_kafka_consume_stop()`. `rd_kafka_consume_start()` and `rd_kafka_consume_start_queue()` must not be combined for the same topic and partition. </p>

</div>
</div>
<a class="anchor" id="acf07475e5e85e63fc5321a1087288cd4"></a><!-- doxytag: member="rdkafka.h::rd_kafka_consume_stop" ref="acf07475e5e85e63fc5321a1087288cd4" args="(rd_kafka_topic_t *rkt, int32_t partition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_consume_stop </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_t *&nbsp;</td>
          <td class="paramname"> <em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>partition</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stop consuming messages for topic <code>rkt</code> and <code>partition</code>, purging all messages currently in the local queue. </p>
<p>NOTE: To enforce synchronisation this call will block until the internal fetcher has terminated and offsets are committed to configured storage method.</p>
<p>The application needs to be stop all consumers before calling `rd_kafka_destroy()` on the main object handle.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success or -1 on error (see `errno`). </dd></dl>

</div>
</div>
<a class="anchor" id="a6667b162931982e9827e3d86ad22ec7d"></a><!-- doxytag: member="rdkafka.h::rd_kafka_seek" ref="a6667b162931982e9827e3d86ad22ec7d" args="(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset, int timeout_ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_seek </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_t *&nbsp;</td>
          <td class="paramname"> <em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout_ms</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Seek consumer for topic+partition to <code>offset</code> which is either an absolute or logical offset. </p>
<p>If <code>timeout_ms</code> is not 0 the call will wait this long for the seek to be performed. If the timeout is reached the internal state will be unknown and this function returns `RD_KAFKA_RESP_ERR__TIMED_OUT`. If <code>timeout_ms</code> is 0 it will initiate the seek but return immediately without any error reporting (e.g., async).</p>
<p>This call triggers a fetch queue barrier flush.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>`RD_KAFKA_RESP_ERR__NO_ERROR` on success else an error code. </dd></dl>

</div>
</div>
<a class="anchor" id="aa49d14e8b742365f9f25d35318ff0b7e"></a><!-- doxytag: member="rdkafka.h::rd_kafka_consume" ref="aa49d14e8b742365f9f25d35318ff0b7e" args="(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a>* rd_kafka_consume </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_t *&nbsp;</td>
          <td class="paramname"> <em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout_ms</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Consume a single message from topic <code>rkt</code> and <code>partition</code>. </p>
<p><code>timeout_ms</code> is maximum amount of time to wait for a message to be received. Consumer must have been previously started with `rd_kafka_consume_start()`.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a message object on success or <code>NULL</code> on error. The message object must be destroyed with `rd_kafka_message_destroy()` when the application is done with it.</dd></dl>
<p>Errors (when returning NULL):</p>
<ul>
<li>ETIMEDOUT - <code>timeout_ms</code> was reached with no new messages fetched.</li>
<li>ENOENT - <code>rkt</code> + <code>partition</code> is unknown. (no prior `rd_kafka_consume_start()` call)</li>
</ul>
<p>NOTE: The returned message's <code></code>..-&gt;err must be checked for errors. NOTE: <code></code>..-&gt;err <code>==</code> <code>RD_KAFKA_RESP_ERR__PARTITION_EOF</code> signals that the end of the partition has been reached, which should typically not be considered an error. The application should handle this case (e.g., ignore).</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>on_consume() interceptors may be called from this function prior to passing message to application. </dd></dl>

</div>
</div>
<a class="anchor" id="a53511739a2cf498b8d88287fef6873ce"></a><!-- doxytag: member="rdkafka.h::rd_kafka_consume_batch" ref="a53511739a2cf498b8d88287fef6873ce" args="(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT ssize_t rd_kafka_consume_batch </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_t *&nbsp;</td>
          <td class="paramname"> <em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> **&nbsp;</td>
          <td class="paramname"> <em>rkmessages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>rkmessages_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Consume up to <code>rkmessages_size</code> from topic <code>rkt</code> and <code>partition</code> putting a pointer to each message in the application provided array <code>rkmessages</code> (of size <code>rkmessages_size</code> entries). </p>
<p>`rd_kafka_consume_batch()` provides higher throughput performance than `rd_kafka_consume()`.</p>
<p><code>timeout_ms</code> is the maximum amount of time to wait for all of <code>rkmessages_size</code> messages to be put into <code>rkmessages</code>. If no messages were available within the timeout period this function returns 0 and <code>rkmessages</code> remains untouched. This differs somewhat from `rd_kafka_consume()`.</p>
<p>The message objects must be destroyed with `rd_kafka_message_destroy()` when the application is done with it.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of rkmessages added in <code>rkmessages</code>, or -1 on error (same error codes as for `rd_kafka_consume()`.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rdkafka_8h.html#aa49d14e8b742365f9f25d35318ff0b7e" title="Consume a single message from topic rkt and partition.">rd_kafka_consume()</a></dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>on_consume() interceptors may be called from this function prior to passing message to application. </dd></dl>

</div>
</div>
<a class="anchor" id="a303fa0f0da7f3c28bed35570adc983c6"></a><!-- doxytag: member="rdkafka.h::rd_kafka_consume_callback" ref="a303fa0f0da7f3c28bed35570adc983c6" args="(rd_kafka_topic_t *rkt, int32_t partition, int timeout_ms, void(*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque), void *opaque)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_consume_callback </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_t *&nbsp;</td>
          <td class="paramname"> <em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, void *opaque)&nbsp;</td>
          <td class="paramname"> <em>consume_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>opaque</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Consumes messages from topic <code>rkt</code> and <code>partition</code>, calling the provided callback for each consumed messsage. </p>
<p>`rd_kafka_consume_callback()` provides higher throughput performance than both `rd_kafka_consume()` and `rd_kafka_consume_batch()`.</p>
<p><code>timeout_ms</code> is the maximum amount of time to wait for one or more messages to arrive.</p>
<p>The provided <code>consume_cb</code> function is called for each message, the application <b>MUST</b> <b>NOT</b> call `rd_kafka_message_destroy()` on the provided <code>rkmessage</code>.</p>
<p>The <code>opaque</code> argument is passed to the 'consume_cb' as <code>opaque</code>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of messages processed or -1 on error.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rdkafka_8h.html#aa49d14e8b742365f9f25d35318ff0b7e" title="Consume a single message from topic rkt and partition.">rd_kafka_consume()</a></dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>on_consume() interceptors may be called from this function prior to passing message to application. </dd></dl>

</div>
</div>
<a class="anchor" id="a8ff0b80fccb3a5bd31b1baaf20e4ca16"></a><!-- doxytag: member="rdkafka.h::rd_kafka_consume_queue" ref="a8ff0b80fccb3a5bd31b1baaf20e4ca16" args="(rd_kafka_queue_t *rkqu, int timeout_ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a>* rd_kafka_consume_queue </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_queue_t *&nbsp;</td>
          <td class="paramname"> <em>rkqu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout_ms</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Consume from queue. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rdkafka_8h.html#aa49d14e8b742365f9f25d35318ff0b7e" title="Consume a single message from topic rkt and partition.">rd_kafka_consume()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3d949238471993b18537855aad28fa23"></a><!-- doxytag: member="rdkafka.h::rd_kafka_consume_batch_queue" ref="a3d949238471993b18537855aad28fa23" args="(rd_kafka_queue_t *rkqu, int timeout_ms, rd_kafka_message_t **rkmessages, size_t rkmessages_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT ssize_t rd_kafka_consume_batch_queue </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_queue_t *&nbsp;</td>
          <td class="paramname"> <em>rkqu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> **&nbsp;</td>
          <td class="paramname"> <em>rkmessages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>rkmessages_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Consume batch of messages from queue. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rdkafka_8h.html#a53511739a2cf498b8d88287fef6873ce" title="Consume up to rkmessages_size from topic rkt and partition putting a pointer to each...">rd_kafka_consume_batch()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abb1aaca2499c2e7d6da37dc28953d532"></a><!-- doxytag: member="rdkafka.h::rd_kafka_consume_callback_queue" ref="abb1aaca2499c2e7d6da37dc28953d532" args="(rd_kafka_queue_t *rkqu, int timeout_ms, void(*consume_cb)(rd_kafka_message_t *rkmessage, void *opaque), void *opaque)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_consume_callback_queue </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_queue_t *&nbsp;</td>
          <td class="paramname"> <em>rkqu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *rkmessage, void *opaque)&nbsp;</td>
          <td class="paramname"> <em>consume_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>opaque</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Consume multiple messages from queue with callback. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rdkafka_8h.html#a303fa0f0da7f3c28bed35570adc983c6" title="Consumes messages from topic rkt and partition, calling the provided callback for...">rd_kafka_consume_callback()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a784186db1d2cb6ceebcd5606d38db4c4"></a><!-- doxytag: member="rdkafka.h::rd_kafka_offset_store" ref="a784186db1d2cb6ceebcd5606d38db4c4" args="(rd_kafka_topic_t *rkt, int32_t partition, int64_t offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_offset_store </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_t *&nbsp;</td>
          <td class="paramname"> <em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Store offset <code>offset</code> for topic <code>rkt</code> partition <code>partition</code>. </p>
<p>The offset will be committed (written) to the offset store according to <code>`auto</code>.commit.interval.ms` or manual offset-less commit()</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><code>`enable</code>.auto.offset.store` must be set to "false" when using this API.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success or an error code on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a047b1e21236fba30898c7c563c2c6777"></a><!-- doxytag: member="rdkafka.h::rd_kafka_offsets_store" ref="a047b1e21236fba30898c7c563c2c6777" args="(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *offsets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_offsets_store </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&nbsp;</td>
          <td class="paramname"> <em>offsets</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Store offsets for next auto-commit for one or more partitions. </p>
<p>The offset will be committed (written) to the offset store according to <code>`auto</code>.commit.interval.ms` or manual offset-less commit().</p>
<p>Per-partition success/error status propagated through each partition's <code></code>.err field.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><code>`enable</code>.auto.offset.store` must be set to "false" when using this API.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success, or RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION if none of the offsets could be stored, or RD_KAFKA_RESP_ERR__INVALID_ARG if <code>enable.auto.offset.store</code> is true. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ebe15e9d0f39ccc84e9686f0fcf46f1"></a><!-- doxytag: member="rdkafka.h::rd_kafka_subscribe" ref="a0ebe15e9d0f39ccc84e9686f0fcf46f1" args="(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *topics)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_subscribe </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&nbsp;</td>
          <td class="paramname"> <em>topics</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subscribe to topic set using balanced consumer groups. </p>
<p>Wildcard (regex) topics are supported by the librdkafka assignor: any topic name in the <code>topics</code> list that is prefixed with <code>\"^\"</code> will be regex-matched to the full list of topics in the cluster and matching topics will be added to the subscription list.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__INVALID_ARG if list is empty, contains invalid topics or regexes. </dd></dl>

</div>
</div>
<a class="anchor" id="ab66a2c014db2e652aa12466b137a6200"></a><!-- doxytag: member="rdkafka.h::rd_kafka_subscription" ref="ab66a2c014db2e652aa12466b137a6200" args="(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **topics)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_subscription </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> **&nbsp;</td>
          <td class="paramname"> <em>topics</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the current topic subscription. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An error code on failure, otherwise <code>topic</code> is updated to point to a newly allocated topic list (possibly empty).</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The application is responsible for calling rd_kafka_topic_partition_list_destroy on the returned list. </dd></dl>

</div>
</div>
<a class="anchor" id="a65cc6cb9bd72c4084f074af0361ceddf"></a><!-- doxytag: member="rdkafka.h::rd_kafka_consumer_poll" ref="a65cc6cb9bd72c4084f074af0361ceddf" args="(rd_kafka_t *rk, int timeout_ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a>* rd_kafka_consumer_poll </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout_ms</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Poll the consumer for messages or events. </p>
<p>Will block for at most <code>timeout_ms</code> milliseconds.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>An application should make sure to call consumer_poll() at regular intervals, even if no messages are expected, to serve any queued callbacks waiting to be called. This is especially important when a rebalance_cb has been registered as it needs to be called and handled properly to synchronize internal consumer state.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A message object which is a proper message if <code>-&gt;err</code> is RD_KAFKA_RESP_ERR_NO_ERROR, or an event or error for any other value.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>on_consume() interceptors may be called from this function prior to passing message to application.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structrd__kafka__message__t.html" title="A Kafka message as returned by the rd_kafka_consume*() family of functions as well...">rd_kafka_message_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a37b54d329e12d745889defe96e7d043d"></a><!-- doxytag: member="rdkafka.h::rd_kafka_consumer_close" ref="a37b54d329e12d745889defe96e7d043d" args="(rd_kafka_t *rk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_consumer_close </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close down the KafkaConsumer. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This call will block until the consumer has revoked its assignment, calling the <code>rebalance_cb</code> if it is configured, committed offsets to broker, and left the consumer group. The maximum blocking time is roughly limited to session.timeout.ms.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An error code indicating if the consumer close was succesful or not.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The application still needs to call <a class="el" href="rdkafka_8h.html#ac052e92621dcaa3a336dbf826e0d7794" title="Destroy Kafka handle.">rd_kafka_destroy()</a> after this call finishes to clean up the underlying handle resources. </dd></dl>

</div>
</div>
<a class="anchor" id="a0566419eff2001f8371e3b50aa7d26e9"></a><!-- doxytag: member="rdkafka.h::rd_kafka_assign" ref="a0566419eff2001f8371e3b50aa7d26e9" args="(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *partitions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_assign </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&nbsp;</td>
          <td class="paramname"> <em>partitions</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Atomic assignment of partitions to consume. </p>
<p>The new <code>partitions</code> will replace the existing assignment.</p>
<p>When used from a rebalance callback the application shall pass the partition list passed to the callback (or a copy of it) (even if the list is empty) rather than NULL to maintain internal join state.</p>
<p>A zero-length <code>partitions</code> will treat the partitions as a valid, albeit empty, assignment, and maintain internal state, while a <code>NULL</code> value for <code>partitions</code> will reset and clear the internal state. </p>

</div>
</div>
<a class="anchor" id="a10a00cc624a46209fe1192cfc56cce59"></a><!-- doxytag: member="rdkafka.h::rd_kafka_assignment" ref="a10a00cc624a46209fe1192cfc56cce59" args="(rd_kafka_t *rk, rd_kafka_topic_partition_list_t **partitions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_assignment </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> **&nbsp;</td>
          <td class="paramname"> <em>partitions</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the current partition assignment. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An error code on failure, otherwise <code>partitions</code> is updated to point to a newly allocated partition list (possibly empty).</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The application is responsible for calling rd_kafka_topic_partition_list_destroy on the returned list. </dd></dl>

</div>
</div>
<a class="anchor" id="ab96539928328f14c3c9177ea0c896c87"></a><!-- doxytag: member="rdkafka.h::rd_kafka_commit" ref="ab96539928328f14c3c9177ea0c896c87" args="(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, int async)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_commit </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&nbsp;</td>
          <td class="paramname"> <em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>async</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Commit offsets on broker for the provided list of partitions. </p>
<p><code>offsets</code> should contain <code>topic</code>, <code>partition</code>, <code>offset</code> and possibly <code>metadata</code>. If <code>offsets</code> is NULL the current partition assignment will be used instead.</p>
<p>If <code>async</code> is false this operation will block until the broker offset commit is done, returning the resulting success or error code.</p>
<p>If a <a class="el" href="rdkafka_8h.html#a1ab8bb9e8d8cdd5906f9e060b506f2eb" title="Consumer: Set offset commit callback for use with consumer groups.">rd_kafka_conf_set_offset_commit_cb()</a> offset commit callback has been configured the callback will be enqueued for a future call to <a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4" title="Polls the provided kafka handle for events.">rd_kafka_poll()</a>, <a class="el" href="rdkafka_8h.html#a65cc6cb9bd72c4084f074af0361ceddf" title="Poll the consumer for messages or events.">rd_kafka_consumer_poll()</a> or similar. </p>

</div>
</div>
<a class="anchor" id="a99fb25d50216e4e20d303bf8a4a62883"></a><!-- doxytag: member="rdkafka.h::rd_kafka_commit_message" ref="a99fb25d50216e4e20d303bf8a4a62883" args="(rd_kafka_t *rk, const rd_kafka_message_t *rkmessage, int async)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_commit_message </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rkmessage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>async</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Commit message's offset on broker for the message's partition. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rdkafka_8h.html#ab96539928328f14c3c9177ea0c896c87" title="Commit offsets on broker for the provided list of partitions.">rd_kafka_commit</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa793dd9c195f39bcb69465cebf534c47"></a><!-- doxytag: member="rdkafka.h::rd_kafka_commit_queue" ref="aa793dd9c195f39bcb69465cebf534c47" args="(rd_kafka_t *rk, const rd_kafka_topic_partition_list_t *offsets, rd_kafka_queue_t *rkqu, void(*cb)(rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque), void *opaque)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_commit_queue </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&nbsp;</td>
          <td class="paramname"> <em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rd_kafka_queue_t *&nbsp;</td>
          <td class="paramname"> <em>rkqu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(rd_kafka_t *rk, <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> err, <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *offsets, void *opaque)&nbsp;</td>
          <td class="paramname"> <em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>opaque</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Commit offsets on broker for the provided list of partitions. </p>
<p>See rd_kafka_commit for <code>offsets</code> semantics.</p>
<p>The result of the offset commit will be posted on the provided <code>rkqu</code> queue.</p>
<p>If the application uses one of the poll APIs (<a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4" title="Polls the provided kafka handle for events.">rd_kafka_poll()</a>, <a class="el" href="rdkafka_8h.html#a65cc6cb9bd72c4084f074af0361ceddf" title="Poll the consumer for messages or events.">rd_kafka_consumer_poll()</a>, <a class="el" href="rdkafka_8h.html#a2f147ed1c554c9048893fb1adde86dfa" title="Poll a queue for an event for max timeout_ms.">rd_kafka_queue_poll()</a>, ..) to serve the queue the <code>cb</code> callback is required. <code>opaque</code> is passed to the callback.</p>
<p>If using the event API the callback is ignored and the offset commit result will be returned as an RD_KAFKA_EVENT_COMMIT event. The <code>opaque</code> value will be available with <a class="el" href="rdkafka_8h.html#a8650ed2a19108d490a65c9aff3e66525">rd_kafka_event_opaque()</a></p>
<p>If <code>rkqu</code> is NULL a temporary queue will be created and the callback will be served by this call.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rdkafka_8h.html#ab96539928328f14c3c9177ea0c896c87" title="Commit offsets on broker for the provided list of partitions.">rd_kafka_commit()</a> </dd>
<dd>
<a class="el" href="rdkafka_8h.html#a1ab8bb9e8d8cdd5906f9e060b506f2eb" title="Consumer: Set offset commit callback for use with consumer groups.">rd_kafka_conf_set_offset_commit_cb()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a39846ae321a03c4679c9c659f18adf13"></a><!-- doxytag: member="rdkafka.h::rd_kafka_committed" ref="a39846ae321a03c4679c9c659f18adf13" args="(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions, int timeout_ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_committed </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&nbsp;</td>
          <td class="paramname"> <em>partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout_ms</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve committed offsets for topics+partitions. </p>
<p>The <code>offset</code> field of each requested partition will either be set to stored offset or to RD_KAFKA_OFFSET_INVALID in case there was no stored offset for that partition.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success in which case the <code>offset</code> or <code>err</code> field of each <code>partitions'</code> element is filled in with the stored offset, or a partition specific error. Else returns an error code. </dd></dl>

</div>
</div>
<a class="anchor" id="a6e9e36bd9e6bf84a9f3092fcbfa3a9ac"></a><!-- doxytag: member="rdkafka.h::rd_kafka_position" ref="a6e9e36bd9e6bf84a9f3092fcbfa3a9ac" args="(rd_kafka_t *rk, rd_kafka_topic_partition_list_t *partitions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_position </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a> *&nbsp;</td>
          <td class="paramname"> <em>partitions</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve current positions (offsets) for topics+partitions. </p>
<p>The <code>offset</code> field of each requested partition will be set to the offset of the last consumed message + 1, or RD_KAFKA_OFFSET_INVALID in case there was no previous message.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success in which case the <code>offset</code> or <code>err</code> field of each <code>partitions'</code> element is filled in with the stored offset, or a partition specific error. Else returns an error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ae24d8ebf1ea15ed8ea0ea40f74662736"></a><!-- doxytag: member="rdkafka.h::rd_kafka_produce" ref="ae24d8ebf1ea15ed8ea0ea40f74662736" args="(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, void *payload, size_t len, const void *key, size_t keylen, void *msg_opaque)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_produce </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_t *&nbsp;</td>
          <td class="paramname"> <em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>msgflags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>keylen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>msg_opaque</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Produce and send a single message to broker. </p>
<p><code>rkt</code> is the target topic which must have been previously created with `rd_kafka_topic_new()`.</p>
<p>`rd_kafka_produce()` is an asynch non-blocking API.</p>
<p><code>partition</code> is the target partition, either:</p>
<ul>
<li>RD_KAFKA_PARTITION_UA (unassigned) for automatic partitioning using the topic's partitioner function, or</li>
<li>a fixed partition (0..N)</li>
</ul>
<p><code>msgflags</code> is zero or more of the following flags OR:ed together: RD_KAFKA_MSG_F_BLOCK - block <code>produce*</code>() call if <code>queue.buffering.max.messages</code> or <code>queue.buffering.max.kbytes</code> are exceeded. Messages are considered in-queue from the point they are accepted by produce() until their corresponding delivery report callback/event returns. It is thus a requirement to call <a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4" title="Polls the provided kafka handle for events.">rd_kafka_poll()</a> (or equiv.) from a separate thread when F_BLOCK is used. See WARNING on <code>RD_KAFKA_MSG_F_BLOCK</code> above.</p>
<p>RD_KAFKA_MSG_F_FREE - rdkafka will free(3) <code>payload</code> when it is done with it. RD_KAFKA_MSG_F_COPY - the <code>payload</code> data will be copied and the <code>payload</code> pointer will not be used by rdkafka after the call returns. RD_KAFKA_MSG_F_PARTITION - produce_batch() will honour per-message partition, either set manually or by the configured partitioner.</p>
<p>.._F_FREE and .._F_COPY are mutually exclusive.</p>
<p>If the function returns -1 and RD_KAFKA_MSG_F_FREE was specified, then the memory associated with the payload is still the caller's responsibility.</p>
<p><code>payload</code> is the message payload of size <code>len</code> bytes.</p>
<p><code>key</code> is an optional message key of size <code>keylen</code> bytes, if non-NULL it will be passed to the topic partitioner as well as be sent with the message to the broker and passed on to the consumer.</p>
<p><code>msg_opaque</code> is an optional application-provided per-message opaque pointer that will provided in the delivery report callback (`dr_cb`) for referencing this message.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>on_send() and on_acknowledgement() interceptors may be called from this function. on_acknowledgement() will only be called if the message fails partitioning.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success or -1 on error in which case errno is set accordingly:<ul>
<li>ENOBUFS - maximum number of outstanding messages has been reached: "queue.buffering.max.messages" (RD_KAFKA_RESP_ERR__QUEUE_FULL)</li>
<li>EMSGSIZE - message is larger than configured max size: "messages.max.bytes". (RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE)</li>
<li>ESRCH - requested <code>partition</code> is unknown in the Kafka cluster. (RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION)</li>
<li>ENOENT - topic is unknown in the Kafka cluster. (RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC)</li>
</ul>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>Use <a class="el" href="rdkafka_8h.html#abeabf8589c657d7a3ec5a1411a7de91d" title="Converts the system errno value errnox to a rd_kafka_resp_err_t error code upon failure...">rd_kafka_errno2err()</a> to convert `errno` to rdkafka error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ac3a111ec3e6729609d498fec7b619efc"></a><!-- doxytag: member="rdkafka.h::rd_kafka_producev" ref="ac3a111ec3e6729609d498fec7b619efc" args="(rd_kafka_t *rk,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_producev </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Produce and send a single message to broker. </p>
<p>The message is defined by a va-arg list using <code>rd_kafka_vtype_t</code> tag tuples which must be terminated with a single <code>RD_KAFKA_V_END</code>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>RD_KAFKA_RESP_ERR_NO_ERROR</code> on success, else an error code. <code>RD_KAFKA_RESP_ERR__CONFLICT</code> is returned if _V_HEADER and _V_HEADERS are mixed.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rdkafka_8h.html#ae24d8ebf1ea15ed8ea0ea40f74662736" title="Produce and send a single message to broker.">rd_kafka_produce</a>, <a class="el" href="rdkafka_8h.html#a03c74ceba678b4e7a624310160a02165" title="Convenience macros for rd_kafka_vtype_t that takes the correct arguments for each...">RD_KAFKA_V_END</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7ad15c71f228c47946500a0e5c6f88ed"></a><!-- doxytag: member="rdkafka.h::rd_kafka_produce_batch" ref="a7ad15c71f228c47946500a0e5c6f88ed" args="(rd_kafka_topic_t *rkt, int32_t partition, int msgflags, rd_kafka_message_t *rkmessages, int message_cnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_produce_batch </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_topic_t *&nbsp;</td>
          <td class="paramname"> <em>rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>msgflags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rkmessages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>message_cnt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Produce multiple messages. </p>
<p>If partition is RD_KAFKA_PARTITION_UA the configured partitioner will be run for each message (slower), otherwise the messages will be enqueued to the specified partition directly (faster).</p>
<p>The messages are provided in the array <code>rkmessages</code> of count <code>message_cnt</code> elements. The <code>partition</code> and <code>msgflags</code> are used for all provided messages.</p>
<p>Honoured <code>rkmessages</code>[] fields are:</p>
<ul>
<li>payload,len Message payload and length</li>
<li>key,key_len Optional message key</li>
<li>_private Message opaque pointer (msg_opaque)</li>
<li>err Will be set according to success or failure. Application only needs to check for errors if return value != <code>message_cnt</code>.</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of messages succesfully enqueued for producing.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This interface does NOT support setting message headers on the provided <code>rkmessages</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="aaff06c4372bce917c17f3c1a5d8b205d"></a><!-- doxytag: member="rdkafka.h::rd_kafka_flush" ref="aaff06c4372bce917c17f3c1a5d8b205d" args="(rd_kafka_t *rk, int timeout_ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_flush </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout_ms</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait until all outstanding produce requests, et.al, are completed. This should typically be done prior to destroying a producer instance to make sure all queued and in-flight produce requests are completed before terminating. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This function will call <a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4" title="Polls the provided kafka handle for events.">rd_kafka_poll()</a> and thus trigger callbacks.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RD_KAFKA_RESP_ERR__TIMED_OUT if <code>timeout_ms</code> was reached before all outstanding requests were completed, else RD_KAFKA_RESP_ERR_NO_ERROR </dd></dl>

</div>
</div>
<a class="anchor" id="a84bba4a4b13fdb515f1a22d6fd4f7344"></a><!-- doxytag: member="rdkafka.h::rd_kafka_metadata" ref="a84bba4a4b13fdb515f1a22d6fd4f7344" args="(rd_kafka_t *rk, int all_topics, rd_kafka_topic_t *only_rkt, const struct rd_kafka_metadata **metadatap, int timeout_ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_metadata </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>all_topics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rd_kafka_topic_t *&nbsp;</td>
          <td class="paramname"> <em>only_rkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct rd_kafka_metadata **&nbsp;</td>
          <td class="paramname"> <em>metadatap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout_ms</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request Metadata from broker. </p>
<p>Parameters:</p>
<ul>
<li><code>all_topics</code> if non-zero: request info about all topics in cluster, if zero: only request info about locally known topics.</li>
<li><code>only_rkt</code> only request info about this topic</li>
<li><code>metadatap</code> pointer to hold metadata result. The <code>*metadatap</code> pointer must be released with <a class="el" href="rdkafka_8h.html#a0b4ee98ab1c76f3504edf9eed986844e" title="Release metadata memory.">rd_kafka_metadata_destroy()</a>.</li>
<li><code>timeout_ms</code> maximum response time before failing.</li>
</ul>
<p>Returns RD_KAFKA_RESP_ERR_NO_ERROR on success (in which case *metadatap) will be set, else RD_KAFKA_RESP_ERR__TIMED_OUT on timeout or other error code on error. </p>

</div>
</div>
<a class="anchor" id="a6cfc79819453ecd4aa94fbae6dbbea0a"></a><!-- doxytag: member="rdkafka.h::rd_kafka_list_groups" ref="a6cfc79819453ecd4aa94fbae6dbbea0a" args="(rd_kafka_t *rk, const char *group, const struct rd_kafka_group_list **grplistp, int timeout_ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_list_groups </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrd__kafka__group__list.html">rd_kafka_group_list</a> **&nbsp;</td>
          <td class="paramname"> <em>grplistp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout_ms</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>List and describe client groups in cluster. </p>
<p><code>group</code> is an optional group name to describe, otherwise (<code>NULL</code>) all groups are returned.</p>
<p><code>timeout_ms</code> is the (approximate) maximum time to wait for response from brokers and must be a positive value.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>RD_KAFKA_RESP_ERR__NO_ERROR</code> on success and <code>grplistp</code> is updated to point to a newly allocated list of groups. <code>RD_KAFKA_RESP_ERR__PARTIAL</code> if not all brokers responded in time but at least one group is returned in <code>grplistlp</code>. <code>RD_KAFKA_RESP_ERR__TIMED_OUT</code> if no groups were returned in the given timeframe but not all brokers have yet responded, or if the list of brokers in the cluster could not be obtained within the given timeframe. <code>RD_KAFKA_RESP_ERR__TRANSPORT</code> if no brokers were found. Other error codes may also be returned from the request layer.</dd></dl>
<p>The <code>grplistp</code> remains untouched if any error code is returned, with the exception of RD_KAFKA_RESP_ERR__PARTIAL which behaves as RD_KAFKA_RESP_ERR__NO_ERROR (success) but with an incomplete group list.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>Use <a class="el" href="rdkafka_8h.html#ab28e1cb749e7e62168107ccdee1960ea" title="Release list memory.">rd_kafka_group_list_destroy()</a> to release list memory. </dd></dl>

</div>
</div>
<a class="anchor" id="ab83da8da989fe41693d78d982c7ae6b7"></a><!-- doxytag: member="rdkafka.h::rd_kafka_brokers_add" ref="ab83da8da989fe41693d78d982c7ae6b7" args="(rd_kafka_t *rk, const char *brokerlist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_brokers_add </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>brokerlist</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds one or more brokers to the kafka handle's list of initial bootstrap brokers. </p>
<p>Additional brokers will be discovered automatically as soon as rdkafka connects to a broker by querying the broker metadata.</p>
<p>If a broker name resolves to multiple addresses (and possibly address families) all will be used for connection attempts in round-robin fashion.</p>
<p><code>brokerlist</code> is a ,-separated list of brokers in the format: <code>&lt;broker1&gt;</code>,&lt;broker2&gt;,.. Where each broker is in either the host or URL based format: <code>&lt;host&gt;</code>[:&lt;port&gt;] <code>&lt;proto&gt;</code>://&lt;host&gt;[:port] <code>&lt;proto&gt;</code> is either <code>PLAINTEXT</code>, <code>SSL</code>, <code>SASL</code>, <code>SASL_PLAINTEXT</code> The two formats can be mixed but ultimately the value of the `security.protocol` config property decides what brokers are allowed.</p>
<p>Example: brokerlist = "broker1:10000,broker2" brokerlist = "SSL://broker3:9000,ssl://broker2"</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of brokers successfully added.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Brokers may also be defined with the <code>metadata.broker.list</code> or <code>bootstrap.servers</code> configuration property (preferred method). </dd></dl>

</div>
</div>
<a class="anchor" id="a9e4af9adee414af74c7817403f7c4a53"></a><!-- doxytag: member="rdkafka.h::rd_kafka_set_logger" ref="a9e4af9adee414af74c7817403f7c4a53" args="(rd_kafka_t *rk, void(*func)(const rd_kafka_t *rk, int level, const char *fac, const char *buf))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT RD_DEPRECATED void rd_kafka_set_logger </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(const rd_kafka_t *rk, int level, const char *fac, const char *buf)&nbsp;</td>
          <td class="paramname"> <em>func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set logger function. </p>
<p>The default is to print to stderr, but a syslog logger is also available, see rd_kafka_log_(print|syslog) for the builtin alternatives. Alternatively the application may provide its own logger callback. Or pass 'func' as NULL to disable logging.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>Use <a class="el" href="rdkafka_8h.html#a06ade2ca41f32eb82c6f7e3d4acbe19f" title="Set logger callback.">rd_kafka_conf_set_log_cb()</a></dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><code>rk</code> may be passed as NULL in the callback. </dd></dl>

</div>
</div>
<a class="anchor" id="acadeefced6bb60acd27e7a0dad553aa4"></a><!-- doxytag: member="rdkafka.h::rd_kafka_set_log_level" ref="acadeefced6bb60acd27e7a0dad553aa4" args="(rd_kafka_t *rk, int level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_set_log_level </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specifies the maximum logging level produced by internal kafka logging and debugging. </p>
<p>If the <code>\"debug\"</code> configuration property is set the level is automatically adjusted to <code>LOG_DEBUG</code> (7). </p>

</div>
</div>
<a class="anchor" id="ad4b3b7659cf9a79d3353810d6b625bb7"></a><!-- doxytag: member="rdkafka.h::rd_kafka_outq_len" ref="ad4b3b7659cf9a79d3353810d6b625bb7" args="(rd_kafka_t *rk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_outq_len </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the current out queue length. </p>
<p>The out queue contains messages waiting to be sent to, or acknowledged by, the broker.</p>
<p>An application should wait for this queue to reach zero before terminating to make sure outstanding requests (such as offset commits) are fully processed.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of messages in the out queue. </dd></dl>

</div>
</div>
<a class="anchor" id="a27a46f74ec4ccc9c0b36dbcf546908a1"></a><!-- doxytag: member="rdkafka.h::rd_kafka_dump" ref="a27a46f74ec4ccc9c0b36dbcf546908a1" args="(FILE *fp, rd_kafka_t *rk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_dump </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dumps rdkafka's internal state for handle <code>rk</code> to stream <code>fp</code>. </p>
<p>This is only useful for debugging rdkafka, showing state and statistics for brokers, topics, partitions, etc. </p>

</div>
</div>
<a class="anchor" id="a0901699375c972b807ba5255773f017f"></a><!-- doxytag: member="rdkafka.h::rd_kafka_thread_cnt" ref="a0901699375c972b807ba5255773f017f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_thread_cnt </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve the current number of threads in use by librdkafka. </p>
<p>Used by regression tests. </p>

</div>
</div>
<a class="anchor" id="aa90f2c92a382dbd0a090d40caa73356d"></a><!-- doxytag: member="rdkafka.h::rd_kafka_wait_destroyed" ref="aa90f2c92a382dbd0a090d40caa73356d" args="(int timeout_ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_wait_destroyed </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout_ms</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for all rd_kafka_t objects to be destroyed. </p>
<p>Returns 0 if all kafka objects are now destroyed, or -1 if the timeout was reached.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This function is deprecated. </dd></dl>

</div>
</div>
<a class="anchor" id="ab932d463be030a5e83ebfc5186ff20b8"></a><!-- doxytag: member="rdkafka.h::rd_kafka_unittest" ref="ab932d463be030a5e83ebfc5186ff20b8" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_unittest </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Run librdkafka's built-in unit-tests. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of failures, or 0 if all tests passed. </dd></dl>

</div>
</div>
<a class="anchor" id="a9bfa0a1dd3f866cbf0c82fc089bd7904"></a><!-- doxytag: member="rdkafka.h::rd_kafka_poll_set_consumer" ref="a9bfa0a1dd3f866cbf0c82fc089bd7904" args="(rd_kafka_t *rk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_poll_set_consumer </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Redirect the main (<a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4" title="Polls the provided kafka handle for events.">rd_kafka_poll()</a>) queue to the KafkaConsumer's queue (<a class="el" href="rdkafka_8h.html#a65cc6cb9bd72c4084f074af0361ceddf" title="Poll the consumer for messages or events.">rd_kafka_consumer_poll()</a>). </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>It is not permitted to call <a class="el" href="rdkafka_8h.html#ad50c431e3a29d14da534db49bd0682a4" title="Polls the provided kafka handle for events.">rd_kafka_poll()</a> after directing the main queue with <a class="el" href="rdkafka_8h.html#a9bfa0a1dd3f866cbf0c82fc089bd7904" title="Redirect the main (rd_kafka_poll()) queue to the KafkaConsumer&#39;s queue (rd_kafka_consumer_poll()...">rd_kafka_poll_set_consumer()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a108de3729a4aa609a72a458a9de02d1d"></a><!-- doxytag: member="rdkafka.h::rd_kafka_event_type" ref="a108de3729a4aa609a72a458a9de02d1d" args="(const rd_kafka_event_t *rkev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a8ea376a6d5fe278df583e873109b3c2f">rd_kafka_event_type_t</a> rd_kafka_event_type </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_event_t *&nbsp;</td>
          <td class="paramname"> <em>rkev</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the event type for the given event.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>As a convenience it is okay to pass <code>rkev</code> as NULL in which case RD_KAFKA_EVENT_NONE is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a608193d1fb486f78c79497c8c5b63866"></a><!-- doxytag: member="rdkafka.h::rd_kafka_event_name" ref="a608193d1fb486f78c79497c8c5b63866" args="(const rd_kafka_event_t *rkev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT const char* rd_kafka_event_name </td>
          <td>(</td>
          <td class="paramtype">const rd_kafka_event_t *&nbsp;</td>
          <td class="paramname"> <em>rkev</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the event type's name for the given event.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>As a convenience it is okay to pass <code>rkev</code> as NULL in which case the name for RD_KAFKA_EVENT_NONE is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="af1835c85aa202caf629861f29f475099"></a><!-- doxytag: member="rdkafka.h::rd_kafka_event_destroy" ref="af1835c85aa202caf629861f29f475099" args="(rd_kafka_event_t *rkev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void rd_kafka_event_destroy </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_event_t *&nbsp;</td>
          <td class="paramname"> <em>rkev</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy an event. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Any references to this event, such as extracted messages, will not be usable after this call.</dd>
<dd>
As a convenience it is okay to pass <code>rkev</code> as NULL in which case no action is performed. </dd></dl>

</div>
</div>
<a class="anchor" id="a3a855eb7bdf17f5797d4911362a5fc7c"></a><!-- doxytag: member="rdkafka.h::rd_kafka_event_message_next" ref="a3a855eb7bdf17f5797d4911362a5fc7c" args="(rd_kafka_event_t *rkev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a>* rd_kafka_event_message_next </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_event_t *&nbsp;</td>
          <td class="paramname"> <em>rkev</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the next message from an event.</dd></dl>
<p>Call repeatedly until it returns NULL.</p>
<p>Event types:</p>
<ul>
<li>RD_KAFKA_EVENT_FETCH (1 message)</li>
<li>RD_KAFKA_EVENT_DR (&gt;=1 message(s))</li>
</ul>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The returned message(s) MUST NOT be freed with <a class="el" href="rdkafka_8h.html#a35e0c519209d1afe9e29468f766c1c24" title="Frees resources for rkmessage and hands ownership back to rdkafka.">rd_kafka_message_destroy()</a>.</dd>
<dd>
on_consume() interceptor may be called from this function prior to passing message to application. </dd></dl>

</div>
</div>
<a class="anchor" id="a18a17000ebe58eabcdafab37924442b8"></a><!-- doxytag: member="rdkafka.h::rd_kafka_event_message_array" ref="a18a17000ebe58eabcdafab37924442b8" args="(rd_kafka_event_t *rkev, const rd_kafka_message_t **rkmessages, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT size_t rd_kafka_event_message_array </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_event_t *&nbsp;</td>
          <td class="paramname"> <em>rkev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrd__kafka__message__t.html">rd_kafka_message_t</a> **&nbsp;</td>
          <td class="paramname"> <em>rkmessages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extacts <code>size</code> message(s) from the event into the pre-allocated array <code>rkmessages</code>. </p>
<p>Event types:</p>
<ul>
<li>RD_KAFKA_EVENT_FETCH (1 message)</li>
<li>RD_KAFKA_EVENT_DR (&gt;=1 message(s))</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of messages extracted.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>on_consume() interceptor may be called from this function prior to passing message to application. </dd></dl>

</div>
</div>
<a class="anchor" id="a61d9d106c8956f379bb77d393b8acf90"></a><!-- doxytag: member="rdkafka.h::rd_kafka_event_message_count" ref="a61d9d106c8956f379bb77d393b8acf90" args="(rd_kafka_event_t *rkev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT size_t rd_kafka_event_message_count </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_event_t *&nbsp;</td>
          <td class="paramname"> <em>rkev</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of remaining messages in the event.</dd></dl>
<p>Event types:</p>
<ul>
<li>RD_KAFKA_EVENT_FETCH (1 message)</li>
<li>RD_KAFKA_EVENT_DR (&gt;=1 message(s)) </li>
</ul>

</div>
</div>
<a class="anchor" id="aa28b7d6bb4885843f9a8b9bafa0e15a5"></a><!-- doxytag: member="rdkafka.h::rd_kafka_event_error" ref="aa28b7d6bb4885843f9a8b9bafa0e15a5" args="(rd_kafka_event_t *rkev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_event_error </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_event_t *&nbsp;</td>
          <td class="paramname"> <em>rkev</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the error code for the event.</dd></dl>
<p>Event types:</p>
<ul>
<li>all </li>
</ul>

</div>
</div>
<a class="anchor" id="ad76a1b2d6c4f1727725b075678b88793"></a><!-- doxytag: member="rdkafka.h::rd_kafka_event_error_string" ref="ad76a1b2d6c4f1727725b075678b88793" args="(rd_kafka_event_t *rkev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT const char* rd_kafka_event_error_string </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_event_t *&nbsp;</td>
          <td class="paramname"> <em>rkev</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the error string (if any). An application should check that <a class="el" href="rdkafka_8h.html#aa28b7d6bb4885843f9a8b9bafa0e15a5">rd_kafka_event_error()</a> returns non-zero before calling this function.</dd></dl>
<p>Event types:</p>
<ul>
<li>all </li>
</ul>

</div>
</div>
<a class="anchor" id="a8650ed2a19108d490a65c9aff3e66525"></a><!-- doxytag: member="rdkafka.h::rd_kafka_event_opaque" ref="a8650ed2a19108d490a65c9aff3e66525" args="(rd_kafka_event_t *rkev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT void* rd_kafka_event_opaque </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_event_t *&nbsp;</td>
          <td class="paramname"> <em>rkev</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the user opaque (if any)</dd></dl>
<p>Event types:</p>
<ul>
<li>RD_KAFKA_OFFSET_COMMIT </li>
</ul>

</div>
</div>
<a class="anchor" id="a535efaa16772642d724bedca414c17c7"></a><!-- doxytag: member="rdkafka.h::rd_kafka_event_log" ref="a535efaa16772642d724bedca414c17c7" args="(rd_kafka_event_t *rkev, const char **fac, const char **str, int *level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_event_log </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_event_t *&nbsp;</td>
          <td class="paramname"> <em>rkev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>fac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>level</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract log message from the event. </p>
<p>Event types:</p>
<ul>
<li>RD_KAFKA_EVENT_LOG</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success or -1 if unsupported event type. </dd></dl>

</div>
</div>
<a class="anchor" id="ae8572e38ffb452f96d13a2d046fb71d9"></a><!-- doxytag: member="rdkafka.h::rd_kafka_event_stats" ref="ae8572e38ffb452f96d13a2d046fb71d9" args="(rd_kafka_event_t *rkev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT const char* rd_kafka_event_stats </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_event_t *&nbsp;</td>
          <td class="paramname"> <em>rkev</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract stats from the event. </p>
<p>Event types:</p>
<ul>
<li>RD_KAFKA_EVENT_STATS</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>stats json string.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>the returned string will be freed automatically along with the event object </dd></dl>

</div>
</div>
<a class="anchor" id="abc8f98c9b35be497251fb8515e9e6633"></a><!-- doxytag: member="rdkafka.h::rd_kafka_event_topic_partition_list" ref="abc8f98c9b35be497251fb8515e9e6633" args="(rd_kafka_event_t *rkev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="structrd__kafka__topic__partition__list__t.html">rd_kafka_topic_partition_list_t</a>* rd_kafka_event_topic_partition_list </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_event_t *&nbsp;</td>
          <td class="paramname"> <em>rkev</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the topic partition list from the event.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The list MUST NOT be freed with <a class="el" href="rdkafka_8h.html#a0c0ab2640e5e96113ce108ab78f475d0" title="Free all resources used by the list and the list itself.">rd_kafka_topic_partition_list_destroy()</a></dd></dl>
<p>Event types:</p>
<ul>
<li>RD_KAFKA_EVENT_REBALANCE</li>
<li>RD_KAFKA_EVENT_OFFSET_COMMIT </li>
</ul>

</div>
</div>
<a class="anchor" id="abf4cce46d6e566dd35865c0451b76afe"></a><!-- doxytag: member="rdkafka.h::rd_kafka_event_topic_partition" ref="abf4cce46d6e566dd35865c0451b76afe" args="(rd_kafka_event_t *rkev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="structrd__kafka__topic__partition__t.html">rd_kafka_topic_partition_t</a>* rd_kafka_event_topic_partition </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_event_t *&nbsp;</td>
          <td class="paramname"> <em>rkev</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>a newly allocated topic_partition container, if applicable for the event type, else NULL.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The returned pointer MUST be freed with <a class="el" href="rdkafka_8h.html#ac5a7b02e3af816cfacbcfa6468c40c9a" title="Destroy a rd_kafka_topic_partition_t.">rd_kafka_topic_partition_destroy()</a>.</dd></dl>
<p>Event types: RD_KAFKA_EVENT_ERROR (for partition level errors) </p>

</div>
</div>
<a class="anchor" id="a2f147ed1c554c9048893fb1adde86dfa"></a><!-- doxytag: member="rdkafka.h::rd_kafka_queue_poll" ref="a2f147ed1c554c9048893fb1adde86dfa" args="(rd_kafka_queue_t *rkqu, int timeout_ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT rd_kafka_event_t* rd_kafka_queue_poll </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_queue_t *&nbsp;</td>
          <td class="paramname"> <em>rkqu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout_ms</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Poll a queue for an event for max <code>timeout_ms</code>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an event, or NULL.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Use <a class="el" href="rdkafka_8h.html#af1835c85aa202caf629861f29f475099" title="Destroy an event.">rd_kafka_event_destroy()</a> to free the event. </dd></dl>

</div>
</div>
<a class="anchor" id="a13d80084f20a2800e863b97e465ce98e"></a><!-- doxytag: member="rdkafka.h::rd_kafka_queue_poll_callback" ref="a13d80084f20a2800e863b97e465ce98e" args="(rd_kafka_queue_t *rkqu, int timeout_ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT int rd_kafka_queue_poll_callback </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_queue_t *&nbsp;</td>
          <td class="paramname"> <em>rkqu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout_ms</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Poll a queue for events served through callbacks for max <code>timeout_ms</code>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of events served.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This API must only be used for queues with callbacks registered for all expected event types. E.g., not a message queue. </dd></dl>

</div>
</div>
<a class="anchor" id="a97bdeb12b99da10eff18767b3cadbfd2"></a><!-- doxytag: member="rdkafka.h::rd_kafka_conf_interceptor_add_on_conf_set" ref="a97bdeb12b99da10eff18767b3cadbfd2" args="(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_set_t *on_conf_set, void *ic_opaque)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_conf_interceptor_add_on_conf_set </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rdkafka_8h.html#adb146aa9dbc3a5d4bb4a5b53c1b86b0d">rd_kafka_interceptor_f_on_conf_set_t</a> *&nbsp;</td>
          <td class="paramname"> <em>on_conf_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ic_opaque</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append an on_conf_set() interceptor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>conf</em>&nbsp;</td><td>Configuration object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ic_name</em>&nbsp;</td><td>Interceptor name, used in logging. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>on_conf_set</em>&nbsp;</td><td>Function pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ic_opaque</em>&nbsp;</td><td>Opaque value that will be passed to the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing intercepted with the same <code>ic_name</code> and function has already been added to <code>conf</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a375ce703f6247377305dc6a5dfc84429"></a><!-- doxytag: member="rdkafka.h::rd_kafka_conf_interceptor_add_on_conf_dup" ref="a375ce703f6247377305dc6a5dfc84429" args="(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_dup_t *on_conf_dup, void *ic_opaque)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_conf_interceptor_add_on_conf_dup </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rdkafka_8h.html#a4339f06d7d4d02d06fbc401d279daeb2">rd_kafka_interceptor_f_on_conf_dup_t</a> *&nbsp;</td>
          <td class="paramname"> <em>on_conf_dup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ic_opaque</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append an on_conf_dup() interceptor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>conf</em>&nbsp;</td><td>Configuration object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ic_name</em>&nbsp;</td><td>Interceptor name, used in logging. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>on_conf_dup</em>&nbsp;</td><td>Function pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ic_opaque</em>&nbsp;</td><td>Opaque value that will be passed to the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing intercepted with the same <code>ic_name</code> and function has already been added to <code>conf</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a919ebd487a2717d6cbdf0d25102ea8ff"></a><!-- doxytag: member="rdkafka.h::rd_kafka_conf_interceptor_add_on_conf_destroy" ref="a919ebd487a2717d6cbdf0d25102ea8ff" args="(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_conf_destroy_t *on_conf_destroy, void *ic_opaque)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_conf_interceptor_add_on_conf_destroy </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rdkafka_8h.html#a39c5416d05a8262ae0a2937853c99257">rd_kafka_interceptor_f_on_conf_destroy_t</a> *&nbsp;</td>
          <td class="paramname"> <em>on_conf_destroy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ic_opaque</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append an on_conf_destroy() interceptor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>conf</em>&nbsp;</td><td>Configuration object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ic_name</em>&nbsp;</td><td>Interceptor name, used in logging. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>on_conf_destroy</em>&nbsp;</td><td>Function pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ic_opaque</em>&nbsp;</td><td>Opaque value that will be passed to the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Multiple on_conf_destroy() interceptors are allowed to be added to the same configuration object. </dd></dl>

</div>
</div>
<a class="anchor" id="a002ef1d350176725b6e9ba93548edf40"></a><!-- doxytag: member="rdkafka.h::rd_kafka_conf_interceptor_add_on_new" ref="a002ef1d350176725b6e9ba93548edf40" args="(rd_kafka_conf_t *conf, const char *ic_name, rd_kafka_interceptor_f_on_new_t *on_new, void *ic_opaque)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_conf_interceptor_add_on_new </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_conf_t *&nbsp;</td>
          <td class="paramname"> <em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rdkafka_8h.html#a045854635d67e89de3098a0d5f53cc39">rd_kafka_interceptor_f_on_new_t</a> *&nbsp;</td>
          <td class="paramname"> <em>on_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ic_opaque</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append an on_new() interceptor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>conf</em>&nbsp;</td><td>Configuration object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ic_name</em>&nbsp;</td><td>Interceptor name, used in logging. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>on_send</em>&nbsp;</td><td>Function pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ic_opaque</em>&nbsp;</td><td>Opaque value that will be passed to the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Since the on_new() interceptor is added to the configuration object it may be copied by <a class="el" href="rdkafka_8h.html#a8cbfe15c6978ff09870e82cb524c673d" title="Creates a copy/duplicate of configuration object conf.">rd_kafka_conf_dup()</a>. An interceptor implementation must thus be able to handle the same interceptor,ic_opaque tuple to be used by multiple client instances.</dd>
<dd>
An interceptor plugin should check the return value to make sure it has not already been added.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing intercepted with the same <code>ic_name</code> and function has already been added to <code>conf</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a11b835cb99dc1cfa03c52465b9837a47"></a><!-- doxytag: member="rdkafka.h::rd_kafka_interceptor_add_on_destroy" ref="a11b835cb99dc1cfa03c52465b9837a47" args="(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_destroy_t *on_destroy, void *ic_opaque)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_interceptor_add_on_destroy </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rdkafka_8h.html#a3eae9c1d37ab4effd55bb8ed5177ac4d">rd_kafka_interceptor_f_on_destroy_t</a> *&nbsp;</td>
          <td class="paramname"> <em>on_destroy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ic_opaque</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append an on_destroy() interceptor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rk</em>&nbsp;</td><td>Client instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ic_name</em>&nbsp;</td><td>Interceptor name, used in logging. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>on_destroy</em>&nbsp;</td><td>Function pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ic_opaque</em>&nbsp;</td><td>Opaque value that will be passed to the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing intercepted with the same <code>ic_name</code> and function has already been added to <code>conf</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="af6fb1b8884444c63b6930a7bd6122cb6"></a><!-- doxytag: member="rdkafka.h::rd_kafka_interceptor_add_on_send" ref="af6fb1b8884444c63b6930a7bd6122cb6" args="(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_send_t *on_send, void *ic_opaque)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_interceptor_add_on_send </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rdkafka_8h.html#a4b71a63f37c4d94cdb1d05e88f120988">rd_kafka_interceptor_f_on_send_t</a> *&nbsp;</td>
          <td class="paramname"> <em>on_send</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ic_opaque</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append an on_send() interceptor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rk</em>&nbsp;</td><td>Client instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ic_name</em>&nbsp;</td><td>Interceptor name, used in logging. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>on_send</em>&nbsp;</td><td>Function pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ic_opaque</em>&nbsp;</td><td>Opaque value that will be passed to the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing intercepted with the same <code>ic_name</code> and function has already been added to <code>conf</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="abaf475ab47fff47ab796be1cecbbd370"></a><!-- doxytag: member="rdkafka.h::rd_kafka_interceptor_add_on_acknowledgement" ref="abaf475ab47fff47ab796be1cecbbd370" args="(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_acknowledgement_t *on_acknowledgement, void *ic_opaque)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_interceptor_add_on_acknowledgement </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rdkafka_8h.html#aca93ab41df25cab562b9a4cf6c0e7320">rd_kafka_interceptor_f_on_acknowledgement_t</a> *&nbsp;</td>
          <td class="paramname"> <em>on_acknowledgement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ic_opaque</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append an on_acknowledgement() interceptor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rk</em>&nbsp;</td><td>Client instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ic_name</em>&nbsp;</td><td>Interceptor name, used in logging. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>on_acknowledgement</em>&nbsp;</td><td>Function pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ic_opaque</em>&nbsp;</td><td>Opaque value that will be passed to the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing intercepted with the same <code>ic_name</code> and function has already been added to <code>conf</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0e722a9930897bba81b33de5fe95b6ed"></a><!-- doxytag: member="rdkafka.h::rd_kafka_interceptor_add_on_consume" ref="a0e722a9930897bba81b33de5fe95b6ed" args="(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_consume_t *on_consume, void *ic_opaque)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_interceptor_add_on_consume </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rdkafka_8h.html#aeafe5c26d64281c1f9a2e2f77f774fa4">rd_kafka_interceptor_f_on_consume_t</a> *&nbsp;</td>
          <td class="paramname"> <em>on_consume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ic_opaque</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append an on_consume() interceptor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rk</em>&nbsp;</td><td>Client instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ic_name</em>&nbsp;</td><td>Interceptor name, used in logging. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>on_consume</em>&nbsp;</td><td>Function pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ic_opaque</em>&nbsp;</td><td>Opaque value that will be passed to the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing intercepted with the same <code>ic_name</code> and function has already been added to <code>conf</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0d3e29337dbf11762b5a7e492b77b781"></a><!-- doxytag: member="rdkafka.h::rd_kafka_interceptor_add_on_commit" ref="a0d3e29337dbf11762b5a7e492b77b781" args="(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_commit_t *on_commit, void *ic_opaque)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_interceptor_add_on_commit </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rdkafka_8h.html#a4ce7c3dfd327ce6512245302be4fe067">rd_kafka_interceptor_f_on_commit_t</a> *&nbsp;</td>
          <td class="paramname"> <em>on_commit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ic_opaque</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append an on_commit() interceptor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rk</em>&nbsp;</td><td>Client instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ic_name</em>&nbsp;</td><td>Interceptor name, used in logging. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>on_commit()</em>&nbsp;</td><td>Function pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ic_opaque</em>&nbsp;</td><td>Opaque value that will be passed to the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing intercepted with the same <code>ic_name</code> and function has already been added to <code>conf</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a444032455f98839bef2fb76d15f663c3"></a><!-- doxytag: member="rdkafka.h::rd_kafka_interceptor_add_on_request_sent" ref="a444032455f98839bef2fb76d15f663c3" args="(rd_kafka_t *rk, const char *ic_name, rd_kafka_interceptor_f_on_request_sent_t *on_request_sent, void *ic_opaque)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RD_EXPORT <a class="el" href="rdkafka_8h.html#a03509bab51072c72a8dcf52337e6d5cb">rd_kafka_resp_err_t</a> rd_kafka_interceptor_add_on_request_sent </td>
          <td>(</td>
          <td class="paramtype">rd_kafka_t *&nbsp;</td>
          <td class="paramname"> <em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ic_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rdkafka_8h.html#afae0abf1b1a5a85da0e3e22c78e3c5bf">rd_kafka_interceptor_f_on_request_sent_t</a> *&nbsp;</td>
          <td class="paramname"> <em>on_request_sent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ic_opaque</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append an on_request_sent() interceptor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rk</em>&nbsp;</td><td>Client instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ic_name</em>&nbsp;</td><td>Interceptor name, used in logging. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>on_request_sent()</em>&nbsp;</td><td>Function pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ic_opaque</em>&nbsp;</td><td>Opaque value that will be passed to the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RD_KAFKA_RESP_ERR_NO_ERROR on success or RD_KAFKA_RESP_ERR__CONFLICT if an existing intercepted with the same <code>ic_name</code> and function has already been added to <code>conf</code>. </dd></dl>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 6 Mar 2018 for librdkafka by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
